%--------------------------------------------
%
% Package pgfplots
%
% Provides a user-friendly interface to create function plots (normal
% plots, semi-logplots and double-logplots).
% 
% It is based on Till Tantau's PGF package.
%
% Copyright 2007/2008/2009 by Christian Feuers√§nger.
%
% This program is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program.  If not, see <http://www.gnu.org/licenses/>.
%
%--------------------------------------------

% this is some kind of "plug-in" for pgfmanual-en-macros.tex which
% provides pretty printing of the code lines in 'codeexample'.
%
% It requires to be invoked with \pgfmanualprettyprintcode{#1} at the
% right place.
%
% ATTENTION:
% this is NOT a sophisticated syntax highlighter like lstlistings! 
% It has rather strict assumptions about how to use it (the input must
% have been read verbatim, for example).



% this 'if' should only be queried inside of
% '/codeexample/prettyprint/key value' -- nowwhere else!
\newif\ifpgfmanualkeyvalueneedsbraces

% Special code for syntax highlighting:
%
%
% USER INTERFACE
\pgfkeys{%
	% this key will be invoked whenever a key in key-value context has been identified.
	% #1 will be the keys name.
	/codeexample/prettyprint/key name/.code={#1},
	%
	% Will be invoked whenever the value of a key has been found.
	% It will be invoked AFTER 'key name' and not at all if there was
	% no value.
	%
	% #1: the key's name
	% #2: the key's value.
	%
	% The if \ifpgfmanualkeyvalueneedsbraces has to queried to check
	% whether '#2' had braces in the original input. These braces must
	% be inserted manually.
	/codeexample/prettyprint/key value/.code 2 args={%
		\ifpgfmanualkeyvalueneedsbraces
			\{%
			\pgfkeysalso{/codeexample/prettyprint/key value with style detection={#1}{#2}}%
			\}%
		\else
			\pgfkeysalso{/codeexample/prettyprint/key value with style detection={#1}{#2}}%
		\fi
	},
	% A helper macro for the default 'key value' implementation.
	/codeexample/prettyprint/key value with style detection/.code 2 args={%
		\pgfutil@in@{style}{#1}%
		\ifpgfutil@in@
			\pgfmanualprettyprintpgfkeys{#2}%
		\else
			\pgfkeysalso{/codeexample/prettyprint/key value display only={#2}}%
		\fi
	},%
	%
	% Will be invoked by the default 'key value' implementation to
	% typeset the value as such.
	/codeexample/prettyprint/key value display only/.code={#1},
	%
	% Used to typeset a single control sequence.
	% #1 is the control sequence's name as a sequence of catcode 12
	% tokens.
	/codeexample/prettyprint/cs/.code={#1},
	%
	% Used to typeset a single control sequence together with an
	% argument.
	% #1 is the control sequence's name and
	% #2 is the value. Braces need to be typeset manually.
	/codeexample/prettyprint/cs with args/.code 2 args={#1\{#2\}},
	%
	% For every identified control sequence, the key
	%    /codeexample/prettyprint/cs arguments/<CSNAME>
	% will be checked. If it exists, it contains an integer with the
	% number of arguments it takes.
	% The <CSNAME> must not contain the '\'.
	/codeexample/prettyprint/cs arguments/pgfkeys/.initial=1,
	%
	% For every identified control sequence, the key
	%	/codeexample/prettyprint/cs/<CSNAME>/.@cmd
	% will be checked. If it exists, it will be used instead of 
	% 'cs with args'. 
	%
	% The <CSNAME> must not contain the '\'.
	%
	% This allows special treatment for special
	% commands like \pgfkeys:
	/codeexample/prettyprint/cs/pgfkeys/.code 2 args={#1\{\pgfmanualprettyprintpgfkeys{#2}\}},
	/codeexample/prettyprint/cs arguments/begin/.initial=1,
	/codeexample/prettyprint/cs/begin/.code 2 args={#1\{#2\}},
	/codeexample/prettyprint/cs arguments/end/.initial=1,
	/codeexample/prettyprint/cs/end/.code 2 args={#1\{#2\}},
	%
	%
	% 
	% A predefined style which colors every identified token. It's
	% purpose is only debugging.
	/codeexample/prettyprint/colored/.style={%
		/codeexample/prettyprint/key name/.code={\textcolor{red!75!black}{##1}},
		/codeexample/prettyprint/key value display only/.code={\textcolor{yellow}{##1}},
		/codeexample/prettyprint/cs/.code={\textcolor{green}{##1}},
		/codeexample/prettyprint/cs with args/.code 2 args={\textcolor{green}{##1}\{\textcolor{orange}{##2}\}},
		/codeexample/prettyprint/cs arguments/pgfkeys/.initial=1,
		/codeexample/prettyprint/cs/pgfkeys/.code 2 args={\textcolor{green}{##1}\{\pgfmanualprettyprintpgfkeys{##2}\}},
		/codeexample/prettyprint/cs arguments/begin/.initial=1,
		/codeexample/prettyprint/cs/begin/.code 2 args={\textcolor{green}{##1}\{\textcolor{orange}{##2}\}},
		/codeexample/prettyprint/cs arguments/end/.initial=1,
		/codeexample/prettyprint/cs/end/.code 2 args={\textcolor{green}{##1}\{\textcolor{orange}{##2}\}},
	},%
	% A further debuggin helper.
	/codeexample/prettyprint/colored and verbose/.style={%
		/codeexample/prettyprint/colored,
		/codeexample/prettyprint/key name/.code={\message{[key name=##1]}\textcolor{red!75!black}{##1}},
		/codeexample/prettyprint/key value display only/.code={\def\temp{##1}\message{[key value=\meaning\temp]}\textcolor{yellow}{##1}},
		/codeexample/prettyprint/cs/.code={\message{[cs=##1]}\textcolor{green}{##1}},
		/codeexample/prettyprint/cs with args/.code 2 args={\def\temp{##2}\message{[cs with args={##1}{\meaning\temp}]}\textcolor{green}{##1}\{\textcolor{orange}{##2}\}},
	},%
	/codeexample/prettyprint/colored,
	/codeexample/prettyprint/colored and verbose,
}%

\newif\ifpgfmanualprettyenabled
\pgfmanualprettyenabledtrue

% Typesets '#1', possibly using some sort of pretty printer.
%
% The argument '#1' is expected to be a long token list in which
% 1. all characters have catcode 11 or 12 (normal letters),
% 2. white spaces, tabs and newlines have catcode 13 (are active).
%
% @see \pgfmanualprettyprintpgfkeys
\long\def\pgfmanualprettyprintcode#1{%
	\begingroup
	\ifpgfmanualprettyenabled
		\pgfmanualprettyprintstyles
		\pgfmanual@pretty@mainloop#1\pgfmanual@EOI
	\else
		#1%
	\fi
	\endgroup
}%
% DISABLE:
%\long\def\pgfmanualprettyprintcode#1{#1}%

\def\pgfmanualprettyprintstyles{%
\tracingmacros=2 \tracingcommands=2
\message{STARTING PRETTY PRINTING}%
	\def\{{\pgfmanual@pretty@lbrace}%
	\def\}{\pgfmanual@pretty@rbrace}%
	\pgfmanual@pretty@installcommenthandler
}%


\newif\ifpgfmanualprettycommentactive

% we can't use the \@typeset@till@return method for comments because
% the pretty printer needs full control over the token list.
%
% We try a replacement here.
%
% FIXME
% THIS INTRODUCES A NEW GROUP! Does that hurt the pretty printer??
% 
\def\pgfmanual@pretty@installcommenthandler{%
	\expandafter\def\pgfmanual@pretty@activepercent{%
		\begingroup
		\pgfmanualprettycommentactivetrue
		\expandafter\let\pgfmanual@pretty@activenl=\pgfmanual@pretty@recoveraftercomment
		\sl \% %
	}%
}%
\def\pgfmanual@pretty@recoveraftercomment{%
	\endgroup
	\pgfmanual@pretty@activenl
}%

\def\pgfmanual@EOI{\pgfmanual@EOI}%

{
	\catcode`\[=0
	\catcode`\\=12
	[gdef[pgfmanual@pretty@backslash{\}%
}
\begingroup
	\catcode`\[=1
	\catcode`\]=2
	\catcode`\{=12
	\catcode`\}=12
	\gdef\pgfmanual@pretty@lbrace[{]%
	\gdef\pgfmanual@pretty@rbrace[}]%
	\catcode`\{=1
	\catcode`\}=2
	\catcode`\[=12
	\catcode`\]=12
	\catcode`\,=12
	\catcode`\ =10\relax\gdef\pgfmanual@pretty@space{ }%
	\gdef\pgfmanual@pretty@lbracket{[}%
	\gdef\pgfmanual@pretty@rbracket{]}%
	\gdef\pgfmanual@pretty@comma{,}%
	\catcode`\==12
	\gdef\pgfmanual@pretty@eq{=}%
\endgroup
\begingroup
	\catcode`\%=12
	\gdef\pgfmanual@pretty@percent{%}
	\catcode`\%=13
	\gdef\pgfmanual@pretty@activepercent{%}
	\catcode`\^^M=13
	\gdef\pgfmanual@pretty@activenl{^^M}\endgroup

% loops through all tokens.
% #1 is a single token.
\long\def\pgfmanual@pretty@mainloop#1{%
	\def\pgfmanual@loc@TMPa{#1}%
	\ifx\pgfmanual@loc@TMPa\pgfmanual@EOI
		% stop iteration.
		\let\pgfmanual@pretty@mainloop@NEXT=\relax
	\else
		\ifpgfmanualprettycommentactive
			\let\pgfmanual@pretty@mainloop@NEXT=\pgfmanual@pretty@mainloop
			#1%
		\else
			\ifx\pgfmanual@loc@TMPa\pgfmanual@pretty@lbracket%
				% we found the start of OPTIONS '[ ... ]'.
				% Attempt syntax highlighting for pgfkeys:
				\let\pgfmanual@pretty@mainloop@NEXT=\pgfmanual@pretty@pgfkeys
			\else
				\ifx\pgfmanual@loc@TMPa\pgfmanual@pretty@backslash
					% we found the start of a control sequence '\command':
					%
					% collect the control sequence name into
					% \pgfmanual@loc@TMPa, but without the backslash:
					\let\pgfmanual@loc@TMPa=\pgfutil@empty
					\let\pgfmanual@pretty@mainloop@NEXT=\pgfmanual@pretty@collectcs@loop
				\else
					% normal processing. Just typeset the token.
					\let\pgfmanual@pretty@mainloop@NEXT=\pgfmanual@pretty@mainloop
					#1%
				\fi
			\fi
		\fi
	\fi
	\pgfmanual@pretty@mainloop@NEXT
}%


% loops through all tokens, assembling the cs name as it goes.
% #1 is a single token.
\def\pgfmanual@pretty@collectcs@loop#1{%
	\ifnum\lccode`#1=0
		% a csname may only use letters. And: only letters have a
		% positive lcccode!
		% This here is the first non-letter.
		\expandafter\pgfmanual@pretty@collectcs@loop@END\expandafter#1%
	\else
		% continue iterating and assemble the csname...
		\edef\pgfmanual@loc@TMPa{\pgfmanual@loc@TMPa #1}%
		\expandafter\pgfmanual@pretty@collectcs@loop
	\fi
}%
\def\pgfmanual@pretty@collectcs@loop@END{%
	\pgfkeysifdefined{/codeexample/prettyprint/cs arguments/\pgfmanual@loc@TMPa}{%
		% oh. The collected control sequence expects arguments. That
		% means a lot of work since there are no nestable braces in
		% the token list! All of them have catcode 12... we need to do
		% that manually.
		\let\pgfmanual@pretty@collectargs@finish=\pgfmanual@pretty@collectargs@finish@cs
		\def\pgfmanual@pretty@collectcs@loop@END@next{%
			\pgfmanual@pretty@collectargs{\pgfkeysvalueof{/codeexample/prettyprint/cs arguments/\pgfmanual@loc@TMPa}}%
		}%
	}{%
		% re-insert the backslash:
		\edef\pgfmanual@loc@TMPa{\pgfmanual@pretty@backslash \pgfmanual@loc@TMPa}%
		% ok, report the macro and continue with the main loop.
		\def\pgfmanual@loc@TMPb{\pgfkeysvalueof{/codeexample/prettyprint/cs/.@cmd}}%
		\expandafter\pgfmanual@loc@TMPb\pgfmanual@loc@TMPa\pgfeov
		\let\pgfmanual@pretty@collectcs@loop@END@next=\pgfmanual@pretty@mainloop
	}%
	\pgfmanual@pretty@collectcs@loop@END@next
}%

% Collects arguments inside of a token list, dealing with nested
% catcode-12-braces.
%
% #1: is the NUMBER of arguments to collect.
%
% PRECONDITION:
% 	there is a large token list following
% 	\pgfmanual@pretty@collectargs with balanced braces. The braces
% 	have \catcode 12.
% POSTCONDITION:
% 	the arguments will be collected as 
% 		'<result> := {<first arg>}{<second arg>}'
% 	and then, \pgfmanual@pretty@collectargs@finish{<result>} will be
% 	invoked. Just defined \pgfmanual@pretty@collectargs@finish
% 	properly.
%
% ATTENTION:
% 	\pgfmanual@pretty@collectargs@finish will be invoked with a SINGLE
% 	argument. However, if #1 > 1, this will contain further braces:
% 		\pgfmanual@pretty@collectargs@finish{{<first arg>}{<second arg>}}
% 	if #1=1, it will be
% 		\pgfmanual@pretty@collectargs@finish{<first arg>}
% 	i.e. without the extra set of braces.
% 	
\def\pgfmanual@pretty@collectargs#1{%
	\begingroup
	\edef\pgfmanual@loc@csargcount{#1}%
	\let\c@pgfmanual@pretty@openbracecount=\c@pgf@counta
	\let\c@pgfmanual@pretty@curargcount=\c@pgf@countb
	% I will track open braces and the number of completely
	% collected arguments here:
	\c@pgfmanual@pretty@openbracecount=0
	\c@pgfmanual@pretty@curargcount=0
	%
	% and I will accumulate the argument token lists as such here:
	\toksdef\t@pgfmanual@currentarg=0
	\toksdef\t@pgfmanual@allargs=1
	\t@pgfmanual@currentarg={}%
	\t@pgfmanual@allargs={}%
	%
	\pgfmanual@pretty@collectargs@loop
}%

% loops through all tokens, collecting the required number of
% arguments. This involves to track nested braces manually.
% #1 is a single token.
\def\pgfmanual@pretty@collectargs@loop#1{%
	\let\pgfmanual@pretty@collectargs@loop@NEXT=\pgfmanual@pretty@collectargs@loop
	\def\pgfmanual@loc@TMPc{#1}%
	\ifx\pgfmanual@loc@TMPc\pgfmanual@EOI
		\edef\pgfmanual@pretty@collectargs@loop@NEXT{%
			\noexpand\endgroup
			\noexpand\pgfmanual@pretty@collectargs@finish{\the\t@pgfmanual@allargs\the\t@pgfmanual@currentarg FIXME}%
		}%
	\else
		\ifpgfmanualprettycommentactive
			\t@pgfmanual@currentarg=\expandafter{\the\t@pgfmanual@currentarg#1}%
			\ifx\pgfmanual@loc@TMPc\pgfmanual@pretty@activenl
				\pgfmanualprettycommentactivefalse
			\fi
		\else
			\ifx\pgfmanual@loc@TMPc\pgfmanual@pretty@activepercent
				\t@pgfmanual@currentarg=\expandafter{\the\t@pgfmanual@currentarg#1}%
				\pgfmanualprettycommentactivetrue
			\else
				\ifx\pgfmanual@loc@TMPc\pgfmanual@pretty@lbrace
					\advance\c@pgfmanual@pretty@openbracecount by1
					\ifnum\c@pgfmanual@pretty@openbracecount>1
						\t@pgfmanual@currentarg=\expandafter{\the\t@pgfmanual@currentarg#1}%
					\fi
				\else
					\ifx\pgfmanual@loc@TMPc\pgfmanual@pretty@rbrace
						\advance\c@pgfmanual@pretty@openbracecount by-1
						\ifnum\c@pgfmanual@pretty@openbracecount=0
							% we have one complete argument ready!
							% append it -- with REAL braces if needed:
							\ifnum\pgfmanual@loc@csargcount=1
								% no extra braces.
								\t@pgfmanual@allargs=\t@pgfmanual@currentarg
							\else
								\edef\pgfmanual@loc@TMPc{\the\t@pgfmanual@allargs{\the\t@pgfmanual@currentarg}}%
								\t@pgfmanual@allargs=\expandafter{\pgfmanual@loc@TMPc}%
							\fi
							%
							% check it we need more arguments:
							\advance\c@pgfmanual@pretty@curargcount by1
							\ifnum\c@pgfmanual@pretty@curargcount=\pgfmanual@loc@csargcount\relax
								\edef\pgfmanual@pretty@collectargs@loop@NEXT{%
									\noexpand\endgroup
									\noexpand\pgfmanual@pretty@collectargs@finish{\the\t@pgfmanual@allargs}%
								}%
							\fi
						\else
							\t@pgfmanual@currentarg=\expandafter{\the\t@pgfmanual@currentarg#1}%
						\fi
					\else
						\t@pgfmanual@currentarg=\expandafter{\the\t@pgfmanual@currentarg#1}%
					\fi
				\fi
			\fi
		\fi
	\fi
	\pgfmanual@pretty@collectargs@loop@NEXT
}%


% Collects tokens inside of a token list up to a single delimiting token, dealing with nested
% catcode-12-braces. 
%
% #1: is the NUMBER of arguments to collect.
%
% PRECONDITION:
% 	there is a large token list following
% 	\pgfmanual@pretty@collectargs with balanced braces. The braces
% 	have \catcode 12.
% POSTCONDITION:
% 	the arguments will be collected as 
% 		'<result> := <token list>'
% 	and then, \pgfmanual@pretty@collectargs@finish{<result>} will be
% 	invoked. Just define \pgfmanual@pretty@collectargs@finish
% 	properly.
%
% @see \pgfmanual@pretty@collectargs
\def\pgfmanual@pretty@collectupto#1{%
	\begingroup
	\def\pgfmanual@loc@delimittoken{#1}%
	\let\c@pgfmanual@pretty@openbracecount=\c@pgf@counta
	% I will track open braces here:
	\c@pgfmanual@pretty@openbracecount=0
	%
	% and I will accumulate the argument token lists as such here:
	\toksdef\t@pgfmanual@currentarg=0
	\t@pgfmanual@currentarg={}%
	%
	\pgfmanual@pretty@collectupto@loop
}%

% loops through all tokens, collecting the required number of
% arguments. This involves to track nested braces manually.
% #1 is a single token.
\def\pgfmanual@pretty@collectupto@loop#1{%
	\let\pgfmanual@pretty@collectup@loop@NEXT=\pgfmanual@pretty@collectupto@loop
	\def\pgfmanual@loc@TMPc{#1}%
	\ifx\pgfmanual@loc@TMPc\pgfmanual@EOI
		\edef\pgfmanual@pretty@collectup@loop@NEXT{%
			\noexpand\endgroup
			\noexpand\pgfmanual@pretty@collectargs@finish{\the\t@pgfmanual@currentarg}%
		}%
	\else
		\ifpgfmanualprettycommentactive
			\t@pgfmanual@currentarg=\expandafter{\the\t@pgfmanual@currentarg#1}%
			\ifx\pgfmanual@loc@TMPc\pgfmanual@pretty@activenl
				\pgfmanualprettycommentactivefalse
			\fi
		\else
			\ifx\pgfmanual@loc@TMPc\pgfmanual@pretty@activepercent
				\t@pgfmanual@currentarg=\expandafter{\the\t@pgfmanual@currentarg#1}%
				\pgfmanualprettycommentactivetrue
			\else
				\ifx\pgfmanual@loc@TMPc\pgfmanual@pretty@lbrace
					\advance\c@pgfmanual@pretty@openbracecount by1
					\t@pgfmanual@currentarg=\expandafter{\the\t@pgfmanual@currentarg#1}%
				\else
					\ifx\pgfmanual@loc@TMPc\pgfmanual@pretty@rbrace
						\advance\c@pgfmanual@pretty@openbracecount by-1
						\t@pgfmanual@currentarg=\expandafter{\the\t@pgfmanual@currentarg#1}%
					\else
						\ifx\pgfmanual@loc@TMPc\pgfmanual@loc@delimittoken
							\ifnum\c@pgfmanual@pretty@openbracecount=0
								% do NOT include the delimit token.
								\edef\pgfmanual@pretty@collectup@loop@NEXT{%
									\noexpand\endgroup
									\noexpand\pgfmanual@pretty@collectargs@finish{\the\t@pgfmanual@currentarg}%
								}%
							\else
								\t@pgfmanual@currentarg=\expandafter{\the\t@pgfmanual@currentarg#1}%
							\fi
						\else
							\t@pgfmanual@currentarg=\expandafter{\the\t@pgfmanual@currentarg#1}%
						\fi
					\fi
				\fi
			\fi
		\fi
	\fi
	\pgfmanual@pretty@collectup@loop@NEXT
}%

\def\pgfmanual@pretty@collectargs@finish@cs#1{%
\message{collected the arguments '#1' for \pgfmanual@loc@TMPa!}%
	% report the macro and its arguments:
	\pgfkeysifdefined{/codeexample/prettyprint/cs/\pgfmanual@loc@TMPa/.@cmd}{%
		% oh, we have a separate routine for this macro! Ok, use it:
		\edef\pgfmanual@loc@TMPb{\noexpand\pgfkeysvalueof{/codeexample/prettyprint/cs/\pgfmanual@loc@TMPa/.@cmd}}%
	}{%
		% use the generic routine:
		% re-insert the backslash:
		\edef\pgfmanual@loc@TMPb{\noexpand\pgfkeysvalueof{/codeexample/prettyprint/cs with args/.@cmd}}%
	}%
	\edef\pgfmanual@loc@TMPa{{\pgfmanual@pretty@backslash\pgfmanual@loc@TMPa}{#1}}%
	\expandafter\pgfmanual@loc@TMPb\pgfmanual@loc@TMPa\pgfeov
	% and continue with the main loop.
	\pgfmanual@pretty@mainloop
}%

% A user macro which pretty prints a set of keys.
\long\def\pgfmanualprettyprintpgfkeys#1{%
	\ifpgfmanualprettyenabled
		\begingroup
		\pgfmanualprettyprintstyles
		\pgfmanual@pretty@pgfkeys@loop#1\pgfmanual@EOI
		\endgroup
	\else
		#1%
	\fi
}

% FIXME: DAS HIER IST FALSCH, WEIL KEINE NESTED BRACES GESUCHT WERDEN!
\def\pgfmanual@pretty@pgfkeys{%
	\let\pgfmanual@pretty@collectargs@finish=\pgfmanual@pretty@pgfkeys@start
	\pgfmanual@pretty@collectupto]%
}%
\long\def\pgfmanual@pretty@pgfkeys@start#1{%
	[%
	\pgfmanual@pretty@pgfkeys@loop#1\pgfmanual@EOI
	]%
	\pgfmanual@pretty@mainloop
}%
% iterates through single tokens, detecting key names and values while
% it goes.
\long\def\pgfmanual@pretty@pgfkeys@loop#1{%
	\def\pgfmanual@loc@TMPa{#1}%
	\ifx\pgfmanual@loc@TMPa\pgfmanual@EOI
		\let\pgfmanual@pretty@pgfkeys@loop@NEXT=\relax
	\else
		\let\pgfmanual@pretty@pgfkeys@loop@NEXT=\pgfmanual@pretty@pgfkeys@loop
		\ifpgfmanualprettycommentactive
			#1%
		\else
			\ifnum13=\catcode`#1
				% we found a white space (space, TAB or NL) or comment
				#1%
			\else
				\ifx\pgfmanual@loc@TMPa\pgfmanual@pretty@comma%
					%\let\pgfmanual@pretty@pgfkeys@loop@NEXT=\pgfmanual@pretty@pgfkeys@checkforEOI
					,%
				\else
					\ifnum10=\catcode`#1
						% another white space... I thought they'd have
						% catcode 13. doesn't matter.
						#1%
					\else
						\ifx\pgfmanual@loc@TMPa\pgfmanual@pretty@lbrace
							% braces may not occur in the first place -
							% but there are circumstances where it is
							% convenient to deal with them here. Do it.
							#1%
						\else
							\ifx\pgfmanual@loc@TMPa\pgfmanual@pretty@rbrace
								#1%
							\else
								% found the beginning of a key! 
								% We will collect the key name into
								% \toks0.
								\toks0={#1}%
								%
								% Handle it:
								% FIXME what if we found an opening brace!?
								\let\pgfmanual@pretty@pgfkeys@loop@NEXT=\pgfmanual@pretty@pgfkeys@collectkey%
							\fi
						\fi
					\fi
				\fi
			\fi
		\fi
	\fi
	\pgfmanual@pretty@pgfkeys@loop@NEXT
}%
\def\pgfmanual@pretty@pgfkeys@collectkey#1{%
	\def\pgfmanual@loc@TMPb{#1}%
	\let\pgfmanual@pretty@pgfkeys@collectkey@next=\pgfmanual@pretty@pgfkeys@collectkey
	\ifx\pgfmanual@loc@TMPb\pgfmanual@EOI
		% finish key name.
		\expandafter\pgfmanual@pretty@pgfkeys@processkey\expandafter{\the\toks0 }%
		\let\pgfmanual@pretty@pgfkeys@collectkey@next=\relax
	\else
		\ifx\pgfmanual@loc@TMPb\pgfmanual@pretty@eq
			% finish key name.
			\expandafter\pgfmanual@pretty@pgfkeys@processkey\expandafter{\the\toks0 }%
			#1%
			% now, we do the same with the value - we collect it into
			% \toks0.
			\toks0={}%
			\def\pgfmanual@pretty@pgfkeys@collectvalue@hasconsumedspaces{0}%
			\let\pgfmanual@pretty@pgfkeys@collectkey@next=\pgfmanual@pretty@pgfkeys@collectvalue
		\else
			\ifx\pgfmanual@loc@TMPb\pgfmanual@pretty@comma
				% finish key name.
				\expandafter\pgfmanual@pretty@pgfkeys@processkey\expandafter{\the\toks0 }%
				#1%
				\let\pgfmanual@pretty@pgfkeys@collectkey@next=\pgfmanual@pretty@pgfkeys@loop
			\else
				\ifx\pgfmanual@loc@TMPb\pgfmanual@pretty@activenl
					% finish key name before newline. This is not
					% necessarily as in TeX, but its simpler here
					% because we don't need special cases for comments
					% and we don't need to gobble following white
					% spaces.
					\expandafter\pgfmanual@pretty@pgfkeys@processkey\expandafter{\the\toks0 }%
					#1%
					\let\pgfmanual@pretty@pgfkeys@collectkey@next=\pgfmanual@pretty@pgfkeys@loop
				\else
					\toks0=\expandafter{\the\toks0 #1}%
				\fi
			\fi
		\fi
	\fi
	\pgfmanual@pretty@pgfkeys@collectkey@next
}%
\def\pgfmanual@pretty@pgfkeys@collectvalue#1{%
	\def\pgfmanual@loc@TMPb{#1}%
	\let\pgfmanual@pretty@pgfkeys@collectvalue@next=\pgfmanual@pretty@pgfkeys@collectvalue
	\ifx\pgfmanual@loc@TMPb\pgfmanual@EOI
		% finish key value.
		\pgfmanualkeyvalueneedsbracesfalse
		\expandafter\pgfmanual@pretty@pgfkeys@processvalue\expandafter{\the\toks0 }%
		\let\pgfmanual@pretty@pgfkeys@collectvalue@next=\relax
	\else
		\def\pgfmanual@pretty@isconsumed{0}%
		\if\pgfmanual@pretty@pgfkeys@collectvalue@hasconsumedspaces0%
			\ifnum13=\catcode`#1
				% we found a white space (space, TAB or NL)
				#1%
				\def\pgfmanual@pretty@isconsumed{1}%
			\else
				\ifnum10=\catcode`#1
					% another white space... I thought they'd have
					% catcode 13. doesn't matter.
					\def\pgfmanual@pretty@isconsumed{1}%
					#1%
				\fi
			\fi
		\fi
		\if\pgfmanual@pretty@isconsumed0%
			\ifx\pgfmanual@loc@TMPb\pgfmanual@pretty@lbrace
				\let\pgfmanual@pretty@collectargs@finish=\pgfmanual@pretty@collectargs@finish@value
				\def\pgfmanual@pretty@pgfkeys@collectvalue@next{%
					\pgfmanual@pretty@collectargs{1}#1%
				}%
			\else
				\ifx\pgfmanual@loc@TMPb\pgfmanual@pretty@comma
					% finish key value.
					\pgfmanualkeyvalueneedsbracesfalse
					\expandafter\pgfmanual@pretty@pgfkeys@processvalue\expandafter{\the\toks0 }%
					#1%
					\let\pgfmanual@pretty@pgfkeys@collectvalue@next=\pgfmanual@pretty@pgfkeys@loop
				\else
					\def\pgfmanual@pretty@pgfkeys@collectvalue@hasconsumedspaces{1}%
					\toks0=\expandafter{\the\toks0 #1}%
				\fi
			\fi
		\fi
	\fi
	\pgfmanual@pretty@pgfkeys@collectvalue@next
}%
\def\pgfmanual@pretty@collectargs@finish@value#1{%
	\pgfmanualkeyvalueneedsbracestrue
	\pgfmanual@pretty@pgfkeys@processvalue{#1}% the braces will be handled separately.
	% FIXME : this doesn't handle keys with more than one argument!
	% -> check for comma or EOI!
	\pgfmanual@pretty@pgfkeys@loop
}%

{\catcode`\^^M=13 \catcode`\ =13\relax\gdef\pgfmanual@pretty@restorespaces{\def^^M{\pgfmanual@pretty@space}\def {\pgfmanual@pretty@space}}}

% #1: the keys name
\def\pgfmanual@pretty@pgfkeys@processkey#1{%
	\begingroup
		\pgfmanual@pretty@restorespaces
		% remember this key name! It is used when we are dealing with
		% its value later... (if it has a value)
		\xdef\pgfmanual@pretty@pgfkeys@collectkey@keyname{#1}%
	\endgroup
	% report key name ...
	\def\pgfmanual@loc@TMPa{\pgfkeysvalueof{/codeexample/prettyprint/key name/.@cmd}}%
	\expandafter\pgfmanual@loc@TMPa\pgfmanual@pretty@pgfkeys@collectkey@keyname\pgfeov
}
\def\pgfmanual@pretty@pgfkeys@processvalue#1{%
	% report or process the value, depending on the keyname.
	% After all, it *may* be a style which needs to be pretty printed
	% as well.
	\pgfkeysifdefined{/codeexample/prettyprint/key value/\pgfmanual@pretty@pgfkeys@collectkey@keyname/.@cmd}{%
		% oh, we have a separate routine for this macro! Ok, use it:
		\edef\pgfmanual@loc@TMPb{\noexpand\pgfkeysvalueof{/codeexample/prettyprint/key value/\pgfmanual@pretty@pgfkeys@collectkey@keyname/.@cmd}}%
	}{%
		% use the generic routine:
		\edef\pgfmanual@loc@TMPb{\noexpand\pgfkeysvalueof{/codeexample/prettyprint/key value/.@cmd}}%
	}%
	\edef\pgfmanual@loc@TMPa{{\pgfmanual@pretty@pgfkeys@collectkey@keyname}}%
	\expandafter\pgfmanual@loc@TMPb\pgfmanual@loc@TMPa{#1}\pgfeov
}

