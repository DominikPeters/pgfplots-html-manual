% main=manual.tex

\section{The Reference}

\subsection{The Axis-Environments}
There is an axis environment for linear scaling, two for semi-logarithmic scaling and one for double-logarithmic scaling.
\begin{environment}{{axis}\oarg{options}}
	The axis environment for normal plots with linear axis scaling.

	The `|every linear axis|' style key can be modified with
\begin{codeexample}[code only]
\pgfplotsset{every linear axis/.append style={...}}
\end{codeexample}
to install styles specifically for linear axes. These styles can contain both \Tikz- and \PGFPlots\ options.
\end{environment}

\begin{environment}{{semilogxaxis}\oarg{options}}
The axis environment for logarithmic scaling of~$x$ and normal scaling of~$y$.
Use
\begin{codeexample}[code only]
\pgfplotsset{every semilogx axis/.append style={...}}
\end{codeexample}
to install styles specifically for the case with |xmode=log|, |ymode=normal|.

The logarithmic scaling means to apply the natural logarithm (base $e$) to each $x$ coordinate. Furthermore, ticks will be typeset as $10^{\text{\meta{exponent}}}$, see section~\ref{sec:number:printing} for more details.
\end{environment}

\begin{environment}{{semilogyaxis}\oarg{options}}
The axis environment for normal scaling of~$x$ and logarithmic scaling of~$y$,

The style `|every semilogy axis|' will be installed for each such plot.

The same remarks as for |semilogxaxis| apply here as well.
\end{environment}

\begin{environment}{{loglogaxis}\oarg{options}}
The axis environment for logarithmic scaling of both, $x$~and~$y$ axes,
As for the other axis possibilities, there is a style `|every loglog axis|' which is installed at the environment's beginning.

The same remarks as for |semilogxaxis| apply here as well.
\end{environment}

\noindent
They are all equivalent to
\begin{codeexample}[code only]
\begin{axis}[
	xmode=log|normal,
	ymode=log|normal]
...
\end{axis}
\end{codeexample}
\noindent
with properly set variables `|xmode|' and `|ymode|' (see below).

\subsection{The \protect\texttt{\protect\textbackslash addplot} Command: Coordinate Input}
\label{sec:addplot}%
\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[ymin=0,ymax=1,enlargelimits=false]
\addplot
	[blue!80!black,fill=blue,fill opacity=0.5] 
coordinates
{(0,0.1)    (0.1,0.15)  (0.2,0.5)   (0.3,0.62)
 (0.4,0.56) (0.5,0.58)  (0.6,0.65)  (0.7,0.6)
 (0.8,0.58) (0.9,0.55)  (1,0.52)} 
|- (axis cs:0,0) -- cycle;

\addplot
	[red,fill=red!90!black,opacity=0.5]
coordinates 
{(0,0.25)   (0.1,0.27)  (0.2,0.24)  (0.3,0.24)
 (0.4,0.26) (0.5,0.3)   (0.6,0.23)  (0.7,0.2)
 (0.8,0.15) (0.9,0.1)   (1,0.1)}
|- (axis cs:0,0) -- cycle;

\addplot[green!20!black] coordinates
	{(0,0.4) (0.2,0.75) (1,0.75)};
\end{axis}
\end{tikzpicture}
\end{codeexample}

\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}
\addplot+[id=parable,domain=-5:5] 
	gnuplot{4*x**2 - 5} 
	node[pin=180:{$4x^2-5$}]{};
\end{axis}
\end{tikzpicture}
\end{codeexample}

\pgfplotsexpensiveexample
\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}
	\addplot3[surf,domain=0:360,samples=40] 
		{sin(x)*sin(y)};	
	\end{axis}
\end{tikzpicture}
\end{codeexample}

\pgfplotsexpensiveexample
\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}[colormap/redyellow,colorbar]
	\addplot3[surf,shader=interp,
		domain=0:360,samples=40] 
		{sin(x)*sin(y)};	
	\end{axis}
\end{tikzpicture}
\end{codeexample}

\pgfplotsexpensiveexample
\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[view={60}{30}]
    \addplot3[surf,shader=flat,
		samples=20,
        domain=-1:0,y domain=0:2*pi,
        z buffer=sort]
        ({sqrt(1-x^2) * cos(deg(y))},
		 {sqrt( 1-x^2 ) * sin(deg(y))},
		 x);
\end{axis}
\end{tikzpicture}
\end{codeexample}

Inside of an axis environment, the |\addplot| command is the main user interface. It comes in two variants: |\addplot| for twodimensional visualization and |\addplot3| for threedimensional visualization.

\begin{command}{\addplot\oarg{options} \meta{input data} \meta{trailing path commands};}
\label{cmd:pgfplots:addplot}
This is the main plotting command, available within each axis environment. It can be used one or more times within an axis to add plots to the current axis. There is also an |\addplot3| command which is described in section~\ref{sec:3d}.

It reads point coordinates from one of the available input sources specified by \meta{input data}, updates limits, remembers \meta{options} for use in a legend (if any) and applies any necessary coordinate transformations (or logarithms).

The \meta{options} can be omitted in which case the next entry from the |cycle list| will be inserted as \meta{options}. These keys characterize the plot's type like linear interpolation, smooth plot, constant interpolation or bar plot and define colors, markers and line specifications\footnote{In version 1.2.2 and earlier, there was an explicit distiction between ``behaviour'' options like error bars, domain, number of samples etc.\ and ``style options'' like color, line width, markers etc. This distiction is obsolete now, simply collect everything into \meta{options}.}\index{Behavior Options}\index{Options!Distinction Behavior, Style Options}. Plot variants like error bars, the number of samples or a sample domain can also be configured in \meta{options}.

The \meta{input data} is one of several coordinate input tools which are described in more detail below. Finally, if |\addplot| successfully processed all coordinates from \meta{input data}, it generates \Tikz-drawing commands (for example |plot coordinate {...}|). If \meta{trailing path commands} is not empty, these arguments are appended to the final drawing command.

\noindent
Some more details:
\begin{itemize}
	\item The style \declaretext{/pgfplots/every axis plot} will be installed at the beginning of \meta{options}. That means you can use
\begin{codeexample}[code only]
\pgfplotsset{every axis plot/.append style={...}}
\end{codeexample}
	to add options to all your plots - maybe to set line widths to |thick|. Furthermore, if you have more than one plot inside of an axis, you can also use
\begin{codeexample}[code only]
\pgfplotsset{every axis plot no 3/.append style={...}}
\end{codeexample}
	to modify options for the plot with number~$3$ only. The first plot has number~$0$.
	\item The \meta{options} are remembered for the legend. They are available as `|current plot style|' as long as the path is not yet finished or in associated error bars.
	\item See subsection~\ref{sec:markers} for a list of available markers and line styles.
	\item For log plots, \PGFPlots\ will compute the natural logarithm $\log(\cdot)$ numerically. This works with normal fixed point numbers or in scientific notation. For example, the following numbers are valid input to |\addplot|.
\begin{codeexample}[]
\begin{tikzpicture}
\begin{loglogaxis}
\addplot coordinates {
	(769,   1.6227e-04)
	(1793,  4.4425e-05)
	(4097,  1.2071e-05)
	(9217,  3.2610e-06)
	(2.2e5, 2.1E-6)
	(1e6,   0.00003341)
	(2.3e7, 0.00131415)
};
\end{loglogaxis}
\end{tikzpicture}
\end{codeexample}
	You can represent arbitrarily small or very large numbers as long as its logarithm can be represented as a \TeX-length (up to about~$16384$). Of course, any coordinate~$x\le 0$ is not possible since the logarithm of a non-positive number is not defined. Such coordinates will be skipped automatically.

	\item For normal plots, \PGFPlots\ applies floating point arithmetics to support large or small numbers like 0.00000001234 or $1.234\cdot 10^{24}$. Its number range is much larger than \TeX's native support for numbers. The relative precision is at least~$5$ significant decimal digits for the mantisse. As soon as the axes limits are completely known, \PGFPlots\ applies a transformation which maps these floating point numbers into \TeX-precision using transformations
		\[ T_x(x) = 10^{s_x} \cdot x - a_x \text{ and } T_y(y) = 10^{s_y} \cdot y - a_y \]
	with properly chosen integers $s_x, s_y \in \Z$ and shifts $a_x,a_y\in \R$. Section~\ref{sec:disabledatascaling} contains a description of |disabledatascaling| and provides more details about the transformation.
	\index{Accuracy!Floating Point in \PGFPlots}%

	\item As a consequence of the coordinate parsing routines, you can't use the mathematical expression parsing method of \PGF\ as coordinates (that means: you will need to provide coordinates without suffixes like ``cm'' or ``pt'' and you can't invoke mathematical functions).
	
	\item If you did not specify axis limits for $x$ and $y$ manually, |\addplot| will compute them automatically. 
	The automatic computation of axis limits works as follows:
		\begin{enumerate}
			\item Every coordinate will be checked. Care has been taken to avoid \TeX's limited numerical capabilities.
			\item Since more than one |\addplot| command may be used inside of |\begin{axis}...\end{axis}|, all drawing commands will be postponed until |\end{axis}|.
		\end{enumerate}
\end{itemize}
\end{command}

\begin{addplot+}
Does the same like |\addplot[|\meta{options}|] ...;| except that \meta{options} are \emph{appended} to the arguments which would have been taken for |\addplot ...| (the element of the default list).

\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}
\addplot {sin(deg(x))};
\end{axis}
\end{tikzpicture}

\begin{tikzpicture}
\begin{axis}
\addplot+[only marks] {sin(deg(x))};
\end{axis}
\end{tikzpicture}
\end{codeexample}
\end{addplot+}

\subsubsection{Coordinate Lists}
\label{pgfplots:providing:input}

\begin{addplotoperation}[]{coordinates}{\marg{coordinate list}}
\label{pgfplots:addplot:coordinates}
The `|plot coordinates|' command is like that provided by \Tikz\ and reads its input data from a sequence of point coordinates, encapsulated in round braces.
\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}
\addplot coordinates {
	(0,0)
	(0.5,1)
	(1,2)
};
\end{axis}
\end{tikzpicture}
\end{codeexample}

You can also supply error coordinates (reliability bounds) if you are interested in error bars. Simply append the error coordinates with `|+- |\parg{ex,ey}' to the associated coordinate:
\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}
\addplot+[error bars/.cd,x dir=both,x explicit] 
coordinates {
	(0,0)   +- (0.1,0)
	(0.5,1) +- (0.4,0.2)
	(1,2)
	(2,5)   +- (1,0.1)
};
\end{axis}
\end{tikzpicture}
\end{codeexample}
or 
\begin{codeexample}[code only]
\addplot coordinates {
	 (900,1e-6) +- (0.1,0.2)
	(2600,5e-7) +- (0.2,0.5)
	(4000,7e-8) +- (0.1,0.01)
};
\end{codeexample}
These error coordinates are only used in case of error bars, see section~\ref{sec:errorbars}. You will also need to configure whether these values denote absolute or relative errors.

The coordinates as such can be numbers as |+5|, |-1.2345e3|, |35.0e2|, |0.00000123| or |1e2345e-8|. They are not limited to \TeX's precision.

Furthermore, |coordinates| allows to define ``meta data'' for each coordinate. The interpretation of meta data depends on the visualization technique: for scatter plots, meta data can be used to define colors or style associations for every point (see page~\pageref{pgfplots:scatterclasses} for an example). Meta data (if any) must be provided after the coordinates and after error bar bounds (if any) in square brackets:
\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}
\addplot+[scatter,scatter src=explicit] coordinates {
	 (900,1e-6) [1]
    (2600,5e-7) [2]
    (4000,7e-8) [3]
};
\end{axis}
\end{tikzpicture}
\end{codeexample}
Please refer to the documentation of |scatter src| on page~\pageref{pgfplots:scatter:src} for more information about per point meta data.
\end{addplotoperation}

\subsubsection{Reading Coordinates From Files}

\begin{addplotoperation}[]{file}{\marg{name}}
\label{pgfplots:addplot:file}
\PGFPlots\ supports two ways to read plot coordinates of external files, and one of them is the \Tikz-command `|plot file|'. It is to be used like
\begin{codeexample}[code only]
\addplot file {datafile.dat};
\end{codeexample}
where \marg{name} is a text file with at least two columns which will be used as $x$ and $y$ coordinates. Lines starting with `|%|' or `|#|' are ignored. Such files are often generated by \textsc{gnuplot}:
\begin{codeexample}[code only]
#Curve 0, 20 points
#x y type
0.00000 0.00000 i
0.52632 0.50235 i
1.05263 0.86873 i
1.57895 0.99997 i
...
9.47368 -0.04889 i
10.00000 -0.54402 i
\end{codeexample}
This listing has been copied from~\cite[section~16.4]{tikz}.

Plot file accepts one optional argument,

\begin{codeexample}[code only]
\addplot file[skip first] {datafile.dat};
\end{codeexample}

\noindent
which allows to skip over a non-comment header line. This allows to read the same input files as |plot table| by skipping over column names. Please note that comment lines do not count as lines here.

The input method |plot file| can also read meta data for every coordinate. As already explained for |plot coordinates| (see above), meta data can be used to change colors or other style parameters for every marker separately. Now, if |scatter src| is set to |explicit| or to |explicit symbolic| and the input method is |plot file|, one further element will be read from disk - for every line. Meta data is always the last element which is read. See page~\pageref{pgfplots:scatter:src} for information and examples about per point meta data and page~\pageref{pgfplots:scatterclasses} for an application example using |scatter/classes|.


Plot file is very similar to |plot table|: you can achieve the same effect with
\begin{codeexample}[code only]
\addplot table[x index=0,y index=1,header=false] {datafile.dat};
\end{codeexample}
\noindent Due to its simplicity, |plot file| is slightly faster while |plot table| allows higher flexibility.

Technical note: every opened file will be protocolled into your log file.
\end{addplotoperation}

\begin{pgfplotskeylist}{%
	plot file/skip first=\mchoice{true,false} (initially false),%
	plot file/ignore first=\mchoice{true,false} (initially false)}
	The two keys can be provided as arguments to |\addplot file[|\meta{options}|] |\marg{filename}|;| to skip the first non-comment entry in the file. They are equivalent.
	If you provide them in this context, the prefix |/pgfplots/plot file| can be omitted.
\end{pgfplotskeylist}

\subsubsection{Reading Coordinates From Tables}

\begin{addplotoperation}[]{table}{\oarg{column selection}\marg{file}}
\label{pgfplots:addplot:table}
The use of `|plot table|' is similar in spirit to `|plot file|', but its flexibility is higher. Given a data file like
\begin{codeexample}[code only]
dof     L2              Lmax            maxlevel
5       8.31160034e-02  1.80007647e-01  2
17      2.54685628e-02  3.75580565e-02  3
49      7.40715288e-03  1.49212716e-02  4
129     2.10192154e-03  4.23330523e-03  5
321     5.87352989e-04  1.30668515e-03  6
769     1.62269942e-04  3.88658098e-04  7
1793    4.44248889e-05  1.12651668e-04  8
4097    1.20714122e-05  3.20339285e-05  9
9217    3.26101452e-06  8.97617707e-06  10
\end{codeexample}
one may want to plot `|dof|' versus `|L2|' or `|dof|' versus `|Lmax|'. This can be done by
\begin{codeexample}[code only]
\begin{tikzpicture}
\begin{loglogaxis}[
	xlabel=Dof,
	ylabel=$L_2$ error]
\addplot table[x=dof,y=L2] {datafile.dat};
\end{loglogaxis}
\end{tikzpicture}
\end{codeexample}
or
\begin{codeexample}[code only]
\begin{tikzpicture}
\begin{loglogaxis}[
	xlabel=Dof,
	ylabel=$L_infty$ error]
\addplot table[x=dof,y=Lmax] {datafile.dat};
\end{loglogaxis}
\end{tikzpicture}
\end{codeexample}
Alternatively, you can load the table \emph{once} and use it \emph{multiple} times:
\begin{codeexample}[code only]
\pgfplotstableread{datafile.dat}\table
...
\addplot table[x=dof,y=L2] from \table;
...
\addplot table[x=dof,y=Lmax] from \table;
...
\end{codeexample}
I am not really sure how much time can be saved, but it works anyway. As a rule of thumb, decide as follows:
\begin{enumerate}
	\item If tables contain few rows and many columns, the |from |\meta{\textbackslash macro} framework will be more efficient.
	\item If tables contain more than~$200$ data points (rows), you should always use file input (and reload if necessary).
\end{enumerate}

If you do prefer to access columns by column indices instead of column names (or your tables do not have column names), you can also use
\begin{codeexample}[code only]
\addplot table[x index=2,y index=3] {datafile.dat};
\addplot table[x=dof,y index=2] {datafile.dat};
\end{codeexample}

Summary and remarks:
\begin{itemize}
	\item Use |plot table[|\declaretext{x}|=|\marg{column name}|,|\declaretext{y}|=|\marg{column name}|]| to access column names. Those names are case sensitive and need to exist.
	\item Use |plot table[|\declaretext{x index}|=|\marg{column index}|,|\declaretext{y index}|=|\marg{column index}|]| to access column indices. Indexing starts with~$0$. You may also use an index for~$x$ and a column name for~$y$.
	\item Use |plot table[|\declaretext{header}|=false] |\marg{file name} if your input file has no column names. Otherwise, the first non-comment line is checked for column names: if all entries are numbers, they are treated as numerical data; if one of them is not a number, all are treated as column names.
	\item It is possible to read error coordinates from tables as well. Simply add options `\declaretext{x error}', `\declaretext{y error}' or `\declaretext{x error index}'/`\declaretext{y error index}' to \marg{source columns}. See section~\ref{sec:errorbars} for details about error bars.
	\item It is possible to read per point meta data (usable in |scatter src|, see page~\pageref{pgfplots:scatter:src}) as has been discussed for |plot coordinates| and |plot file| above. The meta data column can be provided using the \declaretext{meta} key (or the \declaretext{meta index} key).
	\item Use |plot table[|\meta{source columns}|] from |\marg{\textbackslash macro} to use a pre--read table. Tables can be read using
\begin{codeexample}[code only]
\pgfplotstableread{datafile.dat}\macroname.
\end{codeexample}
		The keyword `|from|' can be omitted.

	\item The accepted input format of those tables is as follows:
		\begin{itemize}
			\item Columns are usually separated by white spaces (at least one tab or space).

			 If you need other column separation characters, you can use the 

			\declare{col sep}|=|\mchoice{space,comma,colon,semicolon,braces} 

			option which is documented in all detail in the manual for \PGFPlotstable\ which is part of \PGFPlots.
			\item Any line starting with `\#' or `\%' is ignored.
			\item The first line will be checked if it contains numerical data. If there is a column in the first line which is \emph{no} number, the complete line is considered to be a header which contains column names. Otherwise it belongs to the numerical data and you need to access column indices instead of names.

			\item There is future support for a second header line which must start with `|$flags |'. Currently, such a line is ignored. It may be used to provide number formatting hints like precision and number format if those tables shall be typeset using |\pgfplotstabletypeset| (see the manual for \PGFPlotstable).
			\item The accepted number format is the same as for `|plot coordinates|', see above.
			\item If you omit column selectors, the default is to plot the first column against the second. That means |plot table| does exactly the same job as |plot file| for this case.
			\item If you need unbalanced columns, simply use |nan| as ``empty cell'' placeholder. These coordinates will be skipped in plots.
			\index{Unbalanced Columns}%
			\index{table@\textcolor {gray}{\texttt {plot}}\texttt { table}!Unbalanced Columns}%
		\end{itemize}
	\item It \emph{is} possible to create new columns out of existing ones, see the \PGFPlotstable\ manual section ``Postprocessing Data in New Columns''.

	In this context, you should consider using the key \declaretext{read completely}, see below.
	\item It is also possible to use \textbf{mathematical expressions} together with `|plot table|'. This is documented in all detail in section~\ref{pgfplots:addplot:table:expr}, but the key idea is to use one of \declaretext{x expr}, \declaretext{y expr}, \declaretext{z expr} or \declaretext{meta expr} as in `|plot table[|\declaretext{x expr}|=\thisrow{maxlevel}+3,|\declaretext{y}|=L2]|'.
	\item Technical note: every opened file will be protocolled into your log file.
\end{itemize}
\end{addplotoperation}

\begin{pgfplotskey}{table/header=\mchoice{true,false} (initially true)}
	Allows to disable header identification for |plot table|. See above.
\end{pgfplotskey}
\begin{pgfplotsxykeylist}{table/\x=\marg{column name},
	table/\x\ index=\marg{column index}}
	These keys define the sources for |plot table|. If both, column names and column indices are given, column names are preferred. Column indexing starts with~$0$. The initial setting is to use |x index=0| and |y index=1|. 

	Please note that column \emph{aliases} will be considered if unknown column names are used. Please refer to the manual of \PGFPlotstable\ which comes with this package.
\end{pgfplotsxykeylist}

\begin{pgfplotsxykeylist}{\x\ expr=\marg{expression},meta expr=\marg{expression}}
	These keys allow to combine the mathematical expression parser with file input. They are listed here to complete the list of table keys, but they are described in all detail in section~\ref{pgfplots:addplot:table:expr}.

	The key idea is to provide an \meta{expression} which depends on table data (possibly on all columns in one row). Only data within the same row can be used where columns are referenced with \declaretext{\textbackslash thisrow}\marg{column name} or \declaretext{\textbackslash thisrowno}\marg{column index}. 
	
	Please refer to section~\ref{pgfplots:addplot:table:expr} for details.
\end{pgfplotsxykeylist}


\begin{pgfplotsxykeylist}{%
	table/\x\ error=\marg{column name},
	table/\x\ error index=\marg{column index}}
	These keys define input sources for error bars with explicit error values. Please see section~\ref{sec:errorbars} for details.
\end{pgfplotsxykeylist}
\begin{pgfplotsxykeylist}{%
	table/meta=\marg{column name},
	table/meta index=\marg{column index}}
	These keys define input sources for per point meta data. Please see page~\pageref{pgfplots:scatter:src} for details about meta data or the documentation for |plot coordinates| and |plot file| for further information.
\end{pgfplotsxykeylist}
\begin{key}{/pgfplots/table/col sep=\mchoice{space,comma,semicolon,colon,braces} (initially space)}
	Allows to choose column separators for |plot table|. Please refer to the manual of \PGFPlotstable\ which comes with this package for details about |col sep|.
\end{key}
\begin{key}{/pgfplots/table/read completely=\marg{true,false} (initially false)}
	Allows to customize |\addplot table|\marg{file name} such that it always reads the entire table into memory.

	This key has just one purpose, namely to create postprocessing columns on-the-fly and to plot those columns afterwards. This ``lazy evaluation'' which creates missing columns on-the-fly is documented in the \PGFPlotstable\ manual (in section ``Postprocessing Data in New Columns'').

	\paragraph{Attention:} Usually, |\addplot table| only picks required entries, requiring linear runtime complexity. As soon as |read completely| is activated, tables are loaded completely into memory. Due to datastructures issues (``macro append runtime''), the runtime complexity for |read completely| is $O(N^2)$ where $N$ is the number of rows. Thus: use this feature only for ``small'' tables.
\end{key}

\subsubsection{Computing Coordinates with Mathematical Expressions}

\begin{addplotoperation}[]{expression \marg{math expr}}{}
	This input method allows to provide mathematical expressions which will be sampled. But unlike |plot gnuplot|, the expressions are evaluated using the math parser of \PGF, no external program is required.

	Plot expression samples |x| from the interval $[a,b]$ where $a$ and $b$ are specified with the |domain| key. The number of samples can be configured with |samples=|\meta{N} as for plot gnuplot.

\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}
	\addplot expression {x^2 + 4};
	\addplot expression {-5*x^3 - x^2};
\end{axis}
\end{tikzpicture}
\end{codeexample}

Please note that \PGF's math parser uses degrees for trigonometric functions:
\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}
	\addplot expression[domain=0:360]
		{sin(x)};
\end{axis}
\end{tikzpicture}
\end{codeexample}
\noindent If you want to use radians, use 
\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}
	\addplot expression[domain=-pi:pi] 
		{sin(deg(x))};
\end{axis}
\end{tikzpicture}
\end{codeexample}
\noindent to convert the radians to degrees. The plot expression parser also accepts some more options like |samples at=|\marg{coordinate list} or |domain=|\meta{first}|:|\meta{last} which are described below.

\paragraph{Remarks}
\begin{enumerate} 
	\item What really goes on is a loop which assigns the current sample coordinate to the macro |\x|. \PGFPlots\ defines a math constant |x| which always has the same value as |\x|.

	In short: it is the same whether you write |\x| or just |x| inside of math expressions.

	The variable name can be customized using |variable=\t| (the backslash is necessary!). Then, |t| will be the same as |\t|.
\index{x@\texttt{\textbackslash x} In Coordinate Expressions}%
%\index{y@\texttt{\textbackslash y} In Coordinate Expressions}%

	\item The complete set of math expressions can be found in the \PGF\ manual. The most important mathematical operations are
	|+|, |-|, |*|, |/|, |abs|, |round|, |floor|, |mod|, |<|, |>|, |max|, |min|, |sin|, |cos|, |tan|, |deg| (conversion from radians to degrees), |rad| (conversion from degrees to radians), |atan|, |asin|, |acos|, |cot|, |sec|, |cosec|, |exp|, |ln|, |sqrt|, the constanst |pi| and |e|, |^| (power operation), |factorial|\footnote{Starting with \PGF\ versions newer than $2.00$, you can use the postfix operator \texttt{!} instead of \texttt{factorial}.}, |rand| (random between $-1$ and $1$), |rnd| (random between $0$ and $1$), number format conversions |hex|, |Hex|, |oct|, |bin| and some more. The math parser has been written by Mark Wibrow and Till Tantau~\cite{tikz}, the FPU routines have been developed as part of \PGFPlots. The documentation for both parts can be found in~\cite{tikz}.
	
	Please note, however, that trigonometric functions are defined in degrees. The character `|^|' is used for exponentiation (not `|**|' as in gnuplot).

	\item If the $x$ axis is logarithmic, samples will be drawn logarithmically.

	\item Please note that plot expression does not allow per point meta data (color data).
\end{enumerate}

\paragraph{About the precision and number range:}
\index{Accuracy!High Precision for Plot Expression}%
\index{Errors!dimension too large}%
	\index{Precision}\index{Floating Point Unit} Starting with version 1.2, |plot expression| uses a floating point unit. The FPU provides the full data range of scientific computing with a relative precision between $10^{-4}$ and $10^{-6}$. The |/pgf/fpu| key provides some more details. 

	In case the |fpu| does not provide the desired mathematical function or is too slow\footnote{Or in case you find a bug$\dotsc$}, you should consider using the |plot gnuplot| method which invokes the external, freely available program |gnuplot| as desktop calculator. 

\begin{codeexample}[]
\begin{tikzpicture}
	\begin{loglogaxis}[
		title={$\frac{1}{x^2}$}]
	\addplot[blue]
		expression[domain=1:1e30] 
		{x^-2};
	\end{loglogaxis}
\end{tikzpicture}
\end{codeexample}

\begin{codeexample}[]
\begin{tikzpicture}
	\begin{semilogyaxis}[
		title={$e^x$ logarithmically plotted}]
	\addplot[blue]
		expression[domain=1:700] 
		{exp(x)};
	\end{semilogyaxis}
\end{tikzpicture}
\end{codeexample}
\end{addplotoperation}

\begin{addplotoperation}[]{\marg{math expression}}{}
	Use

	|\addplot |\marg{math expression}|;|

	as short-hand equivalent for

	|\addplot expression |\marg{math expression}|;|
\end{addplotoperation}

\begin{addplotoperation}[]{(\meta{$x$ expression},\meta{$y$ expression})}{}
	A variant of |\addplot expression| which allows to provide different coordinate expressions for the $x$ and $y$ coordinates. This can be used to generate parameterized plots.

	Please note that |\addplot (x,x^2)| is equivalent to |\addplot expression {x^2}|.

	Note further that since the complete point expression is surrounded by round braces, you can't use round braces for either \meta{$x$ expression} or \meta{$y$ expression}. You will need to introduce curly braces additionally to round braces.
\end{addplotoperation}

\begin{pgfplotskeylist}{%
	domain=\meta{$x_1$}:\meta{$x_2$} (initially [-5:5]),%
	y domain=\meta{$y_1$}:\meta{$y_2$}}
	Sets the function's domain(s) for |plot expression| and |plot gnuplot|. Two dimensional plot expressions are defined as functions $f\colon [x_1,x_2] \to \R$ and \meta{$x_1$} and \meta{$x_2$} are set with |domain|. Three dimensional plot expressions use functions $f\colon [x_1,x_2] \times [y_1,y_2] \to \R$ and \meta{$y_1$} and \meta{$y_2$} are set with |y domain|. If |y domain| is empty, $[y_1,y_2] = [x_1,x_2]$ is assumed for three dimensional plots (see page~\pageref{cmd:addplot3:expr} for details about three dimensional plot expressions).


	 The |domain| key won't be used if |samples at| is specified; |samples at| has higher precedence.


	 Please note that |domain| is not necessarily the same as the axis limits (which are configured with the |xmin|/|xmax| options). 

	 \paragraph{Remark for \Tikz-users:} |/pgfplots/domain| and |/tikz/domain| are independent options. Please prefer the \PGFPlots\ variant (i.e.\ provide |domain| to an axis, |\pgfplotsset| or a plot command). Since older versions also accepted something like |\begin{tikzpicture}[domain=|$\dotsc$|]|, this syntax is also accepted as long as no \PGFPlots\ |domain| key is set.
\end{pgfplotskeylist}

\begin{pgfplotskeylist}{%
	samples=\marg{number} (initially 25),%
	samples y=\marg{number}}
	 Sets the number of sample points for |plot expression| and |plot gnuplot|. The |samples| key defines the number of samples used for line plots while the |samples y| key is used for mesh plots (three dimensional visualisation, see page~\pageref{cmd:addplot3:expr} for details). If |samples y| is not set explicitly, it uses the value of |samples|.

	 The |samples| key won't be used if |samples at| is specified; |samples at| has higher precedence.

	The same special treatment of |/tikz/samples| and |/pgfplots/samples| as for the |domain| key applies here. See above for details.
\end{pgfplotskeylist}

\begin{pgfplotskey}{samples at=\marg{coordinate list}}
	Sets the $x$ coordinates for |plot expression| explicitly. This overrides |domain| and |samples|.

	The \marg{coordinate list} is a |\foreach| expression, that means it can contain a simple list of coordinates (comma--separated) but also complex |...| expressions like\footnote{Unfortunately, the |...| is somewhat restrictive when it comes to extended accuracy. So, if you have particularly small or large numbers (or a small distance), you have to provide a comma--separated list (or use the \texttt{domain} key).}
\begin{codeexample}[code only]
\pgfplotsset{samples at={5e-5,7e-5,10e-5,12e-5}}
\pgfplotsset{samples at={-5,-4.5,...,5}}
\pgfplotsset{samples at={-5,-3,-1,-0.5,0,...,5}}
\end{codeexample}

	The same special treatment of |/tikz/samples at| and |/pgfplots/samples at| as for the |domain| key applies here. See above for details.

	\paragraph{Attention:} |samples at| overrides |domain|, even if |domain| has been set \emph{after} |samples at|! Use |samples at={}| to clear \marg{coordinate list} and re-activate |domain|.
\end{pgfplotskey}

\subsubsection{Mathematical Expressions And File Data}
\PGFPlots\ allows to combine `|plot table|' and `|plot expression|' to get both, file input and modifications by means of mathematical expressions.

\begin{addplotoperation}[]{table}{\oarg{column selection and expressions}\marg{file}}
\label{pgfplots:addplot:table:expr}
	Besides the already discussed possibility to provide a column selection by means of column names (\declaretext{x}|=|\meta{name} or \declaretext{x index}|=|\meta{index}, see section~\ref{pgfplots:addplot:table}), it is also possible to provide mathematical expressions as arguments.

	Mathematical expressions are specified with \declaretext{x expr}|=|\meta{expression} inside of \meta{column selection and expressions}. They can depend on zero, one or more columns of the input file. A column is referenced using the special command `\declaretext{\textbackslash thisrow}\marg{column name}' within \meta{expression}.
\begin{codeexample}[vbox]
\pgfplotstabletypeset[columns={maxlevel,L2}]{plotdata/newexperiment1.dat}

\begin{tikzpicture}
	\begin{semilogyaxis}[
		xlabel=\texttt{maxlevel}$ + 10$
	]
	\addplot table
		[x expr=\thisrow{maxlevel}+10, y=L2] 
		{plotdata/newexperiment1.dat};
	\end{semilogyaxis}
\end{tikzpicture}
\end{codeexample}

	Besides \declaretext{x expr}, there are keys \declaretext{y expr}, \declaretext{z expr} and \declaretext{meta expr} where the latter allows to provide point meta data (which is used as |scatter src| or color data for surface plots etc.).

	Inside of \meta{expression}, the following macros can be used to access numerical data cells inside of the input file:

	\begin{command}{\thisrow\marg{column name}}
		Yields the value of the column designated by \marg{column name}. There is no limit on the number of columns which can be part of a mathematical expression, but only values inside of the currently processed \emph{table row} can be used.
		
		It is possible to provide column aliases for \marg{column name} as described in the manual of \PGFPlotstable. 

		If \marg{column name} does not exist, the math parser yields an ``Unknown function'' error message.
	\end{command}
	\begin{command}{\thisrowno\marg{column index}}
		Similar to |\thisrow|, this command yields the value of the column with index \marg{column index} (starting with $0$). 
	\end{command}
	\begin{command}{\coordindex}
		Yields the current index of the table row (starting with $0$). This does \emph{not} count header or comment lines.		
	\end{command}
	\begin{command}{\lineno}
		Yields the current line number (starting with $0$). This does also count header and comment lines.
	\end{command}

	If |x index|, |x| and |x expr| (or the corresponding keys for |y|, |z| or |meta|) are combined, this is how they interact:
	\begin{enumerate}
		\item Column access via |x| has higher precedence than index access via |x index|.
		\item Even if |x expr| is provided, the values of |x index| and |x| are still checked. Any value found using column name access or column index access is made available as \declaretext{\textbackslash x} (or \declaretext{\textbackslash y}, \declaretext{\textbackslash z}, \declaretext{\textbackslash meta}, resp.). However, the result of |x expr| is used as plot coordinate.

		This allows to access the cell values identified by |x| or |x index| using the ``pointer'' |\x|. I am not sure if this yields any advantage, but it is possible nevertheless.
	\end{enumerate}

	\paragraph{Attention:} If your table has less rows than two, you may need to set |x index={},y index={}| explicitly. This is a consequence of the fact that column name/index access is still applied even if an expression is provided.
\end{addplotoperation}

\subsubsection{Computing Coordinates with Mathematical Expressions (gnuplot)}

\begin{addplotoperation}[]{gnuplot}{\oarg{further options}\marg{gnuplot code}}
In contrast to |plot expression|, the |plot gnuplot| command employs the external program |gnuplot| to compute coordinates. The resulting coordinates are written to a text file which will be plotted with |plot file|. \PGF\ checks whether coordinates need to be re-generated and calls |gnuplot| whenever necessary (this is usually the case if you change the number of samples, the argument to |plot gnuplot| or the plotted domain\footnote{Please note that \PGFPlots\ produces slightly different files than \Tikz\ when used with |plot gnuplot| (it configures high precision output). You should use different ids to avoid conflicts in such a case.}).

The differences between |plot expression| and |plot gnuplot| are:
\begin{itemize}
	\item |plot expression| does not require any external programs and requires no additional command line options.
	\item |plot expression| does not produce a lot of temporary files.
	\item |plot gnuplot| uses radians for trigonometric functions while |plot expression| has degrees.
	\item |plot gnuplot| is faster.
	\item |plot gnuplot| has a larger mathematical library.
	\item |plot gnuplot| has a higher accuracy. However, starting with version 1.2, this is no longer a great problem. The new floating point unit for \TeX\ provides reasonable accuracy and the same data range as |gnuplot|.
\end{itemize}

Since system calls are a potential danger, they need to be enabled explicitly using command line options, for example
\begin{codeexample}[code only]
pdflatex -shell-escape filename.tex.
\end{codeexample}
Sometimes it is called |shell-escape| or |enable-write18|. Sometimes one needs two slashes -- that all depends on your \TeX\ distribution.
\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}
\addplot 
	gnuplot[id=sin]{sin(x)};
\end{axis}
\end{tikzpicture}
\end{codeexample}

\begin{codeexample}[]
\begin{tikzpicture}
\begin{semilogyaxis}
\addplot gnuplot
	[id=exp,domain=0:10]{exp(x)};
\end{semilogyaxis}
\end{tikzpicture}
\end{codeexample}

The \meta{options} determine the appearance of the plotted function; these parameters also affect the legend. There is also a set of options which are specific to the gnuplot interface. These options are described in all detail in \cite[section~18.6]{tikz}. A short summary is shown below.

Please note that |plot gnuplot| does not allow per point meta data (color data for each coordinate).

Please refer to \cite[section~18.6]{tikz} for more details about |plot function| and the |gnuplot| interaction.

\begin{pgfplotskey}{translate gnuplot=\mchoice{true,false} (initially true)}
	Enables or disables automatic translation of the exponentiation operator `|^|' to `|**|'. 

	This features allows to use |^| in |plot gnuplot| instead of gnuplot's |**|.
\end{pgfplotskey}
\end{addplotoperation}

\begin{addplotoperation}[]{function}{\marg{gnuplot code}}
	Use

	|\addplot function |\marg{gnuplot code}|;|

	as alias for

	|\addplot gnuplot |\marg{gnuplot code}|;|
\end{addplotoperation}

\begin{key}{/tikz/id=\marg{unique string identifier}}
	 A unique identifier for the current plot. It is used to generate temporary filenames for |gnuplot| output.
\end{key}

\begin{key}{/tikz/prefix=\marg{file name prefix}}
	 A common path prefix for temporary filenames (see \cite[section~18.6]{tikz} for details).
\end{key}

\begin{key}{/tikz/raw gnuplot}
	 Disables the use of |samples| and |domain|.
\end{key}

\subsubsection{Computing Coordinates with External Programs (shell)}

\begin{addplotoperation}[]{shell}{\oarg{further options}\marg{shell commands}}
In contrast to |plot gnuplot|, the |plot shell| command allows execution of arbitrary shell commands to compute coordinates. The resulting coordinates are written to a text file which will be plotted with |plot file|. \PGF\ checks whether coordinates need to be re-generated and executes the \meta{shell commands} whenever necessary.

Since system calls are a potential danger, they need to be enabled explicitly using command line options, for example
\begin{codeexample}[code only]
pdflatex -shell-escape filename.tex.
\end{codeexample}
Sometimes it is called |shell-escape| or |enable-write18|. Sometimes one needs two slashes -- that all depends on your \TeX\ distribution.
\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}
\addplot
	shell[prefix=pgfshell_,id=cos]{awk 'BEGIN{
		pi=3.14159; N=10;
		for(i=0;i<=N;i++) print i,cos(i/N*pi);}'};
\end{axis}
\end{tikzpicture}
\end{codeexample}

\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}
\addplot+[prefix=pgfshell_,id=replot]
	shell{cat pgfshell_cos.out};
	% just reprint the result from above
\end{axis}
\end{tikzpicture}
\end{codeexample}

The \meta{options} determine the appearance of the plotted function; these parameters also affect the legend. There is also a set of options which are specific to the gnuplot and the shell interface. These options are described in all detail in \cite[section~19.6]{tikz}. A short summary is shown below.
\end{addplotoperation}

\begin{key}{/tikz/id=\marg{unique string identifier}}
	 A unique identifier for the current plot. It is used to generate temporary filenames for |shell| output.
\end{key}

\begin{key}{/tikz/prefix=\marg{file name prefix}}
	 A common path prefix for temporary filenames (see \cite[section~19.6]{tikz} for details).
\end{key}

\subsubsection{Using External Graphics as Plot Sources}

\begin{addplotoperation}[]{graphics}{\marg{file name}}
	This plot type allows to extend the plotting capabilities of \PGFPlots\ beyond its own limitations. The idea is to generate the graphics as such (for example, a contour plot, a complicated shaded surface\footnote{See also section~\ref{sec:pgfplots:surfplots} for an overview of \PGFPlots\ methods to draw shaded surfaces.} or a large point cluster) with an external program like Matlab (tm) or |gnuplot|. The graphics, however, should \emph{not} contain an axis or descriptions. Then, we use |\includegraphics| and an \PGFPlots\ axis which fits exactly on top of the imported graphics.

	Of course, one could do this manually by providing proper scales and such. The operation |plot graphics| is intended so simplify this process. However the \emph{main difficulty} is to get images with correct bounding box. Typically, you will have to adjust bounding boxes manually.

	Let's start with an example: Suppose we use, for example, matlab to generate a surface plot like
\begin{codeexample}[code only]
[X,Y] = meshgrid( linspace(-3,3,500) );
surf( X,Y, exp(-(X - Y).^2 - X.^2 ) );
shading flat; view(0,90); axis off; 
print -dpng external1
\end{codeexample}
	\noindent which is then found in |external1.png|. The |surf| command of Matlab generates the surface, the following commands disable the axis descriptions, initialise the desired view and export it. Viewing the image in any image tool, we see a lot of white space around the surface -- Matlab has a particular weakness in producing tight bounding boxes, as far as I know. Well, no problem: use your favorite image editor and crop the image (most image editors can do this automatically). We could use the free ImageMagick command
	
	|convert -trim external1.png external1.png|

	to get a tight bounding box. Then, we use

\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}[enlargelimits=false,axis on top]
		\addplot graphics
			[xmin=-3,xmax=3,ymin=-3,ymax=3] 
			{external1};
	\end{axis}
\end{tikzpicture}
\end{codeexample}
\noindent to load the graphics\footnote{Please note that I don't have a Matlab license, so I used \texttt{gnuplot} to produce an equivalent replacement graphics.} just as if we would have drawn it with \PGFPlots. The |axis on top| simply tells \PGFPlots\ to draw the axis on top of any plots (see its description).

Please note that \PGFPlots\ offers support for smaller surface plots as well which might be an option -- unless the number of samples is too large. The example above could be realized (with considerably fewer samples!) with \PGFPlots\ using the listing below.
\pgfplotsexpensiveexample
\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[view={0}{90},axis on top]
	\addplot3[surf,shader=interp,
		samples=50,domain=-3:3]
	{exp(-(x - y)^2 - x^2 )};
% FIXME : must be '0-' instead of '-' for pgf 2.00!
\end{axis}
\end{tikzpicture}
\end{codeexample}
\noindent However, external programs have the following advantages here: they are faster, allow more complexity and provide real z buffering which is currently only simulated by \PGFPlots. Thus, it may help to consider |plot graphics| for complicated surface plots.

Our first test was successful -- and not difficult at all because graphics programs can automatically compute the bounding box. There are a couple of free tools available which can compute tight bounding boxes for |.eps| or |.pdf| graphics:
\begin{enumerate}
	\item The free vector graphics program |inkscape| can help here. Its feature ``File $\gg$ Document Properties: Fit page to selection'' computes a tight bounding box around every picture element. 

	However, some images may contain a rectanglar path which is as large as the bounding box (Matlab (tm) computes such |.eps| images). In this case, use the ``Ungroup'' method (context menu of |inkscape|) as often as necessary and remove such a path.

	Finally, save as |.eps|.

	However, |inkscape| appears to have problems with postscript fonts -- it substitutes them. This doesn't pose problems in this application because fonts shouldn't be part of such images -- the descriptions will be drawn by \PGFPlots.

	\item The tool |pdfcrop| removes surrounding whitespace in |.pdf| images and produces quite good bounding boxes.
\end{enumerate}

\paragraph{Adjusting bounding boxes manually}
In case you don't have tools at hand to provide correct bounding boxes, you can still use \TeX\ to set the bounding box manually. Some viewers like |gv| provide access to low--level image coordinates. The idea is to determine the number of units which need to be removed and communicate these units to |\includegraphics|.

I am aware of the following methods to determine bounding boxes manually:
\begin{description}
	\item[inkscape] I am pretty sure that |inkscape| can do it.
	\item[gv] The ghost script viewer |gv| always shows the postscript units under the mouse cursor.
	\item[gimp] The graphics program |gimp| usually shows the cursor position in pixels, but it can be configured to display postscript points  (|pt|) instead.
\end{description}

Let's follow this approach in a further example. 

	We use |gnuplot| to draw a (relatively stupid) example data set. The gnuplot script
\begin{codeexample}[code only]
set samples 30000
set parametric
unset border
unset xtics
unset ytics
set output "external2.eps"
set terminal postscript eps color
plot [t=0:1] rand(0),rand(0) with dots notitle lw 5
\end{codeexample}
\noindent generates |external2.eps| with a uniform random sample of size $30000$. As before, we import this scatter plot into \PGFPlots\ using |plot graphics|. Again, the bounding box is too large, so we need to adjust it (|gnuplot| can do this automatically, but we do it anyway to explain the mechanisms):

Using |gv|, I determined that the bounding box needs to be shifted |12| units to the left and |9| down. Furthermore, the right end is |12| units too far off and the top area has about |8| units space wasted. This can be provided to the |trim| option of |\includegraphics|, and we use |clip| to clip the rest away: 
\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}[axis on top,title=Graphics Import]
		\addplot graphics
			[xmin=0,xmax=1,ymin=0,ymax=1,
			% trim=left bottom right top
			includegraphics={trim=12 9 12 8,clip}]
			{external2};
		\addplot coordinates {(0,0) (1,1)};
	\end{axis}
\end{tikzpicture}
\end{codeexample}

	So, |plot graphics| takes a graphics file along with options which can be passed to |\includegraphics|. Furthermore, it provides the information how to embed the graphics into an axis. The axis can contain any other |\addplot| command as well and will be resized properly.


\paragraph{Details about \texttt{plot graphics}:}
	The loaded graphics file is drawn with
	
	|\node[/pgfplots/plot graphics/node] {\includegraphics[|\meta{options}|]|\marg{file name}|};|

	where the |node| style is a configurable style. The node is placed at the coordinate designated by |xmin|, |ymin|. 
	
	The \meta{options} are any arguments provided to the |includegraphics| key (see below) and |width| and |height| determined such that the graphics fits exactly into the rectangle denoted by the |xmin|, |ymin| and |xmax|, |ymax| coordinates.

	The scaling will thus ignore the aspect ratio of the external image and prefer the one used by \PGFPlots. You will need to provide |width| and |height| to the \PGFPlots\ axis to change its scaling. Use the |scale only axis| key in such a case.
\end{addplotoperation}
\begin{pgfplotsxykeylist}{
	plot graphics/\x min=\marg{coordinate},
	plot graphics/\x max=\marg{coordinate}}
	These keys are required for |plot graphics| and provide information about the external data range. The graphics will be squeezed between these coordinates. The arguments are axis coordinates.
\end{pgfplotsxykeylist}

\begin{pgfplotskey}{plot graphics/includegraphics=\marg{options}}
	A list of options which will be passed as--is to |\includegraphics|. Interesting options include the |trim=|\meta{left} \meta{bottom} \meta{right} \meta{top} key which reduces the bounding box and |clip| which discards everything outside of the bounding box. The scaling options won't have any effect, they will be overwritten by \PGFPlots.
\end{pgfplotskey}
\begin{stylekey}{/pgfplots/plot graphics/node}
	A predefined style used for the node containing the graphics. The predefined value is
\begin{codeexample}[code only]
\pgfplotsset{
	plot graphics/node/.style={
		transform shape,
		inner sep=0pt,
		outer sep=0pt,
		every node/.style={},
		anchor=south west,
		at={(0pt,0pt)},
		rectangle
	}
}
\end{codeexample}
\end{stylekey}

\begin{pgfplotskey}{plot graphics}
	This key belongs to the public low--level plotting interface. You won't need it in most cases.

	This key is similar to |sharp plot| or |smooth| or |const plot|: it installs a low--level plot--handler which expects exactly two points: the lower left corner and the upper right one. The graphics will be drawn between them. The graphics file name is expected as value of the |/pgfplots/plot graphics/src| key. The other keys described above need to be set correctly (excluding the limits, these are ignored at this level of abstraction). This key can be used independent of an axis.
\end{pgfplotskey}

\begin{pgfplotskey}{plot graphics/lowlevel draw=\marg{width}\marg{height}}
	A low--level interface for |plot graphics| which actually invokes |\includegraphics|. But there is no magic involved: the command is simply expected to draw a box of dimensions \meta{width} $\times$ \meta{height}. The coordinate system has already been shifted correctly.

	The initial configuration is

	|\includegraphics[|\meta{value of ``{\normalfont\texttt{plot graphics/includegraphics}}''}|,width=#1,height=#2]|

	\hspace{10pt}\marg{value of ``{\normalfont\texttt{plot graphics/src}}''}.

	Thus, you can tweak |plot graphics| to place any \TeX\ box of the desired dimensions into an axis between the provided minimum and maximum coordinates. It is not necessary to make use of the graphics file name or the options in the `|includegraphics|' key if you overwrite this lowlevel interface.
\end{pgfplotskey}
	

\subsection{About Options: Preliminaries}
\PGFPlots\ knowns a whole lot of key--value options which can be (re-)defined to active desired features, modify them or apply fine tuning.

Most keys can be used like
\begin{codeexample}[code only]
\begin{tikzpicture}
\begin{axis}[key=value,key2=value2]
...
\end{axis}
\end{tikzpicture}
\end{codeexample}
\noindent which changes them for the complete axis. Some keys can be changed for each plot:
\begin{codeexample}[code only]
\begin{tikzpicture}
\begin{axis}
\addplot[key=value,key2=value2] ... ;
\addplot+[key=value,key2=value2] ... ; % keeps the keys which would have been used by default
\end{axis}
\end{tikzpicture}
\end{codeexample}

The basic engine to manage key--value pairs is |pgfkeys| which is part of \pgfname. This engine always has a key name and a key ``path'', which is somehow similar to file name and directory of files. The common ``directory'' (key path) of \PGFPlots\ is `|/pgfplots/|'. Although the key definitions below provide this full path, it is always (well, almost always) enough to skipt this prefix -- \PGFPlots\ uses it automatically. The same holds for the prefixes `|/tikz/|' which are common for all \Tikz\ drawing options and `|/pgf/|' which are for the (more or less) low--level commands of \pgfname. All these prefixes can be omitted.

One important concept is the concept of styles. A style is a key which contains one or more other keys. It can be redefined or modified until it is actually used by the internal routines. Each single component of \Tikz\ and \PGFPlots\ can be configured with styles.

For example,
\begin{codeexample}[code only]
\pgfplotsset{every axis/.append style={line width=1pt}}
\end{codeexample}
\noindent
sets the line width for every axis to |1pt|. 

There are several other styles predefined to modify the appearance, see section~\ref{sec:styles}.

\begin{command}{\pgfplotsset\marg{key-value-list}}
	Defines or sets all options in \marg{key-value-list}.
	
	It is a shortcut for |\pgfqkeys{/pgfplots}|\marg{key-value-list}, that means it inserts the prefix |/pgfplots| to any option which has no full path.

	This command can be used to define default options for the complete document or a part of the document. For example, 
\begin{codeexample}[code only]
\pgfplotsset{
	cycle list={%
		{red, mark=*}, {blue,mark=*},
		{red, mark=x}, {blue,mark=x},
		{red, mark=square*}, {blue,mark=square*},
		{red, mark=triangle*}, {blue,mark=triangle*},
		{red, mark=diamond*}, {blue,mark=diamond*},
		{red, mark=pentagon*}, {blue,mark=pentagon*}
	},
	legend style={
		at={(0.5,-0.2)},
		anchor=north,
		legend columns=2,
		cells={anchor=west},
		font=\footnotesize,
		rounded corners=2pt,
	},
	xlabel=$x$,ylabel=$f(x)$
}
\end{codeexample}
	can be used to set document--wise styles for line specifications, the legend's style and axis labels.

	You can also define new styles (collections of key--value--pairs) with |.style| and |.append style|.
\begin{codeexample}[code only]
\pgfplotsset{
	My Style 1/.style={xlabel=$x$, legend entries={1,2,3} },
	My Style 2/.style={xlabel=$X$, legend entries={4,5,6} }
\end{codeexample}
	The |.style| and |.append style| key handlers are described in section~\ref{sec:styles} in more detail.
\end{command}


\subsubsection{Pgfplots Options and \Tikz\ Options}
This section is more or less technical and can be skipped unless one really wants to know more about this topic.

\Tikz\ options and \PGFPlots\ options can be mixed inside of the axis arguments and in any of the associated styles. For example,
\begin{codeexample}[code only]
\pgfplotsset{every axis legend/.append style={
	legend columns=3,font=\Large}}
\end{codeexample}
\noindent
assigns the `|legend columns|' option (a \PGFPlots\ option) and uses `|font|' for drawing the legend (a \Tikz\ option).

The axis environments will process any known \PGFPlots\ options, and all `|every|'--styles will be parsed for \PGFPlots\ options. Every unknown option is supposed to be a \Tikz\ option and will be forward to the associated \Tikz\ drawing commands. For example, the `\lstinline{font=\Large}' above will be used as argument to the legend matrix, and the `\lstinline{font=\Large}' argument in 
\begin{codeexample}[code only]
\pgfplotsset{every axis label/.append style={
	ylabel=Error,xlabel=Dof,font=\Large}}
\end{codeexample}
will be used in the nodes for axis labels (but not the axis title, for example).

It is an error if you assign incompatible options to axis labels, for example `|xmin|' and `|xmax|' can't be set inside of `|every axis label|'.

\subsection{Two Dimensional Plot Types}
\PGFPlots\ supports several two-dimensional line-plots like piecewise linear line plots, piecewise constant plots, smoothed plots, bar plots and comb plots. Most of them use the \PGF\ plot handler library directly, see \cite[section 18.8]{tikz}.

Plot types are part of the plot style, so they are set with options. Most of the basic 2d plot types are part of \Tikz, see \cite[section 18.8]{tikz}, and are probably known to users of \Tikz. They are documented here as well.


\subsubsection{Linear Plots}
\begin{plottype}{sharp plot}
Linear (`sharp') plots are the default. Point coordinates are simply connected by straight lines. 
\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}
	\addplot+[sharp plot] coordinates 
		{(0,0) (1,2) (2,3)};
\end{axis}
\end{tikzpicture}
\end{codeexample}

The `|+|' here means to use the normal plot cycle list and append `|sharp plot|' to its option list.
\end{plottype}

\subsubsection{Smooth Plots}
\begin{plottype}{smooth}
Smooth plots interpolate smoothly between successive points.
\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}
	\addplot+[smooth] coordinates 
		{(0,0) (1,2) (2,3)};
\end{axis}
\end{tikzpicture}
\end{codeexample}
\end{plottype}

\subsubsection{Constant Plots}
Constant plots draw lines parallel to the $x$-axis to connect coordinates. The discontinuos edges may be drawn or not, and marks may be placed on left or right ends.

\begin{plottype}{const plot}
Connects all points with horizontal and vertical lines. Marks are placed left-handed on horizontal line segments, causing the plot to be right-sided continuous at all data points.

\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}
\addplot+[const plot]
coordinates
{(0,0.1)    (0.1,0.15)  (0.2,0.5)   (0.3,0.62)
 (0.4,0.56) (0.5,0.58)  (0.6,0.65)  (0.7,0.6)
 (0.8,0.58) (0.9,0.55)  (1,0.52)};
\end{axis}
\end{tikzpicture}
\end{codeexample}


\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[ymin=0,ymax=1,enlargelimits=false]
\addplot
	[const plot,fill=blue,draw=black] 
coordinates
{(0,0.1)    (0.1,0.15)  (0.2,0.5)   (0.3,0.62)
 (0.4,0.56) (0.5,0.58)  (0.6,0.65)  (0.7,0.6)
 (0.8,0.58) (0.9,0.55)  (1,0.52)} 
	\closedcycle;
\end{axis}
\end{tikzpicture}
\end{codeexample}
\end{plottype}

\begin{plottype}{const plot mark left}
An alias for `|const plot|'.
\end{plottype}

\begin{plottype}{const plot mark right}
 A variant which places marks on the right of each line segment, causing plots to be left-sided continuous at coordinates.
\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}
\addplot+[const plot mark right]
coordinates
{(0,0.1)    (0.1,0.15)  (0.2,0.5)   (0.3,0.62)
 (0.4,0.56) (0.5,0.58)  (0.6,0.65)  (0.7,0.6)
 (0.8,0.58) (0.9,0.55)  (1,0.52)};
\end{axis}
\end{tikzpicture}
\end{codeexample}
\end{plottype}

\begin{plottype}{jump mark left}
A variant of `|const plot mark left|' which does not draw vertical lines.
\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[samples=8]
\addplot+[jump mark left] 
	expression[domain=-5:0] 
	{4*x^2 - 5};

\addplot+[jump mark right] 
	expression[domain=-5:0] 
	{0.7*x^3 + 50};
\end{axis}
\end{tikzpicture}
\end{codeexample}
\end{plottype}

\begin{plottype}{jump mark right}
A variant of `|const plot mark right|' which does not draw vertical lines.
\end{plottype}

\subsubsection{Bar Plots}
Bar plots place horizontal or vertical bars at coordinates. Multiple bar plots in one axis can be stacked on top of each other or aligned next to each other.

\begin{plottype}{xbar}
	Places horizontal bars between the $(y=0)$ line and each coordinate.

	This option is used on a per-plot basis and configures only the visualization of coordinates. The figure-wide style |/pgfplots/xbar| also sets reasonable options for ticks, legends and multiple plots.
\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}
\addplot+[xbar] coordinates 
	{(4,0) (1,1) (2,2) 
	 (5,3) (6,4) (1,5)};
\end{axis}
\end{tikzpicture}
\end{codeexample}
	Bars are centered at plot coordinates with width |bar width|. Using bar plots usually means more than just a different way of how to connect coordinates, for example to draw ticks outside of the axis, change the legend's appearance or introduce shifts if multiple |\addplot| commands appear.

	There is a preconfigured style for |xbar| which is installed automatically if you provide |xbar| as argument to the axis environment which provides this functionality.
% \usetikzlibrary{patterns}
\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[xbar,enlargelimits=0.15]
\addplot
[draw=blue,pattern=horizontal lines light blue] 
coordinates
	{(10,5) (15,10) (5,15) (24,20) (30,25)};

\addplot
[draw=black,pattern=horizontal lines dark blue] 
coordinates 
	{(3,5) (5,10) (15,15) (20,20) (35,25)};
\end{axis}
\end{tikzpicture}
\end{codeexample}
Here |xbar| yields |/pgfplots/xbar| because it is an argument to the axis, not to a single plot.

	Besides line-, fill- and colorstyles, bars can be configured with |bar width| and |bar shift|, see below.
\end{plottype}

\begin{stylekey}{/pgfplots/xbar=\marg{shift for multiple plots} (default 2pt)}
	This style sets |/tikz/xbar| \emph{and} some commonly used options concerning horizontal bars for the complete axis. This is automatically done if you provide |xbar| as argument to an axis argument, see above.

The |xbar| style defines shifts if multiple plots are placed into one axis. It draws bars adjacent to each other, separated by \marg{shift for multiple plots}. Furthermore, it sets the style |bar cycle list| and sets tick and legend appearance options.

The style is defined as follows.
\begin{codeexample}[code only]
/pgfplots/xbar/.style={
	bar cycle list,
	tick align=outside,
	/pgfplots/legend image code/.code=
		{\draw[##1,bar width=3pt,yshift=-0.2em,bar shift=0pt]
			plot coordinates {(0cm,0.8em) (2*\pgfplotbarwidth,0.6em)};},
	/pgf/bar shift={%
			% total width = n*w + (n-1)*skip
			% -> subtract half for centering
			-0.5*(\numplots*\pgfplotbarwidth + (\numplots-1)*#1)  + 
			% the '0.5*w' is for centering
			(.5+\plotnum)*\pgfplotbarwidth + \plotnum*#1},
	/tikz/xbar},
\end{codeexample}
The formular for |bar shift| assigns shifts dependend on the total number of plots and the current plot's number. It is designed to fill a total width of $n \cdot $|bar width|$ + (n-1) \cdot $\marg{shift for multiple plots}. The $0.5$ compensates for centering.
\end{stylekey}

\begin{plottype}{ybar}
	Like |xbar|, this option generates bar plots. It draws vertical bars between the ($x=0$) line and each input coordinate.
\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}
\addplot+[ybar] plot coordinates
	{(0,3) (1,2) (2,4) (3,1) (4,2)};
\end{axis}
\end{tikzpicture}
\end{codeexample}
	The example above simply changes how input coordinates shall be visualized. As mentioned for |xbar|, one usually needs modified legends and shifts for multiple bars in the same axis.

	There is a predefined style which installs these customizations when provided to the axis-environment:
\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[
	x tick label style={
		/pgf/number format/1000 sep=},
	ylabel=Population,
	enlargelimits=0.15,
	legend style={at={(0.5,-0.15)},
		anchor=north,legend columns=-1},
	ybar,
	bar width=7pt,
]
\addplot 
	coordinates {(1930,50e6) (1940,33e6)
		 (1950,40e6) (1960,50e6) (1970,70e6)};

\addplot 
	coordinates {(1930,38e6) (1940,42e6) 
		(1950,43e6) (1960,45e6) (1970,65e6)};

\addplot 
	coordinates {(1930,15e6) (1940,12e6) 
		(1950,13e6) (1960,25e6) (1970,35e6)};
\legend{Far,Near,Here}
\end{axis}
\end{tikzpicture}
\end{codeexample}
Here |ybar| yields |/pgfplots/ybar| because it is an argument to the axis, not to a single plot.

	As for |xbar|, the bar width and shift can be configured with |bar width| and |bar shift|.
\end{plottype}

\begin{stylekey}{/pgfplots/ybar=\marg{shift for multiple plots} (default 2pt)}
	As |/pgfplots/xbar|, this style sets the |/tikz/ybar| option to draw vertical bars, but it also provides commonly used options for vertical bars.

	If you supply |ybar| to an axis environment, |/pgfplots/ybar| will be chosen instead of |/tikz/ybar|.

	It changes the legend, draws ticks outside of the axis lines and draws multiple |\addplot| arguments adjacent to each other; block--centered at the $x$ coordinate and separated by \marg{shift for multiple plots}. Furthermore, it installs the style |bar cycle list|. It is defined similarly to |/pgfplots/xbar|.
\end{stylekey}

\begin{key}{/tikz/bar width=\marg{dimension} (initially 10pt)}
	Configures the width used by |xbar| and |ybar|. It is accepted to provide mathematical expressions.
\end{key}

\begin{key}{/tikz/bar shift=\marg{dimension} (initially 0pt)}
	Configures a shift for |xbar| and |ybar|. Use |bar shift| together with |bar width| to draw multiple bar plots into the same axis. It is accepted to provide mathematical expressions.
\end{key}


\begin{plottype}{ybar interval}
	This plot type produces vertical bars with width (and shift) relatively to intervals of coordinates.

	There is one conceptional difference when working with intervals: an interval is defined by \emph{two} coordinates. Since |ybar| has one value for each interval, the $i$th bar is defined by
	\begin{enumerate}
		\item the $y$ value of the $i$th coordinates,
		\item the $x$ value of the $i$th coordinate as left interval boundary,
		\item the $x$ value of the $(i+1)$th coordinate as right interval boundary.
	\end{enumerate}
	Consequently, there is \emph{one coordinate too much}: the last coordinate will \emph{only} be used to determine the interval width; its $y$ value doesn't influence the bar appearance.

	It is installed on a per-plot basis and configures \emph{only} the visualization of coordinates. See the style |/pgfplots/ybar interval| which configures the appearance of the complete figure.
\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}
\addplot+[ybar interval] plot coordinates
	{(0,2) (0.1,1) (0.3,0.5) (0.35,4) (0.5,3)
	 (0.6,2) (0.7,1.5) (1,1.5)};
\end{axis}
\end{tikzpicture}
\end{codeexample}

\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[ybar interval,
	xtick=data,
	xticklabel interval boundaries,
	x tick label style=
		{rotate=90,anchor=east}
	]
\addplot coordinates
	{(0,2) (0.1,1) (0.3,0.5) (0.35,4) (0.5,3)
	 (0.6,2) (0.7,1.5) (1,1.5)};
\end{axis}
\end{tikzpicture}
\end{codeexample}

\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[
	x tick label style={
		/pgf/number format/1000 sep=},
	ylabel=Population,
	enlargelimits=0.05,
	legend style={at={(0.5,-0.15)},
		anchor=north,legend columns=-1},
	ybar interval=0.7,
]
\addplot 
	coordinates {(1930,50e6) (1940,33e6)
		 (1950,40e6) (1960,50e6) (1970,70e6)};

\addplot 
	coordinates {(1930,38e6) (1940,42e6) 
		(1950,43e6) (1960,45e6) (1970,65e6)};

\addplot 
	coordinates {(1930,15e6) (1940,12e6) 
		(1950,13e6) (1960,25e6) (1970,35e6)};
\legend{Far,Near,Here}
\end{axis}
\end{tikzpicture}
\end{codeexample}
\end{plottype}

\begin{stylekey}{/pgfplots/ybar interval=\marg{relative width} (default 1)}
	A style which is intended to install options for |ybar interval| for a complete figure. This includes tick and legend appearance, management of multiple bar plots in one figure and a more adequate |cycle list| using the style |bar cycle list|.
\end{stylekey}

\begin{plottype}{xbar interval}
	As |ybar interval|, just for horizontal bars. 
\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[
	xmin=0,xmax=53,
	ylabel=Age,
	xlabel=Quantity,
	y label style={yshift=0.7cm},
	enlargelimits=false,
	ytick=data,
	yticklabel interval boundaries,
	xbar interval,
]
\addplot
	coordinates {(10,5) (10.5,10) (15,13) 
		(24,18) (50,21) (23,25) (10,30) 
		(3,50) (3,70)};
\end{axis}
\end{tikzpicture}
\end{codeexample}
\end{plottype}

\begin{stylekey}{/pgfplots/xbar interval=\marg{relative width} (default 1)}
	A style which is intended to install options for |xbar interval| for a complete figure, see the style |/pgfplots/ybar interval| for details.
\end{stylekey}

\begin{pgfplotsxykey}{\x ticklabel interval boundaries}
	These are style keys which set |x tick label as interval| (see page~\pageref{key:pgfplots:ticklabelasinterval} for details) and configure the tick appearance to be \marg{start} -- \marg{end} for each tick interval.
\end{pgfplotsxykey}

\subsubsection{Comb Plots}
Comb plots are very similar to bar plots except that they employ single horizontal/vertical lines instead of rectangles.

\begin{plottype}{xcomb}
\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}
\addplot+[xcomb] coordinates 
	{(4,0) (1,1) (2,2) 
	 (5,3) (6,4) (1,5)};
\end{axis}
\end{tikzpicture}
\end{codeexample}
\end{plottype}

\begin{plottype}{ycomb}
\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}
\addplot+[ycomb] plot coordinates
	{(0,3) (1,2) (2,4) (3,1) (4,2)};
\end{axis}
\end{tikzpicture}
\end{codeexample}
\end{plottype}

\subsubsection{Stacked Plots}
\begin{pgfplotskey}{stack plots=\mchoice{x,y,false} (initially false)}
	Allows stacking of plots in either $x$ or $y$ direction. Stacking means to add either $x$- or $y$ coordinates of successive |\addplot| commands on top of each other.
\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}[stack plots=y]
	\addplot coordinates
		{(0,1) (1,1) (2,2) (3,2)};
	\addplot coordinates
		{(0,1) (1,1) (2,2) (3,2)};
	\addplot coordinates
		{(0,1) (1,1) (2,2) (3,2)};
	\end{axis}
\end{tikzpicture}
\end{codeexample}

|stack plots| is particularly useful for bar plots. The following examples demonstrate its functionality. Normally, it is advisable to use the styles |ybar stacked| and |xbar stacked| which also set some other options.
\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}[stack plots=y,/tikz/ybar]
	\addplot coordinates
		{(0,1) (1,1) (2,3) (3,2) (4,1.5)};
	\addplot coordinates
		{(0,1) (1,1) (2,3) (3,2) (4,1.5)};
	\addplot coordinates
		{(0,1) (1,1) (2,3) (3,2) (4,1.5)};
	\end{axis}
\end{tikzpicture}
\end{codeexample}

\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}[ybar stacked]
	\addplot coordinates
		{(0,1) (1,1) (2,3) (3,2) (4,1.5)};
	\addplot coordinates
		{(0,1) (1,1) (2,3) (3,2) (4,1.5)};
	\addplot coordinates
		{(0,1) (1,1) (2,3) (3,2) (4,1.5)};
	\end{axis}
\end{tikzpicture}
\end{codeexample}

\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}[stack plots=x,/tikz/xbar]
	\addplot coordinates
		{(1,0) (2,1) (2,2) (3,3)};
	\addplot coordinates
		{(1,0) (2,1) (2,2) (3,3)};
	\addplot coordinates
		{(1,0) (2,1) (2,2) (3,3)};
	\end{axis}
\end{tikzpicture}
\end{codeexample}
\begin{codeexample}[]

\begin{tikzpicture}
	\begin{axis}[xbar stacked]
	\addplot coordinates
		{(1,0) (2,1) (2,2) (3,3)};
	\addplot coordinates
		{(1,0) (2,1) (2,2) (3,3)};
	\addplot coordinates
		{(1,0) (2,1) (2,2) (3,3)};
	\end{axis}
\end{tikzpicture}
\end{codeexample}
The current implementation for |stack plots| does \emph{not} interpolate missing coordinates. That means stacking will fail if the plots have different grids.
\end{pgfplotskey}

\begin{pgfplotskey}{stack dir=\mchoice{plus,minus} (initially plus)}
	Configures the direction of |stack plots|. The value |plus| will add coordinates of successive plots while |minus| subtracts them.
\end{pgfplotskey}

\begin{pgfplotskey}{reverse stacked plots=\mchoice{true,false} (initially true, default true)}
	Configures the sequence in which stacked plots are drawn. This is more or less a technical detail which should not be changed in any normal case.

	The motivation is as follows: suppose multiple |\addplot| commands are stacked on top of each other and they are processed in the order of appearance. Than, the second plot could easily draw its lines (or fill area) on top of the first one - hiding its marker or line completely. Therefor, \PGFPlots\ reverses the sequence of drawing commands.

	This has the side-effect that any normal \Tikz-paths inside of an axis will also be processed in reverse sequence.
\end{pgfplotskey}

\begin{stylekey}{/pgfplots/xbar stacked=\mchoice{plus,minus} (default plus)}
	A figure-wide style which enables stacked horizontal bars (i.e.\ |xbar| and |stack plots=x|). It also adjusts the legend and tick appearance and assigns a useful |cycle list|.
\end{stylekey}
\begin{stylekey}{/pgfplots/ybar stacked=\mchoice{plus,minus} (default plus)}
	A figure-wide style which enables stacked vertical bars (i.e.\ |ybar| and |stack plots=y|). It also adjusts the legend and tick appearance and assigns a useful |cycle list|.
\end{stylekey}

\begin{stylekey}{/pgfplots/xbar interval stacked=\mchoice{plus,minus} (default plus)}
	A style similar to |/pgfplots/xbar stacked| for the interval based bar plot variant.
\end{stylekey}
\begin{stylekey}{/pgfplots/ybar interval stacked=\mchoice{plus,minus} (default plus)}
	A style similar to |/pgfplots/ybar stacked| for the interval based bar plot variant.
\end{stylekey}

\subsubsection{Area Plots}
Area plots are a combination of |\closedcycle| and |stack plots|. They can be combined with any other plot type.

\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}[
		stack plots=y,
		area style,
		enlarge x limits=false]
	\addplot coordinates
		{(0,1) (1,1) (2,2) (3,2)} 
		\closedcycle;
	\addplot coordinates
		{(0,1) (1,1) (2,2) (3,2)}
		\closedcycle;
	\addplot coordinates
		{(0,1) (1,1) (2,2) (3,2)}
		\closedcycle;
	\end{axis}
\end{tikzpicture}
\end{codeexample}
\noindent
Area plots may need modified legends, for example using the |area legend| key. Furthermore, one may want to consider the |axis on top| key such that filled areas do not overlap ticks and grid lines. 

\begin{stylekey}{/pgfplots/area style}
	A style which sets
\begin{codeexample}[code only]
\pgfplotsset{
	/pgfplots/area style/.style={%
		area cycle list,
		area legend,
		axis on top,
	}}
\end{codeexample}
\end{stylekey}

\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}[
		const plot,
		stack plots=y,
		area style,
		enlarge x limits=false]
	\addplot coordinates
		{(0,1) (1,1) (2,2) (3,2)} 
		\closedcycle;
	\addplot coordinates
		{(0,1) (1,1) (2,2) (3,2)}
		\closedcycle;
	\addplot coordinates
		{(0,1) (1,1) (2,2) (3,2)}
		\closedcycle;
	\end{axis}
\end{tikzpicture}
\end{codeexample}

\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}[
		smooth,
		stack plots=y,
		area style,
		enlarge x limits=false]
	\addplot coordinates
		{(0,1) (1,1) (2,2) (3,2)} 
		\closedcycle;
	\addplot coordinates
		{(0,1) (1,1) (2,2) (3,2)}
		\closedcycle;
	\addplot coordinates
		{(0,1) (1,1) (2,2) (3,2)}
		\closedcycle;
	\end{axis}
\end{tikzpicture}
\end{codeexample}

\begin{codeexample}[]
\pgfplotstableread{pgfplots.timeseries.dat}\table
\pgfplotstabletypeset\table
\end{codeexample}
\begin{codeexample}[]
\pgfplotstableread
	{pgfplots.timeseries.dat}
	{\table}

\begin{tikzpicture}
	\begin{axis}[
		ymin=0,
		minor tick num=4,
		enlarge x limits=false,
		axis on top,
		every axis plot post/.append style=
			{mark=none},
		const plot,
		legend style={
			area legend,
			at={(0.5,-0.15)},
			anchor=north,
			legend columns=-1}]

	\addplot[draw=blue,fill=blue!30!white]
	 table[x=time,y=1minload] from \table
		\closedcycle;
	\addplot table[x=time,y=nodes] from \table;
	\addplot table[x=time,y=cpus] from \table;
	\addplot table[x=time,y=processes] 
		from \table;
	\legend{1min load,nodes,cpus,processes}
	\end{axis}
\end{tikzpicture}
\end{codeexample}

\begin{codeexample}[width=4cm]
\pgfplotstableread{pgfplots.timeseries.dat}\table

\begin{tikzpicture}
	\begin{axis}[
		ymin=0,
		minor tick num=4,
		enlarge x limits=false,
		const plot,
		axis on top,
		stack plots=y,
		cycle list={%
			{blue!70!black,fill=blue},%
			{blue!60!white,fill=blue!30!white},%
			{draw=none,fill={rgb:red,138;green,82;blue,232}},%
			{red,thick}%
		},
		ylabel={Mem [GB]},
		legend style={
			area legend,
			at={(0.5,-0.15)},
			anchor=north,
			legend columns=2}]

	\addplot table[x=time,y=memused]      from \table \closedcycle;
	\addplot table[x=time,y=memcached]    from \table \closedcycle;
	\addplot table[x=time,y=membuf]       from \table \closedcycle;
	\addplot+[stack plots=false]
			 table[x=time,y=memtotal]     from \table;
	\legend{Memory used,Memory cached,Memory buffered,Total memory}
	\end{axis}
\end{tikzpicture}
\end{codeexample}

\subsubsection{Scatter Plots}
The most simple scatter plots produce the same as the line plots above -- but they contain only markers. They are enabled using the |only marks| key of \Tikz.
\begin{plottype}{only marks}
Draws a simple scatter plot: all markers have the same appearance.
\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}[enlargelimits=false]
	\addplot+[only marks] 
		expression[samples=400]
		{rand};
	\end{axis}
\end{tikzpicture}
\end{codeexample}
	The |only marks| visualization style simply draws marks at every coordinate. Marks can be set with |mark=|\meta{mark name} and marker options like size and color can be specified using the |mark options=|\marg{style options} key (or by modifying the |every mark| style). The available markers along with the accepted style options can be found in section~\ref{sec:markers} on page~\pageref{sec:markers}.
\end{plottype}

\label{pgfplots:scatter}
More sophisticated scatter plots change the marker appearance for each data point. An example is that marker colors depend on the magnitude of function values $f(x)$ or other provided coordinates. The term ``scatter plot'' will be used for this type of plots in the following sections.

Scatter plots require ``source'' coordinates. These source coordinates can be the $y$ coordinate, or explicitly provided additional values.

\begin{plottype}{scatter}
	Enables marker appearance modifications. The default implementation acquires ``source coordinates'' for every data point (see |scatter src| below) and maps them linearly into the current color map. The resulting color is used as draw and fill color of the marker.

\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}
	\addplot+[scatter,only marks] 
		expression[samples=50,scatter src=y]
		{x-x^2};
	\end{axis}
\end{tikzpicture}
\end{codeexample}

	The key |scatter| is simply a boolean variable which enables marker modifications. It applies only to markers and it can be combined with any other plot type.

\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}
	\addplot+[scatter] 
		expression[samples=50,scatter src=y]
		{x^3};
	\end{axis}
\end{tikzpicture}
\end{codeexample}
\end{plottype}

Scatter plots can be configured using a set of options. One of them is mandatory, the rest allows fine grained control over marker appearance options.

\begin{pgfplotskey}{scatter src=\mchoice{none,\meta{expression},x,y,z,explicit,explicit symbolic} (initially none)}
\label{pgfplots:scatter:src}
	This key is necessary for any scatter plot. It needs to be provided as \marg{option} for |\addplot| to configure the value used to determine marker appearances. Actually, |scatter src| is nothing but an alias for \declaretext{point meta}, so the main documentation for this key is on page~\pageref{pgfplots:pointmeta}. However, we summarize the choices here together with scatter plot examples.

	Usually, |scatter src| provides input data (numeric or string type) which is used to determine colors and other style options for markers.
	The default configuration expects numerical data which is mapped linearly into the current color map.

	The value of |scatter src| determines how to get this data: the choices |x|, |y| and |z| will use either the $x$, $y$ or $z$ coordinates to determine marker options\footnote{The coordinates are used after any coordinate filters, logarithms or stacked-plot computations have been applied.}. The choice |explicit| expects the scatter source data as additional coordinate from the coordinate input streams (see section~\ref{pgfplots:providing:input} for how to provide input meta data or below for some small examples). They will be treated as numerical data. The choice |explicit symbolic| also expects scatter source data as additional meta information for each input coordinate, but it treats them as strings,  not as numerical data. Consequently, no arithmetics is performed. It is task of the scatter plot style to do something with it. See, for example, the |scatter/classes| style below.
	Finally, it is possible to provide an arbitrary mathematical expression which involves zero, one or more of the values \declaretext{x} (the current $x$ coordinate), \declaretext{y} (the current $y$ coordinate) or \declaretext{z} (the current $z$ coordinate, if any).
	A mathematical expression for |scatter src| can also depend on an explicitly provided numerical value, that means it is possible to combine the choice |explicit| and \meta{expression}. To do so, provide |scatter src| twice: 
	
	|scatter src=explicit,scatter src=meta^2|.

	The first call tells \PGFPlots\ that numerical data can be found in the coordinate input streams. This data will be called \declaretext{meta}. The second call defines the mathematical expression |meta^2| which uses this data.

	Here are examples for how to provide data for the choices |explicit| and |explicit symbolic|.
\begin{codeexample}[code only]
\begin{tikzpicture}
	\begin{axis}
		% provide color data explicitly using [<data>]
		% behind coordinates:
		\addplot+[scatter]
			[scatter src=explicit]
			coordinates {
				(0,0) [1.0e10]
				(1,2) [1.1e10]
				(2,3) [1.2e10]
				(3,4) [1.3e10]
				% ...
			};

        % Assumes a datafile.dat like
        % xcolname  ycolname    colordata
        % 0         0           0.001
        % 1         2           0.3
        % 2         2.1         0.4
        % 3         3           0.5
        % ...
        % the file may have more columns.
		\addplot+[scatter]
			[scatter src=explicit]
			table[x=xcolname,y=ycolname,meta=colordata] 
				{datafile.dat};

        % Assumes a datafile.dat like
        % 0         0           0.001
        % 1         2           0.3
        % 2         2.1         0.4
        % 3         3           0.5
        % ...
        % the first three columns will be used here:
		\addplot+[scatter]
			[scatter src=explicit]
			file {datafile.dat};
	\end{axis}
\end{tikzpicture}
\end{codeexample}

	Please note that |scatter src|$\neq$|none| results in computational work even if |scatter=false|.
\end{pgfplotskey}

\begin{stylekey}{/pgfplots/scatter/use mapped color=\marg{options for each marker} (initially draw=mapped color!80!black,fill=mapped color)}
	This style is installed by default. When active, it recomputes the color |mapped color| for every processed point coordinate by transforming the |scatter src| coordinates into the current color map linearly. Then, it evaluates the options provided as \marg{options for each marker} which are expected to depend on |mapped color|.

	The user interface for color maps is described in section~\ref{pgfplots:colormap}.
\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[title=Default arguments]
\addplot+[scatter]
	expression[scatter src=y]
	{2*x+3};
\end{axis}
\end{tikzpicture}
\end{codeexample}

\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[
	title=Black fill color and varying draw color,
	scatter/use mapped color=
		{draw=mapped color,fill=black}]
\addplot+[scatter]
	expression[scatter src=y]
	{2*x+3};
\end{axis}
\end{tikzpicture}
\end{codeexample}

\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[
	title=Black draw color and varying fill color,
	scatter/use mapped color=
		{draw=black,fill=mapped color}]
\addplot+[scatter]
	expression[scatter src=y]
	{2*x+3};
\end{axis}
\end{tikzpicture}
\end{codeexample}
	This key is actually a style which redefines |@pre marker code| and |@post marker code| (see below).
\end{stylekey}

\label{pgfplots:scatterclasses}
\begin{stylekey}{/pgfplots/scatter/classes=\marg{styles for each classname}}
	A scatter plot style which visualizes points using several classes. The style assumes that every point coordinate has a class label attached, that means the choice |scatter src=explicit symbolic| is assumed\footnote{If \texttt{scatter src} is not \texttt{explicit symbolic}, we expect a numeric argument which is rounded to the nearest integer. The resulting integer is used a class label. If that fails, the numeric argument is truncated to the nearest integer. If that fails as well, the point has no label.}. A class label can be a number, but it can also be a symbolic constant. Given class labels for every point, \marg{styles for each classname} contains a comma-separated list which associates appearance options to each class label.

\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[scatter/classes={
	a={mark=square*,blue},%
	b={mark=triangle*,red},%
	c={mark=o,draw=black}}]

	% \addplot[] is better than \addplot+[] here:
	% it avoids scalings of the cycle list
	\addplot[scatter,only marks] 
		plot[scatter src=explicit symbolic]
		coordinates {
			(0.1,0.15)  [a]
			(0.45,0.27) [c]
			(0.02,0.17) [a]
			(0.06,0.1)  [a]
			(0.9,0.5)   [b]
			(0.5,0.3)   [c]
			(0.85,0.52) [b]
			(0.12,0.05) [a]
			(0.73,0.45) [b]
			(0.53,0.25) [c]
			(0.76,0.5)  [b]
			(0.55,0.32) [c]
		};
\end{axis}
\end{tikzpicture}
\end{codeexample}
In this example, the coordinate |(0.1,0.15)| has the associated label `|a|' while |(0.45,0.27)| has the label `|c|' (see section~\ref{sec:addplot} for details about specifying point meta data). Now, The argument to |scatter/classes| contains styles for every label -- for label `|a|', square markers will be drawn in color blue. 

\begin{codeexample}[code only]
\begin{tikzpicture}
\begin{axis}[scatter/classes={
	0={mark=square*,blue},%
	1={mark=triangle*,red},%
	2={mark=o,draw=black,fill=black}}]

	% Assumes datafile.dat looks like
	% x             y               label
    % 5.000000e-01  7.500000e-01    1
    % 1.000000e+00  6.718750e-01    2
    % 1.000000e+00  5.597630e-01    2
    % 5.000000e-01  1.250000e-01    2
    % 1.000000e+00  6.603350e-01    0
    % 5.000000e-01  0.000000e+00    0
    % 0.000000e+00  5.000000e-01    0
    % 1.000000e+00  0.000000e+00    2
    % 5.000000e-01  1.250000e-01    1
    % 1.000000e+00  6.213180e-01    1
	% ...
    \addplot[scatter,only marks]
			table[scatter src=explicit symbolic,x=x,y=y,meta=label]
			{datafile.dat}
        ;
\end{axis}
\end{tikzpicture}
\end{codeexample}

In general, the format of \marg{styles for each classname} is a comma separated list of \meta{label}|=|\marg{style options}.

\paragraph{Attention:} The keys |every mark| and |mark options| have \emph{no effect} when used inside of \marg{styles for each classname}! So, instead of assigning |mark options|, you can simply provide the options directly. They apply only to markers anyway.
\end{stylekey}

\begin{pgfplotsxycodekeylist}{
	scatter/@pre marker code,
	scatter/@post marker code}
	These two keys constitute the public low-level interface which determines the marker appearance depending on the scatter source coordinates.

	Redefining them allows fine grained control even over marker types, linestyles and colors.

	The scatter plot algorithm works as follows:
\begin{enumerate} 
\item The scatter source coordinates form a data stream whose data limits are computed additionally to the axis limits. This step is skipped for |symbolic| meta data.
\item Before any markers are drawn, a linear coordinate transformation from these data limits to the interval $[0.0,1000.0]$ is initialised. 
\item Every scatter source coordinate\footnote{During the evaluation, the public macros \texttt{\textbackslash pgfplotspointmeta} and \texttt{\textbackslash pgfplotspointmetarange} indicate the source coordinate and the source coordinate range in the format $a:b$ (for log--axis, they are given in fixed point representation and for linear axes in floating point).} will be transformed linearly and the result is available as macro |\pgfplotspointmetatransformed| $ \in [0.0,1000.0]$.

The decision is thus based on per thousands of the data range. The transformation is skipped for |symbolic| meta data (and the meta data is simply contained in the mentioned macro).
\item The code of |scatter/@pre marker code| is evaluated (without arguments).
\item The standard code which draws markers is evaluated.
\item The code of |scatter/@post marker code| is evaluated (without arguments).
\end{enumerate}
	The idea is to generate a set of appearance keys which depends on |\pgfplotspointmetatransformed|. Then, a call to |\scope|\oarg{generated keys} as |@pre| code and the associated |\endscope| as |@post| code will draw markers individually using \oarg{generated keys}.

A technical example is shown below. It demonstrates how to write user defined routines, in this case a three--class system\footnote{Please note that you don't need to copy this particular example: the multiple--class example is also available as predefined style \texttt{scatter/classes}.}.
\begin{codeexample}[]
\begin{tikzpicture}
% Low-Level scatter plot interface Example: 
% use three different marker classes 
% 0% - 30%   : first class
% 30% - 60%  : second class
% 60% - 100% : third class
\begin{axis}[
scatter/@pre marker code/.code={%
   \ifdim\pgfplotspointmetatransformed pt<300pt
      \def\markopts{mark=square*,fill=blue}%
   \else
      \ifdim\pgfplotspointmetatransformed pt<600pt
         \def\markopts{mark=triangle*,fill=orange}%
      \else
         \def\markopts{mark=pentagon*,fill=red}%
      \fi
   \fi
   \expandafter\scope\expandafter[\markopts]
},%
scatter/@post marker code/.code={%
   \endscope
}]

\addplot+[scatter]
   expression[scatter src=y,samples=40]
   {sin(deg(x))};
   
\end{axis}
\end{tikzpicture}
\end{codeexample}
Please note that |\ifdim| compares \TeX\ lengths, so the example employs the suffix |pt| for any number used in this context. That doesn't change the semantics.

\paragraph{Attention:} if you attempt to redefine these keys in |\addplot|, you need to provide the complete key name, including the prefix |/pgfplots/|. For code keys (and styles), |\addplot| prefers the prefix |/tikz/| otherwise.
\index{Errors!Handled keys in addplot@Handled keys (styles and command keys) in \texttt{\textbackslash addplot}}%
\end{pgfplotsxycodekeylist}

\subsubsection{1D Colored Mesh Plots}
\begin{plottype}{mesh}
	Uses the current color map to determine colors for each fixed line segment. Each line segment will get the same color.
\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}
	\addplot[mesh] {x+sin(deg(x))};
	\end{axis}
\end{tikzpicture}
\end{codeexample}
	The color data is per default the $y$ value of the plot. It can be reconfigured using the |point meta| key (which is actually the same as |scatter src|). The following example provides the color data explicitly for |plot coordinates|, using the square bracket notation.
\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}
	\addplot[mesh,point meta=explicit] 
		coordinates {
			(0,0)   [0]
			(1,0.1) [1]
			(2,0.1) [2]
			(3,0.3) [3]
			(4,0.3) [4]
		};
	\end{axis}
\end{tikzpicture}
\end{codeexample}
	This onedimensional |mesh| plot is actually a special case of the twodimensional mesh plots, so more detailed configuration, including how to change the color data, can be found in section~\ref{sec:2d:mesh}.

\end{plottype}


\subsubsection{Interrupted Plots}
\index{Interrupted Plots}%
\label{pgfplots:interrupt}%
Sometimes it is desireable to draw parts of a single plot separately, without connection between the parts (discontinuities). This can be achieved using the \declaretext{unbounded coords} key combined with coordinate values |nan|, |inf| or |-inf|.

\begin{pgfplotskey}{unbounded coords=\mchoice{discard,jump} (initially discard)}
	This key configures what to do if one or more coordinates of a single point are unbounded. Here, unbounded means it is either $\pm \infty$ or it has the special ``not--a--number'' value |nan|.

	The initial setting \declaretext{discard} discards the complete point and a warning is issued in the log file\footnote{The warning can be disabled with \texttt{filter discard warning=false}.}. This setting has the same effect as if the unbounded point did not occur: lines will be drawn between the neighboring points.

	The alternative setting \declaretext{jump} allows interrupted plots: it provides extra checking for these coordinates and does not interpolate over them; only those line segments which are adjacent to unbounded coordinates will be skipped. 
\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[
	title=Discarding unbounded coords,
	unbounded coords=discard]

	\addplot coordinates {
		(0,0) (10,50) (20,100) (30,200) 
		(40,inf) (50,600) (60,800) (80,1000)
	};
\end{axis}
\end{tikzpicture}
\begin{tikzpicture}
\begin{axis}[
	title=Jumps at unbounded coords,
	unbounded coords=jump]
	\addplot coordinates {
		(0,0) (10,50) (20,100) (30,200) 
		(40,inf) (50,600) (60,800) (80,1000)
	};
\end{axis}
\end{tikzpicture}
\end{codeexample}

	For plot expression and its friends, it is more likely to get very large floating point numbers instead of |inf|. In this case, consider using the \declaretext{restrict x to domain} key described on page~\pageref{key:restrict:x:to:domain}.

	The |unbounded coords=jump| method does also work for mesh/surface plots: every face adjacent to an unbounded coordinate will be discarded in this case. The following example sets up a (cryptic) coordinate filter which cuts out a quarter of the domain and replaces its values with |nan|:

\pgfplotsexpensiveexample
\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[
  unbounded coords=jump,
  % A technical filter to cut out 
  % the x<0 and y<0 edge.
  filter point/.code={%
    \pgfmathparse
      {\pgfkeysvalueof{/data point/x}<0}%
    \ifpgfmathfloatcomparison
      \pgfmathparse
        {\pgfkeysvalueof{/data point/y}<0}%
      \ifpgfmathfloatcomparison
        \pgfkeyssetvalue{/data point/x}{nan}%
      \fi
    \fi
  },
  ]
  \addplot3[surf] {exp(-sqrt(x^2 + y^2))};
\end{axis}
\end{tikzpicture}
\end{codeexample}
\end{pgfplotskey}


\subsection{Three Dimensional Plot Types}
\label{sec:3d}
\PGFPlots\ comes provides three dimensional visualizations like scatter, line, mesh or surface plots. This section explains the methods to provide input coordinates and how to use the different plot types.

\subsubsection{Before You Start With 3D}
\label{pgfplots:3d:preliminary}
Before we delve into the capabilities of \PGFPlots\ for three dimensional visualization, let me start with some preliminary remarks. The reason to use \PGFPlots\ for three dimensional plots are similar to those of normal, two dimensional plots: the possibility to get consistent fonts and document consistent styles combined with high--quality output.

While this works very nice for (not too complex) two dimensional plots, it requires considerably more effort than non--graphical documents. This is even more so for three dimensional plots. In other words: \PGFPlots' three dimensional routines are slow. There are reasons for this and some of them may vanish in future versions. But one of these reasons is, that \TeX\ has never been designed for complex visualisation techniques. Consider the image externalization routines mentioned in section~\ref{sec:pgfplots:export} to reduce typesetting time. Besides the speed limitations, three dimensional plots reaches memory limits easily. There for, the plot complexity of three dimensional plots is limited to relatively coarse resolutions.

Another issue which arises in three dimensional visualization is: \PGFPlots\ doesn't really know anything about depth. Both, the underlying \PGF\ package and the Portable Document Format (|.pdf|) as such are inherently two--dimensional. \PGFPlots\ does its best to maintain a reasonable efficiency combined with routines which yield good quality. It has z buffering emulation techniques. But still, it is just a more--or--less smart way of drawing lines and polygons on top of each other. You may encounter the limitations sometimes. Maybe it will be improved in future versions.

If you decide that you need high complexity, speed and 100\% reliable z buffers (depth information), you should consider using other visualization tools and return to \PGFPlots\ in several years. If you can wait for a complex picture and you don't even see the limitations arising from z buffering defiancies, you should use \PGFPlots.

Enough for now, let's continue.

\subsubsection{Providing Three Dimensional Coordinate Input}
\label{pgfplots:sec:threedim}
\begin{addplot3generic}
	The |\addplot3| command is the main interface for any three dimensional plot. It works in the same way as its two dimensional variant |\addplot| which has been described in all detail in section~\ref{cmd:pgfplots:addplot} on page~\pageref{cmd:pgfplots:addplot}.

	The |\addplot3| command accepts the same input methods as the |\addplot| variant, including expression plotting, coordinates, files and tables. However, a third coordinate is necessary for each of these methods which is usually straight--forward and is explained in all detail in the following.

	Furthermore, |\addplot3| has a way to decide whether a \emph{line} visualization or a \emph{mesh} visualization has to be done. The first one is map from one dimension into $\R^3$ and the latter one a map from two dimensions to $\R^3$. Here, the keys \declaretext{mesh/rows} and \declaretext{mesh/cols} are used to define mesh sizes (matrix sizes). Usually, you don't have to care about that because the coordinate input routines already allow either onedimensional or two dimensional structure.
\end{addplot3generic}

\begin{addplot3operation}[]{coordinates}{\marg{coordinate list}}
	The |\addplot3 coordinates| method works like its twodimensional variant, |\addplot coordinates| which is described in all detail on page~\pageref{pgfplots:addplot:coordinates}:

	A long list of coordinates |(|\meta{x}|,|\meta{y}|,|\meta{z}|)| is expected. The input list can be either an unordered series of coordinates, for example for scatter or line plots. It can also have matrix structure, in which an empty input lines marks the end of one matrix row. Matrix structure can also be provided if one of \declaretext{mesh/rows} or \declaretext{mesh/cols} is provided explicitly.
	
\long\def\temporarytest{\noexpand\par}
\begin{codeexample}[newline=\temporarytest]
\begin{tikzpicture}
	\begin{axis}
		% this yields a 3x4 matrix:
		\addplot3[surf] coordinates {
			(0,0,0) (1,0,0)   (2,0,0)   (3,0,0)

			(0,1,0) (1,1,0.6) (2,1,0.7) (3,1,0.5)

			(0,2,0) (1,2,0.7) (2,2,0.8) (3,2,0.5)
		};
	\end{axis}
\end{tikzpicture}
\end{codeexample}
	\noindent Here, |\addplot3| reads a matrix with three rows and four columns. The empty lines separate one row from the following.
\end{addplot3operation}

\begin{addplot3operation}[]{file}{\marg{name}}
	The |\addplot3 file| input method is the same as |\addplot file| -- it only expects one more coordinate.
	Thus, the input file contains $x_i$ in the first column, $y_i$ in the second column and $z_i$ in the third. 
	
	A further column is read if |point meta=explicit| has been requested, see the documentation of |\addplot file| on page~\pageref{pgfplots:addplot:file} for details.
	
	As for |\addplot3 coordinates|, an empty line in the file marks the end of one matrix row.
\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}
		% We have `plotdata/first3d.dat' with
		%---------
		% 0	0 0.8
		% 1	0 0.56
		% 2	0 0.5
		% 3	0 0.75
		%
		% 0	1 0.6
		% 1	1 0.3
		% 2	1 0.21
		% 3	1 0.3
		%
		% 0	2 0.68
		% 1	2 0.22
		% 2	2 0.25
		% 3	2 0.4
		%
		% 0	3 0.7
		% 1	3 0.5
		% 2	3 0.58
		% 3	3 0.9
		% -> yields a 4x4 matrix:
		\addplot3[surf] file {plotdata/first3d.dat};
	\end{axis}
\end{tikzpicture}
\end{codeexample}
\end{addplot3operation}

\begin{addplot3operation}[]{table}{\oarg{column selection}\marg{file}}
	The |\addplot3 table| works in the same way as its two dimensional counterpart |\addplot table|. It only expects a column for the $z$ coordinates. Furthermore, it interpretes empty input lines as end--of--row markers.
\end{addplot3operation}

\begin{pgfplotskeylist}{mesh/rows=\marg{integer},mesh/cols=\marg{integer}}
	For visualization of mesh or surface plots which need some sort of matrix input, the dimensions of the input matrix need to be known in order to visualize the plots correctly. The matrix structure may be known from end--of--row marks (empty lines in the input stream) as has been described above.

	If the matrix structure is not yet known, it is necessary to provide at least one of |mesh/rows| or |mesh/cols|.

	Thus, the following example is also a valid method to define an input matrix.
\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}
		% this yields also 3x4 matrix:
		\addplot3[surf,mesh/rows=3] coordinates {
			(0,0,0) (1,0,0)   (2,0,0)   (3,0,0)
			(0,1,0) (1,1,0.6) (2,1,0.7) (3,1,0.5)
			(0,2,0) (1,2,0.7) (2,2,0.8) (3,2,0.5)
		};
	\end{axis}
\end{tikzpicture}
\end{codeexample}

	It is enough to supply one of |mesh/rows| or |mesh/cols| -- the missing values will be determined automatically.
	
	If you provide one of |mesh/rows| or |mesh/cols|, any end--of--row marker seen inside of input files or coordinate streams will be ignored.
\end{pgfplotskeylist}
\begin{pgfplotskey}{mesh/ordering=\mchoice{rowwise,colwise} (initially rowwise)}
	Allows to configure the sequence in which matrizes (meshes) are read from |\addplot3 coordinates|, |\addplot3 file| or |\addplot3 table|. The default method is to read matrizes in row-wise ordering.

	Please note that |shader=interp| relies on low level shadings which need to be given in row wise ordering, so a (potentially expensive) transposition of the data matrix will be performed in this case. If possible, supply your data in row wise ordering.
\end{pgfplotskey}

\begin{addplot3operation}[]{expression \marg{math expr}}{}
\label{cmd:addplot3:expr}
	Expression plotting also works in the same way as for two dimensional plots. Now, however, a two dimensional mesh is samples instead of a single line.

	The method |\addplot3 |\marg{math expr} visualizes the function $f(x,y) = $\meta{math expr} where $ f \colon [x_1,x_2] \times [y_1,y_2] \to \R$. The interval $[x_1,x_2]$ is determined using the \declaretext{domain} key, for example using |domain=0:1|. The interval $[y_1,y_2]$ is determined using the \declaretext{y domain} key. If |y domain| is empty, $[y_1,y_2] = [x_1,x_2]$ will be assumed.

	The number of samples in $x$ direction is set using the \declaretext{samples} key. The number of samples in $y$ direction is set using the \declaretext{samples y} key. If |samples y| is not set, the same value as for $x$ is used.

\pgfplotsexpensiveexample
\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}
		\addplot3[surf] {y};
	\end{axis}
\end{tikzpicture}
\end{codeexample}

\pgfplotsexpensiveexample
\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}[colorbar]
		\addplot3
			[surf,faceted color=blue,
			 domain=0:1,y domain=-1:1]
			{x^2 - y^2};
	\end{axis}
\end{tikzpicture}
\end{codeexample}

	Expression plotting sets |mesh/rows| and |mesh/cols| automatically; these settings don't have any effect for expression plotting.
\end{addplot3operation}

\begin{addplot3operation}[]{\marg{math expression}}{}
	Use

	|\addplot3 |\marg{math expression}|;|

	as short-hand equivalent for

	|\addplot3 expression |\marg{math expression}|;|
\end{addplot3operation}

\begin{addplot3operation}[]{(\meta{$x$ expression},\meta{$y$ expression},\meta{$z$ expression})}{}
	A variant of |\addplot3 expression| which allows to provide different coordinate expressions for the $x$, $y$ and $z$ coordinates. This can be used to generate parameterized plots.

	Please note that |\addplot (x,y,x^2)| is equivalent to |\addplot expression {x^2}|.

	Note further that since the complete point expression is surrounded by round braces, you can't use round braces inside of \meta{$x$ expression}, \meta{$y$ expression} or \meta{$z$ expression} directly -- surround the expressions with curly braces additionally.
\end{addplot3operation}

\subsubsection{Scatter Plots}

\subsubsection{Mesh Plots}
\label{sec:2d:mesh}
\begin{plottype}{mesh}
	A mesh plot uses different colors for each line segment. Each line segment gets the same color. The color is determined using a ``color coordinate'' which is also called ``meta data'' throughout this document. It is the same data which is used for surface and scatter plots as well, see section~\ref{pgfplots:pointmeta}. In the initial configuration, the ``color coordinate'' is the $z$ axis (or the $y$ axis for two dimensional plots). This color coordinate is mapped linearly into the current color map to determine the color for each line segment. Thus, if the smallest occuring color data is, say, $-1$ and the largest is $42$, points with color data $-1$ will get the color at the lower end of the color map and points with color data $42$ the color of the upper end of the color map.

\pgfplotsexpensiveexample
\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}
		\addplot3[mesh] {x^2};
	\end{axis}
\end{tikzpicture}
\end{codeexample}

	A mesh plot can be combined with markers or with the |scatter| key which does also draw markers in different colors.

\pgfplotsexpensiveexample
\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}
	\addplot3+[mesh,scatter,samples=10,domain=0:1] 
		{x*(1-x)*y*(1-y)};
	\end{axis}
\end{tikzpicture}
\end{codeexample}

\pgfplotsexpensiveexample
\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}[grid=major,view={210}{30}]
	\addplot3+[mesh,scatter,samples=10,domain=0:1] 
		{5*x*sin(2*deg(x)) * y*(1-y)};
	\end{axis}
\end{tikzpicture}
\end{codeexample}

	\paragraph{Details:}
	\begin{itemize}
		\item 
	A mesh plot uses the same implementation as |shader=flat| to get one color for each single segment. Thus, if |shader=flat mean|, the color for a segment is determined using the \emph{mean} of the color data of adjacent vertices. If |shader=flat corner|, the color of a segment is the color of \emph{one} adjacent vertex.
		\item As soon as |mesh| is activated, \declaretext{color=mapped color} is installed. This is \emph{necessary} unless one needs a different color -- but |mapped color| is the only color which reflects the color data.

		It is possible to use a different color using the \declaretext{color=}\meta{color name} as for any other plot.

		\item It is easily possible to add \declaretext{mark=}\meta{marker name} to mesh plots, \declaretext{scatter} is also possible. Scatter plots will use the same color data as for the mesh.
	\end{itemize}

\pgfplotsexpensiveexample
\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}[view/az=14]
	\addplot3[mesh,draw=red,samples=10] {x^2-y^2};	
	\end{axis}
\end{tikzpicture}
\end{codeexample}
\end{plottype}

\begin{pgfplotskey}{z buffer=\mchoice{none,auto,sort,reverse x seq,reverse y seq,reverse xy seq} (initially auto)}
	This key allows to choose between different $z$ buffering strategies. A $z$ buffer determines which parts of an image should be drawn in front of other parts. Since both, the graphics packages \PGF\ and the final document format |.pdf| are inherently two dimensional, this work has to be done in \TeX. Currently, several (fast) heuristics can be used which work reasonably well for simple mesh- and surface plots. Furthermore, there is a (time consuming) sorting method which does also work if the fast heuristics fail.

	However, the $z$ buffering algorithms of \PGFPlots\ are only a first step towards 3D visualization -- and they apply only to a single plot. This has two implications which have already been discussed in the preliminary section~\ref{pgfplots:3d:preliminary}: at first the depth information is only simulated. There can (and will) be limitations, and even this limited feature is slow. Second, you can't apply the $z$ buffering strategies to a whole picture; not even to a mesh and its plot marks. The $z$ buffering algorithms are applied only to one plot part.

	The choice \declaretext{none} disables $z$ buffering. This is also the case for two dimensional axes which don't need $z$ buffering.

	The choice \declaretext{auto} is the initial value for any mesh- or surface plot: it uses a very fast heuristics to decide how to realize $z$ buffering for mesh and surface plots. The idea is to reverse either the sequence of $x$ coordinates, or those of all $y$ coordinates, or both. For regular meshes, this suffices to provide $z$ buffering. In other words: the choice |auto| will use one of the three reverse strategies (or none at all).

	The choice \declaretext{sort} can be used for scatter, line, mesh and surface plots. It really sorts according to the depth of each point (or mesh segment)\footnote{The choice \texttt{sort} is \emph{not} available for surface plots with \texttt{shader=interp} because the low level format doesn't support sorting.}. Sorting in \TeX\ uses a slow algorithm and may require a lot of memory (although it has the expected runtime asymptotics $\mathcal O(N \log N)$).

	The remaining choices apply only to mesh/surface plots and do nothing more then their name indicates: they reverse the coordinate sequences (using quasi linear runtime). They should only be used in conjunction by |z buffer=auto|.
\end{pgfplotskey}

\subsubsection{Surface Plots}
\label{sec:pgfplots:surfplots}
\begin{plottype}{surf}
	A surface plot visualizes a two dimensional, single patch using different fill colors for each patch segment. Each patch segment is a (pseudo) rectangle, that means input data is given in form of a data matrix as is discussed in the introductory section about three dimensional coordinates,~\ref{pgfplots:sec:threedim}.

\pgfplotsexpensiveexample
\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}
		\addplot3[surf,shader=interp] {x*y};
	\end{axis}
\end{tikzpicture}
\end{codeexample}

	The simplest way to generate surface plots is to use the plot expression feature, but -- as discussed in section~\ref{pgfplots:sec:threedim} -- other input methods like tables or coordinate lists are also possible. 

	The appearance can be configured using color maps, the value of the \declaretext{shader} key and the current \declaretext{draw} and \declaretext{fill} color.

\pgfplotsexpensiveexample
\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}[
		grid=major,
		colormap/greenyellow]
	\addplot3[surf,samples=30,domain=0:1] 
		{5*x*sin(2*deg(x)) * y};
	\end{axis}
\end{tikzpicture}
\end{codeexample}

\pgfplotsexpensiveexample
\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}
		\addplot3[surf,faceted color=blue] {x+y};
	\end{axis}
\end{tikzpicture}
\end{codeexample}

\pgfplotsexpensiveexample
\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}[colormap/cool]
	\addplot3[surf,samples=10,domain=0:1,
		shader=interp] 
		{x*(1-x)*y*(1-y)};
	\end{axis}
\end{tikzpicture}
\begin{tikzpicture}
	\begin{axis}[colormap/cool]
	\addplot3[surf,samples=25,domain=0:1,
		shader=flat] 
		{x*(1-x)*y*(1-y)};
	\end{axis}
\end{tikzpicture}
\end{codeexample}

\pgfplotsexpensiveexample
\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}[grid=major]
		\addplot3[surf,shader=interp,
			samples=25,domain=0:2,y domain=0:1] 
			{exp(-x) * sin(pi*deg(y))};
	\end{axis}
\end{tikzpicture}
\end{codeexample}

\pgfplotsexpensiveexample
\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}[grid=major]
		\addplot3[surf,shader=faceted,
			samples=25,domain=0:2,y domain=0:1] 
			{exp(-x) * sin(pi*deg(y))};
	\end{axis}
\end{tikzpicture}
\end{codeexample}

	Details about the shading algorithm are provided below in the documentation of \declaretext{shader}.
\end{plottype}

\begin{pgfplotskey}{shader=\mchoice{flat,interp,faceted,flat corner,flat mean} (initially faceted)}
	Configures the shader used for surface plots. The shader determines how the color data available at each single vertex is used to fill the surface patch.

	The simplest choice is to use one fill color for each segment, the choice |flat|.

\pgfplotsexpensiveexample
\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}
	\addplot3[surf,shader=flat,
		samples=10,domain=0:1] 
		{x^2*y};
	\end{axis}
\end{tikzpicture}
\end{codeexample}

	\noindent The |flat| shader provides full support of |z buffer|ing, that means it does also support the choice |z buffer=sort|. There are (currently) two possibilities to determine the single color for every segment:
	\begin{description}
		\item[\declaretext{flat corner}] Uses the color data of one vertex to color the segment.
		\FIXME{this is not well defined if z buffering changes the ordering of vertices!}

		\item[\declaretext{flat mean}] Uses the mean of all four color data values to color the segment. This is the initial value as it provides symmetric colors for symmetric functions.
	\end{description}
	The choice |flat| is actually the same as |flat mean|. Please note that |shader=flat mean| and |shader=flat corner| also influence mesh plots -- the choices determine the mesh segment color.

	Another choice is |shader=interp| which uses Gouraud shading (bilinear interpolation) to fill the segments. 

\pgfplotsexpensiveexample
\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}
	\addplot3[surf,shader=interp,
		samples=10,domain=0:1] 
		{x^2*y};
	\end{axis}
\end{tikzpicture}
\end{codeexample}

	The |shader=interp| setting requires a special low--level shading implementation which is currently (only) available for the postscript driver \declaretext{pgfsys-dvips.def} and the |pdflatex| driver \declaretext{pgfsys-pdftex.def}. For other drivers, the choice |shader=interp| will result in a warning and is equivalent to |shader=flat mean|. 
	


	Finally, the choice |shader=faceted| uses a constant fill color for every line segment (as for |flat|) and the value of the key \declaretext{/pgfplots/faceted color} to draw the connecting mesh elements:
\pgfplotsexpensiveexample
\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}
	\addplot3[surf,shader=faceted,
		samples=10,domain=0:1] 
		{x^2*y};
	\end{axis}
\end{tikzpicture}
\end{codeexample}


	\paragraph{Details:}
	\begin{itemize}
		\item The choice |shader=faceted| is the same as |shader=flat| -- except that it uses a special draw color.
		
		So, |shader=faceted| has the same effect as 
		
		|shader=flat,draw=\pgfkeysvalueof{/pgfplots/faceted color}|.

		\item The |flat| shader uses the current |draw| and |fill| colors. They are set with |color=mapped color| and can be overruled with |draw=|\meta{draw color} and |fill=|\meta{fill color}. The |mapped color| always contains the color of the color map. 
		
		\item The |interp| shader does not support mesh colors and it uses the current color map in any case (it simply ignores the values of |draw| and |fill|).

		\item You easily add \declaretext{mark=}\meta{plot mark} to mesh and/or surface plots or even colored plot marks with \declaretext{scatter}. The scatter plot feature will use the same color data as for the surface.

		But: Markers and surfaces do not share the same depth information. They are drawn on top of each other.

		\item For surface plots with lots of points, |shader=interp| produces smaller |pdf| documents, requires less compilation time in \TeX\ and requires less time to display in Acrobat Reader.

		\item The postscript driver did not work when I tried to write hex encoded 32 bit binary coordinates into the shading. So, the postscript driver \emph{truncates} coordinates to 24 bit -- which might result in a loss of precision (the truncation is not very intelligent). See the \declaretext{surf shading/precision} key for details. To improve compatibility, this 24 bit truncation algorithm is enabled by default.
	\end{itemize}

\pgfplotsexpensiveexample
\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}
	\addplot3[surf,shader=flat,
		draw=black,
		samples=10,domain=0:1] 
		{x^2*y};
	\end{axis}
\end{tikzpicture}
\end{codeexample}

\pgfplotsexpensiveexample
\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}
	\addplot3[surf,shader=faceted,
		scatter,mark=*,
		samples=10,domain=0:1] 
		{x^2*y};
	\end{axis}
\end{tikzpicture}
\end{codeexample}
\end{pgfplotskey}

\begin{pgfplotskey}{faceted color=\marg{color name} (initially mapped color!80!black)}
	Defines the color to be used for meshes of faceted surface plots.
\end{pgfplotskey}

\begin{pgfplotskey}{surf shading/precision=\mchoice{pdf,postscript,ps} (initially postscript)}
	A key to configure how the low level driver for |shader=interp| writes its data. The choice |pdf| uses 32 bit binary coordinates (which is lossless). The resulting |.pdf| files appear to be correct, but they can't be converted to postscript -- the converter software always complaints about an error. 

	The choice |postscript| (or, in short, |ps|) uses 24 bit truncated binary coordinates. This results in both, readable |.ps| and |.pdf| files. However, the truncation is lossy.

	If anyone has ideas how to fix this problem: let me know. As far as I know, postscript should accept 32 bit coordinates, so it might be a mistake in the shading driver.
\end{pgfplotskey}

\subsubsection{Parameterized Plots}
Parameterized plots use the same plot types as documented in the preceding sections: both, mesh and surface plots are actually special parameterized plots where $x$ and $y$ are on cartesian grid points.

Parameterized plots just need a special way to provide the coordinates:

\pgfplotsexpensiveexample
\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}[view={60}{30}]
	\addplot3+[domain=0:5*pi,samples=60,samples y=0] 
		({sin(deg(x))},
		 {cos(deg(x))},
		 {2*x/(5*pi)});
	\end{axis}
\end{tikzpicture}
\end{codeexample}
\noindent The preceding example uses |samples y=0| to indicate that a line shall be samples instead of a matrix. The curly braces are necessary because \TeX\ can't nest round braces. The single expressions here are used to parameterize the helix.

Other example follow. Note that |z buffer=sort| is a necessary method here.

\pgfplotsexpensiveexample
\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[view={60}{30}]
	\addplot3[mesh,z buffer=sort,
		samples=20,domain=-1:0,y domain=0:2*pi]
		({sqrt(1-x^2) * cos(deg(y))},
		 {sqrt( 1-x^2 ) * sin(deg(y))},
		 x);
\end{axis}
\end{tikzpicture}
\end{codeexample}

\pgfplotsexpensiveexample
\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[view={60}{30}]
	\addplot3[mesh,z buffer=sort,
		scatter,only marks,scatter src=z,
		samples=30,domain=-1:1,y domain=0:2*pi]
		({sqrt(1-x^2) * cos(deg(y))},
		 {sqrt( 1-x^2 ) * sin(deg(y))},
		 x);
\end{axis}
\end{tikzpicture}
\end{codeexample}

\pgfplotsexpensiveexample
\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[view={60}{30}]
	\addplot3[surf,shader=flat,z buffer=sort,
		samples=30,domain=-1:0,y domain=0:2*pi]
		({sqrt(1-x^2) * cos(deg(y))},
		 {sqrt( 1-x^2 ) * sin(deg(y))},
		 x);
\end{axis}
\end{tikzpicture}
\end{codeexample}


\subsection{Markers, Linestyles, Colors and Colormaps}
\label{sec:markers}%
The following options of \Tikz\ are available to plots.
\subsubsection{Markers}
This list is copied from~\cite[section~29]{tikz}:
\begingroup
\newenvironment{longdescription}[0]{%
	\begin{list}{}{%
		\leftmargin=4.3cm
		\setlength{\labelwidth}{4.3cm}%
		\renewcommand{\makelabel}[1]{\hfill\textbf{\texttt{##1}}}%
	}%
}{%
	\end{list}%
}%
\def\showit#1{%
	\tikz\draw[%
		gray,
		thin,
		mark options={fill=yellow!80!black,draw=black,scale=2},
		x=0.8cm,y=0.3cm,
		#1]
	plot coordinates {(0,0) (1,1) (2,0) (3,1)};%
}%
\begin{longdescription}
	\item[mark=*] \showit{mark=*}
	\item[mark=x] \showit{mark=x}
	\item[mark=+] \showit{mark=+}
%	\item[mark=ball] \showit{mark=ball}
\end{longdescription}
And with |\usetikzlibrary{plotmarks}|:
\begin{longdescription}
	\item[mark=$-$] \showit{mark=-}
	\item[mark=$\vert$] \showit{mark=|}
	\item[mark=o] \showit{mark=o}
	\item[mark=asterisk] \showit{mark=asterisk}
	\item[mark=star] \showit{mark=star}
	\item[mark=oplus] \showit{mark=oplus}
	\item[mark=oplus*] \showit{mark=oplus*}
	\item[mark=otimes] \showit{mark=otimes}
	\item[mark=otimes*] \showit{mark=otimes*}
	\item[mark=square] \showit{mark=square}
	\item[mark=square*] \showit{mark=square*}
	\item[mark=triangle] \showit{mark=triangle}
	\item[mark=triangle*] \showit{mark=triangle*}
	\item[mark=diamond] \showit{mark=diamond}
	\item[mark=diamond*] \showit{mark=diamond*}
	\item[mark=pentagon] \showit{mark=pentagon}
	\item[mark=pentagon*] \showit{mark=pentagon*}
	\item[mark=text] \showit{mark=text,every mark/.append style={scale=0.5}} 

	This marker is special as it can be configured freely. The character (or even text) used is configured by a set of variables, see below.
	\item[User defined] It is possible to define new markers with |\pgfdeclareplotmark|, see below.
	\item[mark=cube] FIXME : example
	\item[mark=cube*] FIXME : example
\end{longdescription}
All these options have been drawn with the additional options
\begin{codeexample}[code only]
\draw[
	gray,
	thin,
	mark options={%
		scale=2,fill=yellow!80!black,draw=black
	}
]
\end{codeexample}
Please see section~\ref{sec:colors} for how to change draw- and fill colors.

\begin{key}{/pgf/text mark=\marg{text} (initially p)}
	Changes the text shown by |mark=text|.

	With |/pgf/text mark=m|: \pgfkeys{/pgf/text mark=m}\showit{mark=text,every mark/.append style={scale=0.5}}

	With |/pgf/text mark=A|: \pgfkeys{/pgf/text mark=A}\showit{mark=text,every mark/.append style={scale=0.5}}

	There is no limitation about the number of characters or whatever. In fact, any \TeX\ material can be inserted as \marg{text}, including images.
\end{key}
\begin{key}{/pgf/text mark/style=\marg{options for \texttt{mark=text}}}
	Defines a set of options which control the appearance of |mark=text|.

	If |/pgf/text mark/as node=false| (the default), \marg{options} is provided as argument to |\pgftext| -- which provides only some basic keys like |left|, |right|, |top|, |bottom|, |base| and |rotate|.

	If |/pgf/text mark/as node=true|, \marg{options} is provided as argument to |\node|. This means you can provide a very powerful set of options including |anchor|, |scale|, |fill|, |draw|, |rounded corners| etc. 
\end{key}
\begin{key}{/pgf/text mark/as node=\mchoice{true,false} (initially false)}
	Configures how |mark=text| will be drawn: either as |\node| or as |\pgftext|.

	The first choice is highly flexible and possibly slow, the second is very fast and usually enough.
\end{key}

\begin{key}{/tikz/mark size=\marg{dimension}}
	This \Tikz\ option allows to set marker sizes to \marg{dimension}. For circular markers, \marg{dimension} is the radius, for other plot marks it is about half the width and height.
\end{key}
\begin{key}{/tikz/every mark}
	This \Tikz\ style can be reconfigured to set marker appearance options like colors or transformations like scaling or rotation. \PGFPlots\ appends its cycle list options to this style.
\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[y=2cm]
	\addplot coordinates 
		{(-2,0) (-1,1) (0,0) (1,1) (2,0)};
\end{axis}
\end{tikzpicture}
\end{codeexample}

\begin{codeexample}[]
\tikzset{every mark/.append style={scale=2}}
\begin{tikzpicture}
\begin{axis}[y=2cm]
	\addplot coordinates 
		{(-2,0) (-1,1) (0,0) (1,1) (2,0)};
\end{axis}
\end{tikzpicture}
\end{codeexample}
\end{key}

\begin{command}{\pgfdeclareplotmark\marg{plot mark name}\marg{code}}
	Defines a new marker named \marg{plot mark name}. Whenever it is used, \marg{code} will be invoked. It is suppose to contain (preferrable \PGF\ basic level) drawing commands. During \marg{code}, the coordinate system's origin denotes the coordinate where the marker shall be placed.

	Please refer to~\cite{tikz} section ``Mark Plot Handler'' for more detailed information.
\end{command}



\begin{stylekey}{/pgfplots/every axis plot post (initially {})}
The |every axis plot post| style can be used to overwrite parts (or all) of the drawing styles which are assigned for plots.
\begin{codeexample}[]
% Overwrite any cycle list:
\pgfplotsset{
  every axis plot post/.append style={
   mark=triangle,
   every mark/.append style={rotate=90}}}
\begin{tikzpicture}
\begin{axis}[y=2cm]
	\addplot coordinates 
		{(-2,0) (-1,1) (0,0) (1,1) (2,0)};
\end{axis}
\end{tikzpicture}
\end{codeexample}
\end{stylekey}

\begin{stylekey}{/pgfplots/no markers}
	Disables plot marks.

	If this style is provided as argument to a complete axis, it is appended to |every axis plot post| such that it disables markers even for cycle lists which contain markers.
\end{stylekey}

\begin{key}{/tikz/mark options=\marg{options}}
	Resets |every mark| to \marg{options}.
\end{key}

Markers paths are not subjected to clipping as other parts of the figure. Markers are either drawn completely or not at all.

\Tikz\ offers more options for marker fine tuning, please refer to~\cite{tikz} for details.

\subsubsection{Line Styles}
\def\showit#1{%
	\tikz\draw[%
		black,
		x=0.8cm,y=0.3cm,
		#1]
	plot coordinates {(0,0) (1,1) (2,0) (3,1)};%
}%
The following line styles are predefined in \Tikz.
\begin{stylekey}{/tikz/solid}
	 \showit{style=solid}
\end{stylekey}

\begin{stylekey}{/tikz/dotted}
	 \showit{style=dotted}
\end{stylekey}

\begin{stylekey}{/tikz/densely dotted}
	 \showit{style=densely dotted}
\end{stylekey}

\begin{stylekey}{/tikz/loosely dotted}
	 \showit{style=loosely dotted}
\end{stylekey}

\begin{stylekey}{/tikz/dashed}
	 \showit{style=dashed}
\end{stylekey}

\begin{stylekey}{/tikz/densely dashed}
	 \showit{style=densely dashed}
\end{stylekey}

\begin{stylekey}{/tikz/loosely dashed}
	 \showit{style=loosely dashed}
\end{stylekey}
\noindent since these styles apply to markers as well, you may want to consider using 
\begin{codeexample}[code only]
\pgfplotsset{
	every mark/.append style={solid}
}
\end{codeexample}
\noindent in marker styles.

Besides linestyles, \PGF\ also offers (a lot of) arrow heads. Please refer to~\cite{tikz} for details.
\endgroup


\subsubsection{Font Size and Line Width}
Often, one wants to change line width and font sizes for plots. This can be done using the following options of \Tikz.

\begin{key}{/tikz/font=\marg{font name} (initially \textbackslash normalfont)}
	Sets the font which is to be used for text in nodes (like tick labels, legends or descriptions).

	A font can be any \LaTeX\ argument like |\footnotesize| or |\small\bfseries|\footnote{Con\TeX t and plain \TeX\ users need to provide other statements, of course.}.

	It may be useful to change fonts only for specific axis descriptions, for example using
\begin{codeexample}[code only]
\pgfplotsset{
	tick label style={font=\small},
	label style={font=\small},
	legend style={font=\footnotesize}
}
\end{codeexample}
\end{key}

\begin{key}{/tikz/line width=\marg{dimension} (initially 0.4pt)}
	Sets the line width. Please note that line widths for tick lines and grid lines are predefined, so it may be necessary to override the styles |every tick| and |every axis grid|.

	The |line width| key is changed quite often in \Tikz. You should use
\begin{codeexample}[code only]
\pgfplotsset{every axis/.append style={line width=1pt}}
\end{codeexample}
	or
\begin{codeexample}[code only]
\pgfplotsset{every axis/.append style={thick}}
\end{codeexample}
	to change the overall line width. To also adjust ticks and grid lines, one can use
\begin{codeexample}[code only]
\pgfplotsset{every axis/.append style={
	line width=1pt,
	tick style={line width=0.6pt}}}
\end{codeexample}
	or styles like
\begin{codeexample}[code only]
\pgfplotsset{every axis/.append style={
	thick,
	tick style={semithick}}}
\end{codeexample}
	The `|every axis plot|' style can be used to change line widths for plots only.
\end{key}

\begin{keylist}[/tikz]{ultra thin,very thin,semithick,thick,very thick,ultra thick}
	These \Tikz\ styles provide different predefined line widths.
\end{keylist}

This example shows the same plots as on page~\pageref{page:plotcoords:src} (using |\plotcoords| as place holder for the commands on page~\pageref{page:plotcoords:src}), with different line width and font size.
\begin{codeexample}[]
\pgfplotsset{every axis/.append style={
	font=\large,
	line width=1pt,
	tick style={line width=0.8pt}}}
\begin{tikzpicture}
	\begin{loglogaxis}[
		legend style={at={(0.03,0.03)},
			anchor=south west},
		xlabel=\textsc{Dof},
		ylabel=$L_2$ Error
	]
	% see above for this macro:
	\plotcoords
	\legend{$d=2$,$d=3$,$d=4$,$d=5$,$d=6$}
	\end{loglogaxis}
\end{tikzpicture}
\end{codeexample}

\begin{codeexample}[]
\pgfplotsset{every axis/.append style={
	font=\footnotesize,
	thin,
	tick style={ultra thin}}}
\begin{tikzpicture}
	\begin{loglogaxis}[
		xlabel=\textsc{Dof},
		ylabel=$L_2$ Error
	]
	% see above for this macro:
	\plotcoords
	\legend{$d=2$,$d=3$,$d=4$,$d=5$,$d=6$}
	\end{loglogaxis}
\end{tikzpicture}
\end{codeexample}


\subsubsection{Colors}
\label{sec:colors}
{%
\def\showcolorandname#1{%
	\showcolor{#1}~#1%
}%
\def\showcolor#1{%
	\tikz \draw[black,fill={#1}] (0,0) rectangle (1em,0.6em);%
}%
\PGF\ uses the color support of |xcolor|. Therefore, the main reference for how to specify colors is the |xcolor| manual~\cite{xcolor}. The \PGF\ manual~\cite{tikz} is the reference for how to select colors for specific purposes like drawing, filling, shading, patterns etc.\ This section contains a short overview over the specification of colors in~\cite{xcolor} (which is not limited to \PGFPlots).

The package |xcolor| defines a set of predefined colors, namely 
\showcolorandname{red},
\showcolorandname{green},
\showcolorandname{blue},
\showcolorandname{cyan},
\showcolorandname{magenta},
\showcolorandname{yellow},
\showcolorandname{black},
\showcolorandname{gray},
\showcolorandname{white},
\showcolorandname{darkgray},
\showcolorandname{lightgray},
\showcolorandname{brown},
\showcolorandname{lime},
\showcolorandname{olive},
\showcolorandname{orange},
\showcolorandname{pink},
\showcolorandname{purple},
\showcolorandname{teal},
\showcolorandname{violet}.

\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}[enlarge x limits=false]
	\addplot[red]
		expression[samples=500] {sin(deg(x))};

	\addplot[orange] 
		expression[samples=7] {sin(deg(x))};

	\addplot[teal,const plot] 
		expression[samples=14] {sin(deg(x))};
	\end{axis}
\end{tikzpicture}
\end{codeexample}

Besides predefined colors, it is possible to \emph{mix} two (or more) colors. For example, \showcolorandname{red!30!white} contains $30\%$ of \showcolorandname{red} and $70\%$ of \showcolorandname{white}. Consequently, one can build \showcolorandname{red!70!white} to get $70\%$ red and $30\%$ white or \showcolorandname{red!10!white} for $10\%$ red and $90\%$ white. This mixing can be done with any color, \showcolorandname{red!50!green}, \showcolorandname{blue!50!yellow}.

A different type of color mixing is supported, which allows to take $100\%$ of \emph{each} component. For example, \showcolorandname{rgb,2:red,1;green,1} will add $1/2$ part \showcolorandname{red} and $1/2$ part \showcolorandname{green} and we reproduced the example from above. Using the denominator~$1$ instead of~$2$ leads to \showcolorandname{rgb,1:red,1;green,1} which uses $1$ part \showcolorandname{red} and $1$ part \showcolorandname{green}. Many programs allow to select pieces between $0,\dotsc,255$, so a denominator of $255$ is useful. Consequently, \showcolorandname{rgb,255:red,231;green,84;blue,121} uses $231/255$ red, $84/255$ green and $121/255$. This corresponds to the standard RGB color $(231,84,121)$. Other examples are \showcolorandname{rgb,255:red,32;green,127;blue,43}, \showcolorandname{rgb,255:red,178;green,127;blue,43}, \showcolorandname{rgb,255:red,169;green,178;blue,43}.

It is also possible to use RGB values, the HSV color model or the HTML color syntax directly. However, this requires some more programming. I suppose this is the fastest (and probably the most uncomfortable) method to use colors. For example, 
\begin{codeexample}[]
\definecolor{color1}{rgb}{1,1,0}
\tikz \fill[color1] 
	(0,0) rectangle (1em,0.6em);
\end{codeexample}
\noindent creates the color with $100\%$ red, $100\%$ green and $0\%$ blue;

\begin{codeexample}[]
\definecolor{color1}{HTML}{D0B22B}
\tikz \fill[color1] 
	(0,0) rectangle (1em,0.6em);
\end{codeexample}
\noindent creates the color with $208/255$ pieces red, $178/255$ pieces green and $43$ pieces blue, specified in standard HTML notation. Please refer to the |xcolor| manual~\cite{xcolor} for more details and color models.
}%

\begin{keylist}{
	/tikz/color=\marg{a color},
	/tikz/draw=\marg{stroke color},
	/tikz/fill=\marg{fill color}}
	These keys are (generally) used to set colors. Use |color| to set the color for both, drawing and filling. Instead of |color=|\marg{color name} you can simply write \marg{color name}. The |draw| and |fill| keys only set colors for stroking and filling, respectively.

	Use |draw=none| to disable drawing and |fill=none| to disable filling\footnote{Up to now, plot marks always have a stroke color (some also have a fill color). This restriction may be lifted in upcoming versions.}.% This does also work for markers.
%--------------------------------------------------
% \ begin{codeexample}[]
% \begin{tikzpicture}
% 	\begin{axis}
% 	\addplot+[only marks,mark=square*,
% 		mark options={fill=red!50!white,draw=none}]
% 		{4*x^2 - 2*x +4 };
% 	\end{axis}
% \end{tikzpicture}
% \end{codeexample}
%-------------------------------------------------- 

	Since these keys belong to \Tikz, the complete documentation can be found in the \Tikz\ manual~\cite[Section ``Specifying a Color'']{tikz}.
\end{keylist}

\subsubsection{Color Maps}
\label{pgfplots:colormap}
\begin{pgfplotskey}{colormap name=\marg{color map name} (initially hot)}
	Changes the current color map to the already defined map named \marg{color map name}. The predefined color map is

	\begin{tabular}{>{\ttfamily}ll}
	hot & \pgfplotsshowcolormap{hot}\\
	\end{tabular}

	Further color maps are described below.

	Colormaps can be used, for example, in scatter plots (see section~\ref{pgfplots:scatter}).

	You can use |colormap| to create new color maps (see below).
\end{pgfplotskey}

\begin{pgfplotskey}{colormap=\marg{name}\marg{color specification}}
	Defines a new colormap named \marg{name} according to \marg{color specification} and activates it using |colormap name=|\marg{name}.
	
	The \marg{color specification} is a sequence of positions and associated colors where linear interpolation is applied inbetween. The syntax is very similar as the one used for \PGF\ shadings described in~\cite[VIII -- Shadings]{tikz}: it is a semicolon--separated series of 
	
	\meta{color type}|(|\meta{offset}|)=(|\meta{color value}|); |:
	
\begin{codeexample}[code only]
% possibility 1: like PGF shadings:
rgb(0cm)=(1,0,0); rgb(1cm)=(0,1,0); rgb255(2cm)=(0,0,255); gray(3cm)=(0.3);  color(4cm)=(green)
\end{codeexample}
\pgfplotsshowcolormapexample{rgb(0cm)=(1,0,0); rgb(1cm)=(0,1,0); rgb255(2cm)=(0,0,255); gray(3cm)=(0.3);  color(4cm)=(green)}

	If the distance between successive colors is the same anyway, one can skip the \meta{offset}. The `|;|' separators are not necessary as well:

\begin{codeexample}[code only]
% (simplified) possibility 2: skip `;' and length arguments:
rgb=(1,0,0) rgb=(0,1,0) rgb255=(0,0,255) gray=(0.3) color=(green)
\end{codeexample}
\pgfplotsshowcolormapexample{rgb=(1,0,0) rgb=(0,1,0) rgb255=(0,0,255) gray=(0.3) color=(green)}

	It is also possible to provide non-uniform distances between the different colors -- if all single positions can be projected onto a uniform grid. \PGFPlots\ will perform this interpolation automatically:

\begin{codeexample}[code only]
% non uniform spacing example: the mesh width is provided as first
% part of the specification.
\pgfplotset{colormap={violetnew}
	{[1cm] rgb255(0cm)=(25,25,122) color(1cm)=(white) rgb255(5cm)=(238,140,238)}}
\end{codeexample}
\pgfplotsshowcolormapexample{[1cm] rgb255(0cm)=(25,25,122) color(1cm)=(white) rgb255(5cm)=(238,140,238)}

\noindent In this last example, the mesh width has been provided explicitly and \PGFPlots\ interpolates the missing grid points on its own. It is an error if the provided positions are no multiple of the mesh width. The |\pgfplotsset| employs the public user interface to create a new color map named `|violetnew|'.

\noindent The single colors can be separated by semicolons `|;|'. The (optional) length describes how much of the bar is occupied by the interval, it is interpreted relative to the complete length. If the length argument is missing, it is taken to be the last specified length plus the last length difference (the first color defaults to |1cm| in this case). 

Each entry has the form \meta{color model}|(|\meta{length}|)=(|\meta{arguments}|)| where the \meta{length} argument is optional as discussed. The example above means that the left end of the color map shall have RGB components $1,0,0$, indicating $100\%$ red and $0\%$ green and blue. The next entity starts at |1cm| and describes a color with $100\%$ green. The |rgb255| also expects three RGB components, but in the range $[0,255]$. Finally, |gray| specifies a color in parenthesis with the same value for each, R G and B and |color| accesses predefined colors.

\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}[
		colormap={bw}{gray(0cm)=(0); gray(1cm)=(1)}]
	\addplot+[scatter,only marks]
		plot[scatter src=y,domain=0:8,samples=100]
		{exp(x)};
	\end{axis}
\end{tikzpicture}
\end{codeexample}
The complete length of a color map is irrelevant: it will be mapped linearly to an internal range anyway (for efficient interpolation). The only requirement is that the left end must be at |0|.

Available color maps are shows below.

\end{pgfplotskey}

\begin{stylekey}{/pgfplots/colormap/hot}
	A style which installs the colormap

	|{color(0cm)=(blue); color(1cm)=(yellow); color(2cm)=(orange); color(3cm)=(red)}|

	\pgfplotsshowcolormap{hot}

	This is the preconfigured color map.
\end{stylekey}

\begin{stylekey}{/pgfplots/colormap/bluered}
	A style which installs the colormap

	|{rgb255(0cm)=(0,0,180); rgb255(1cm)=(0,255,255); rgb255(2cm)=(100,255,0); |

	|rgb255(3cm)=(255,255,0); rgb255(4cm)=(255,0,0); rgb255(5cm)=(128,0,0)}|,

	\pgfplotsshowcolormap{bluered}

\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}[colormap/bluered]
	\addplot+[scatter]
		expression[scatter src=x,samples=50]
		{sin(deg(x))};
	\end{axis}
\end{tikzpicture}
\end{codeexample}

	\paragraph{Remark:} 
	The style |bluered| (re-)defines the color map and activates it. \TeX\ will be slightly faster if you call |\pgfplotsset{colormap/bluered}| in the preamble (to create the color map once) and use |colormap name=bluered| whenever you need it. This remark holds for every color map style which follows. But you can simply ignore this remark.
\end{stylekey}

\begin{stylekey}{/pgfplots/colormap/cool}
	A style which installs the colormap

	|{rgb255(0cm)=(255,255,255); rgb255(1cm)=(0,128,255); rgb255(2cm)=(255,0,255)}|

	\pgfplotsshowcolormap{cool}
\end{stylekey}

\begin{stylekey}{/pgfplots/colormap/greenyellow}
	A style which installs the colormap

	|{rgb255(0cm)=(0,128,0); rgb255(1cm)=(255,255,0)}|

	\pgfplotsshowcolormap{greenyellow}
\end{stylekey}

\begin{stylekey}{/pgfplots/colormap/redyellow}
	A style which installs the colormap

	|{rgb255(0cm)=(255,0,0); rgb255(1cm)=(255,255,0)}|

	\pgfplotsshowcolormap{redyellow}
\end{stylekey}

\begin{stylekey}{/pgfplots/colormap/violet}
	A style which installs the colormap

	|{rgb255=(25,25,122) color=(white) rgb255=(238,140,238)}|

	\pgfplotsshowcolormap{violet}
\end{stylekey}

\begin{stylekey}{/pgfplots/colormap/blackwhite}
	A style which installs the colormap

	|{gray(0cm)=(0); gray(1cm)=(1)}|

	\pgfplotsshowcolormap{blackwhite}
\end{stylekey}

\begin{command}{\pgfplotscolormaptoshadingspec\marg{colormap name}\marg{right end size}\marg{\textbackslash macro}}
	A command which converts a colormap into a \PGF\ shading's color specification. It can be used in commands like |\pgfdeclare*shading| (see the \PGF\ manual~\cite{tikz} for details).

	The first argument is the name of a (defined) colormap, the second the rightmost dimension of the specification. The result will be stored in \meta{\textbackslash macro}.
\begin{codeexample}[]
	% convert `hot' -> \result
	\pgfplotscolormaptoshadingspec{hot}{8cm}\result
	% define and use a shading in pgf:
	\def\tempb{\pgfdeclarehorizontalshading{tempshading}{1cm}}%
	% where `\result' is inserted as last argument:
	\expandafter\tempb\expandafter{\result}%
	\pgfuseshading{tempshading}%
\end{codeexample}
The usage of the result \meta{\textbackslash macro} is a little bit low--level.
\end{command}

\subsubsection{Options Controlling Linestyles}

\label{sec:cycle:list}%
\begin{pgfplotskeylist}{cycle list=\marg{list},cycle list name=\marg{\textbackslash macro}}
Allows to specify a list of plot specifications which will be used for each \hbox{|\addplot|}-command without explicit plot specification.

There are several possiblities to change it:
\begin{enumerate}
	\item Use one of the predefined lists\footnote{These lists were named \texttt{\textbackslash coloredplotspeclist} and \texttt{\textbackslash blackwhiteplotspeclist} which appeared to be unnecessarily long, so they have been renamed. The old names are still accepted, however.},
		\begin{itemize}
			\item |color| (from top to bottom)
\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[
	stack plots=y,stack dir=minus,
	cycle list name=color]
\addplot coordinates {(0,1) (0.5,1) (1,1)};
\addplot coordinates {(0,1) (0.5,1) (1,1)};
\addplot coordinates {(0,1) (0.5,1) (1,1)};
\addplot coordinates {(0,1) (0.5,1) (1,1)};
\addplot coordinates {(0,1) (0.5,1) (1,1)};
\addplot coordinates {(0,1) (0.5,1) (1,1)};
\addplot coordinates {(0,1) (0.5,1) (1,1)};
\addplot coordinates {(0,1) (0.5,1) (1,1)};
\addplot coordinates {(0,1) (0.5,1) (1,1)};
\addplot coordinates {(0,1) (0.5,1) (1,1)};
\addplot coordinates {(0,1) (0.5,1) (1,1)};
\addplot coordinates {(0,1) (0.5,1) (1,1)};
\addplot coordinates {(0,1) (0.5,1) (1,1)};
\end{axis}
\end{tikzpicture}
\end{codeexample}

			\item |exotic| (from top to bottom)
\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[
	stack plots=y,stack dir=minus,
	cycle list name=exotic]
\addplot coordinates {(0,1) (0.5,1) (1,1)};
\addplot coordinates {(0,1) (0.5,1) (1,1)};
\addplot coordinates {(0,1) (0.5,1) (1,1)};
\addplot coordinates {(0,1) (0.5,1) (1,1)};
\addplot coordinates {(0,1) (0.5,1) (1,1)};
\addplot coordinates {(0,1) (0.5,1) (1,1)};
\addplot coordinates {(0,1) (0.5,1) (1,1)};
\addplot coordinates {(0,1) (0.5,1) (1,1)};
\addplot coordinates {(0,1) (0.5,1) (1,1)};
\addplot coordinates {(0,1) (0.5,1) (1,1)};
\addplot coordinates {(0,1) (0.5,1) (1,1)};
\addplot coordinates {(0,1) (0.5,1) (1,1)};
\addplot coordinates {(0,1) (0.5,1) (1,1)};
\end{axis}
\end{tikzpicture}
\end{codeexample}

	\item |black white| (from top to bottom)
\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[
	stack plots=y,stack dir=minus,
	cycle list name=black white]
\addplot coordinates {(0,1) (0.5,1) (1,1)};
\addplot coordinates {(0,1) (0.5,1) (1,1)};
\addplot coordinates {(0,1) (0.5,1) (1,1)};
\addplot coordinates {(0,1) (0.5,1) (1,1)};
\addplot coordinates {(0,1) (0.5,1) (1,1)};
\addplot coordinates {(0,1) (0.5,1) (1,1)};
\addplot coordinates {(0,1) (0.5,1) (1,1)};
\addplot coordinates {(0,1) (0.5,1) (1,1)};
\addplot coordinates {(0,1) (0.5,1) (1,1)};
\addplot coordinates {(0,1) (0.5,1) (1,1)};
\addplot coordinates {(0,1) (0.5,1) (1,1)};
\addplot coordinates {(0,1) (0.5,1) (1,1)};
\addplot coordinates {(0,1) (0.5,1) (1,1)};
\end{axis}
\end{tikzpicture}
\end{codeexample}
		\end{itemize}

These predefined cycle lists habe been created with
\begin{codeexample}[code only]
\pgfplotscreateplotcyclelist{color}{%
	blue,every mark/.append style={fill=blue!80!black},mark=*\\%
	red,every mark/.append style={fill=red!80!black},mark=square*\\%
	brown!60!black,every mark/.append style={fill=brown!80!black},mark=otimes*\\%
	black,mark=star\\%
	blue,every mark/.append style={fill=blue!80!black},mark=diamond*\\%
	red,densely dashed,every mark/.append style={solid,fill=red!80!black},mark=*\\%
	brown!60!black,densely dashed,every mark/.append style={
		solid,fill=brown!80!black},mark=square*\\%
	black,densely dashed,every mark/.append style={solid,fill=gray},mark=otimes*\\%
	blue,densely dashed,mark=star,every mark/.append style=solid\\%
	red,densely dashed,every mark/.append style={solid,fill=red!80!black},mark=diamond*\\%
}
\pgfplotscreateplotcyclelist{black white}{%
	every mark/.append style={fill=gray},mark=*\\%
	every mark/.append style={fill=gray},mark=square*\\%
	every mark/.append style={fill=gray},mark=otimes*\\%
	mark=star\\%
	every mark/.append style={fill=gray},mark=diamond*\\%
	densely dashed,every mark/.append style={solid,fill=gray},mark=*\\%
	densely dashed,every mark/.append style={solid,fill=gray},mark=square*\\%
	densely dashed,every mark/.append style={solid,fill=gray},mark=otimes*\\%
	densely dashed,every mark/.append style={solid},mark=star\\%
	densely dashed,every mark/.append style={solid,fill=gray},mark=diamond*\\%
}
\pgfplotscreateplotcyclelist{exotic}{%
	teal,every mark/.append style={fill=teal!80!black},mark=*\\%
	orange,every mark/.append style={fill=orange!80!black},mark=square*\\%
	cyan!60!black,every mark/.append style={fill=cyan!80!black},mark=otimes*\\%
	red!70!white,mark=star\\%
	lime!80!black,every mark/.append style={fill=lime},mark=diamond*\\%
	red,densely dashed,every mark/.append style={solid,fill=red!80!black},mark=*\\%
	yellow!60!black,densely dashed,
		every mark/.append style={solid,fill=yellow!80!black},mark=square*\\%
	black,every mark/.append style={solid,fill=gray},mark=otimes*\\%
	blue,densely dashed,mark=star,every mark/.append style=solid\\%
	red,densely dashed,every mark/.append style={solid,fill=red!80!black},mark=diamond*\\%
}
\end{codeexample}

	\item Provide the list explicitly,
\begin{codeexample}[]
\begin{tikzpicture}
\begin{loglogaxis}[cycle list={%
	{blue,mark=*},
	{red,mark=square},
	{dashed,mark=o},
	{loosely dotted,mark=+},
	{brown!60!black,
		mark options={fill=brown!40},
		mark=otimes*}}
]
\plotcoords
\legend{$d=2$,$d=3$,$d=4$,$d=5$,$d=6$}
\end{loglogaxis}
\end{tikzpicture}
\end{codeexample}
	(This example list requires |\usetikzlibrary{plotmarks}|).
	\item Define macro names and use them with `|cycle list name|':
\begin{codeexample}[code only]
\pgfplotscreateplotcyclelist{mylist}{%
	{blue,mark=*},
	{red,mark=square},
	{dashed,mark=o},
	{loosely dotted,mark=+},
	{brown!60!black,mark options={fill=brown!40},mark=otimes*}}
...
\begin{axis}[cycle list name=mylist]
	...
\end{axis}
\end{codeexample}
\end{enumerate}

\paragraph{Remark:} You can also terminate single entries with `|\\|' as in
\begin{codeexample}[code only]
\begin{axis}[cycle list={%
	blue,mark=*\\%
	red,mark=square\\%
	dashed,mark=o\\%
	loosely dotted,mark=+\\%
	brown!60!black,
		mark options={fill=brown!40},
		mark=otimes*\\}
]
...
\end{axis}
\end{codeexample}
In this case, the \emph{last} entry also needs a terminating `|\\|', but one can omit braces around the single entries.
\end{pgfplotskeylist}

\subsection{Providing Color Data - Point Meta}
\label{pgfplots:point:meta}
\PGFPlots\ provides features which modify plots depending on a special coordinate, the ``point meta data''. For example, scatter plots may vary marker colors, size or appearance depending on this special data. Surface and mesh plots are another example: here, the color of a surface patch (or mesh part) depends on ``point meta''.

The common idea idea is to tell \PGFPlots\ how to get this data. It is not necessary to provide data explicitly -- in many cases, the data which is used to color surface patches or marker colors is the plot's $y$ or $z$ coordinate. The method used to tell \PGFPlots\ where to find ``point meta data'' is the \declaretext{point meta} key. 

A further common idea is the use of color maps: if the point meta data is in the interval $[m_{\text{min}},m_{\text{max}}]$, the point meta coordinate $m = m_{\text{min}}$ will get the lowest color provided by the color map while $m=m_{\text{max}}$ will get the highest color provided by the color map. Any coordinate between this values will be mapped linearly: for example, the mean $m = 1/2 (m_{\text{max}} + m_{\text{min}})$ will get the middle color of the color map. This is why ``point meta'' is sometimes called ``color data''.

\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}
		\addplot[mesh,point meta=y,thick] {x^2};
		% FIXME : provide colorbar!
	\end{axis}
\end{tikzpicture}
\end{codeexample}

\begin{pgfplotskey}{point meta=\mchoice{none,\meta{expression},x,y,z,explicit,explicit symbolic} (initially none)}
	\label{pgfplots:pointmeta}
	The |point meta| key tells \PGFPlots\ where to get the special point meta data. Please note that |point meta| and |scatter src| is actually the same -- |scatter src| is an alias for |point meta|. Thus, the summary provided for |scatter src| on page~\pageref{pgfplots:scatter:src} covers the same topics. However, the main reference for |point meta| is here.
	
	\begin{description}
		\item[\declaretext{none}] The initial choice |none| disables point meta data, resulting in no computational work. Any other choice will activate the computation of upper and lower ranges for point meta data, i.e.\ the computation of $[m_{\text{min}},m_{\text{max}}]$. 

		\item[\declaretext{x}] The choice |x| uses the already available $x$ coordinates as point meta data. This does always refer to the \emph{final} $x$ coordinates after any user transformations, logarithms, stacked plot computations etc.\ have been applied.

		\item[\declaretext{y}]
		\item[\declaretext{z}]
			 The choices |y| and |z| are similar: they use the $y$ or $z$ coordinates respectively as point meta data. Consequently, these three choices do \emph{not} need any extra data.

		\item[\declaretext{explicit}] This choice tells \PGFPlots\ to expect \emph{numerical} point meta data which is provided explicitly in the coordinate input streams. This data will be transformed linearly into the current color map as it has been motivated above.
		
		How point meta data is provided for |plot coordinates|, |plot table| and the other input methods is described in all detail in section~\ref{pgfplots:providing:input} -- but we provide small examples here to summarize the possibilities:
\begin{codeexample}[code only]
\begin{tikzpicture}
	\begin{axis}
		% for 'coordinates':
		% provide color data explicitly using [<data>]
		% behind coordinates:
		\addplot+[point meta=explicit]
			coordinates {
				(0,0) [1.0e10]
				(1,2) [1.1e10]
				(2,3) [1.2e10]
				(3,4) [1.3e10]
				% ...
			};

		% for 'table':
        % Assumes a datafile.dat like
        % xcolname  ycolname    colordata
        % 0         0           0.001
        % 1         2           0.3
        % 2         2.1         0.4
        % 3         3           0.5
        % ...
        % the file may have more columns.
		\addplot+[point meta=explicit]
			table[x=xcolname,y=ycolname,meta=colordata] 
				{datafile.dat};

		% for 'file':
        % Assumes a datafile.dat like
        % 0         0           0.001
        % 1         2           0.3
        % 2         2.1         0.4
        % 3         3           0.5
        % ...
        % the first three columns will be used here as x,y and meta,
		% resp.
		\addplot+[point meta=explicit]
			file {datafile.dat};

		% 'table' using expressions which may depend on all
		% columns:
        % Assumes a datafile.dat like
        % xcolname  ycolname    anything    othercol
        % 0         0           4           15
        % 1         2           5           20
        % 2         2.1         8           30
        % 3         3           42          40
        % ...
        % the file may have more columns.
		\addplot+[point meta=explicit]
			table[
				x=xcolname,y=ycolname,
				meta expr={0.5*(\thisrow{anything} + sqrt(\thisrow{othercol}))}] 
				{datafile.dat};
	\end{axis}
\end{tikzpicture}
\end{codeexample}
		Thus, there are several methods to provide point meta (color data). The key for the choice |explicit| is that some data is provided explicitly -- although |point meta| doesn't know how. The data is expected to be of numerical type and is mapped linearly into the range $[0,1000]$ (maybe for use in the current color map).

		\item[\declaretext{explicit symbolic}] The choice |explicit symbolic| is very similar to |explicit| in that it expects extra data by the coordinate input routines. However, |explicit symbolic| does not necessarily expect numerical data: you can provide any sort of symbols. One might provide a set of styles, one for each class in a scatter plot. This is realised using \declaretext{scatter/classes}, see page~\pageref{pgfplots:scatterclasses}. Input data is provided in the same fashion as mentioned above for the choice |explicit|. 
		
		Currently, this choice can only be used for scatter plots.

		\item[\declare{\meta{expression}}] This choice finally allows to compute point meta data using a mathematical expression. The \meta{expression} may depend on |x|, |y|, |z| which yield the current $x$, $y$ or $z$ coordinate, respectively. The coordinates are completely processed (transformations, logs) as mentioned above for the choice |x|. Furthermore, the \meta{expression} may depend on commands which are valid during |\addplot| like \declaretext{\textbackslash plotnum} or \declaretext{\textbackslash coordindex} (see section~\ref{pgfplots:misc} for details). Computations are performed using the floating point unit of \PGF, and all supported arithmetical operations can be used. 
		
		In essence, the \meta{expression} may depend on everything which is known to all |\addplot| commands: the $x$, $y$ and (if any) $z$ coordinates. Note that it is \emph{not} possible to access columns names of input tables in this context (use the choice |explicit| combined with the meta data generation methods of |plot table| for such a task, cf\ the example above).

		In addition to $x$, $y$ and $z$ coordinates, the \meta{expression} may also depend on any explicitly provided point meta data. This can be realized by providing two |point meta| keys. For example,

		|point meta=explicit, point meta=meta^2+3|

		will expect point meta data as explicitly provided coordinate from the input streams. This data will be called \declaretext{meta}. In a second step, this data will be put into the mathematical expression |meta^2+3| which depends on |meta|.
	\end{description}

	It has been mentioned several times that one application of point meta data is to determine (marker/face/edge) colors using a linear map into the range $[0,1000]$ (maybe for use in the current color map). This map works as follows: it is a function
	\[ \phi\colon [m_{\text{min}},m_{\text{max}}] \to [0,1000] \]
	with
	\[ \phi(m) = \frac{m - m_{\text{min}}} {1000} \]
	such that $\phi(m_{\text{min}}) = 0$ and $\phi(m_{\text{max}})=1000$. The value $1000$ is -- per convention -- the upper limit of all color maps. Now, if a coordinate (or edge/face) has the point meta data $m$, its color will be determined using $\phi(m)$: it is the color at $\phi(m)$\textperthousand\ of the current color map.

	This transformation depends on the interval $[m_{\text{min}},m_{\text{max}}]$ which, in turn, can be modified using the keys \declaretext{point meta rel}, \declaretext{point meta min} and \declaretext{point meta max} described below.

	The untransformed point meta data is available in the macro |\pgfplotspointmeta| (only in the correct context, for example the scatter plot interfaces). This macro contains a low level floating point number. The transformed data will be available in the macro |\pgfplotspointmetatransformed| and is in fixed point representation. It is expected to be in the range $[0,1000]$.

\end{pgfplotskey}

\begin{pgfplotskey}{scatter src=\marg{value}}
	This is an alias for |point meta=|\marg{value}. Its description along with scatter plot specific documentation can be found on page~\pageref{pgfplots:scatter:src}.
\end{pgfplotskey}

\begin{pgfplotskey}{point meta rel=\mchoice{axis wide,per plot} (initially axis wide)}
	As already explained in the documentation for |point meta|, one application for point meta data is to determine colors using the current color map and a linear map from point meta data into the current color map. The question is how this linear map is computed. 

	The key |point meta rel| configures whether the interval of all point meta coordinates, $[m_{\text{min}},m_{\text{max}}]$ is computed as maximum over all plots in the complete axis (the choice \declaretext{axis wide}) or only for one particular plot (the choice \declaretext{per plot}).

\begin{codeexample}[]
\begin{tikzpicture}
   \begin{axis}[
      title=Axis wide color mapping,
      colorbar,
      samples=50,point meta rel=axis wide,
	  point meta=y]

      \addplot[mesh,thick] {sin(deg(x))};
      \addplot[mesh,thick] {3*tanh(x)};
   \end{axis}
\end{tikzpicture}
~
\begin{tikzpicture}
   \begin{axis}[
      title=Per Plot color mapping,
      colorbar,
      samples=50,
	  point meta rel=per plot,
	  point meta=y]

      \addplot[mesh,thick] {sin(deg(x))};
      \addplot[mesh,thick] {3*tanh(x)};
   \end{axis}
\end{tikzpicture}
\end{codeexample}
\end{pgfplotskey}

\begin{pgfplotskeylist}{point meta min=\marg{number},point meta max=\marg{number}}
	These keys allow to define the range required for the linear map of point meta data into the range $[0,1000]$ (for example, for current maps) explicitly. This is necessary if the same mapping shall be used for more than one axis.

	\paragraph{Remarks about special cases:}
	\begin{itemize}
		\item It is possible to provide limits partially; in this case, only the missing limit will be computed.
		\item If point meta data falls outside of these limits, the linear transformation is still well defined which is acceptable (unless the interval is of zero length). However, color data can't be outside of these limits, so color bars perform a truncation.
		\item This key can be provided for single plots as well as for the complete axis (or for both).
		\item If meta limits are provided for a single plot, these limits may also contribute to the axis wide meta interval.
	\end{itemize}
\end{pgfplotskeylist}

\begin{pgfplotskey}{colormap access=\mchoice{map,direct} (initially map)}
	This key configures how point meta data is used to determine colors from a color map. The initial configuration |map| performs the linear mapping operation explained above. The choice |direct| does not perform any transformation; it takes the point meta as integers indizes into the current color map. 
\end{pgfplotskey}



\subsection{Axis Descriptions}
Axis descriptions are labels for $x$ and $y$ axis, titles, legends and the like. Axis descriptions are drawn after the plot is finished and they are not subjected to clipping. 

\subsubsection{Placement of Axis Descriptions}
This section describes how to \emph{modify} the placement of titles, labels, legends and other axis descriptions. It may be skipped at first reading.

There are different methods to place axis descriptions. One of them is to provide coordinates relative to the axis' rectangle such that |(0,0)| is the lower left corner and |(1,1)| is the upper right corner -- this is very useful for figure titles or legends. Coordinates of this type, i.e.\ without unit like |(0,0)| or |(1.03,1)|, are called \declaretext{axis description cs} (the |cs| stands for ``coordinate system''). One other method is of primary interest for axis labels -- they should be placed near the tick labels, but it a way that they don't overlap or obscure tick labels. Furthermore, axis labels shall be placed such that they are automatically moved if the axis is rotated (or tick labels are moved to the right side of the figure). There is a special coordinate system to realize these two demands, the \declaretext{ticklabel cs}.

In the following, the two coordinate systems \declaretext{axis description cs} and \declaretext{ticklabel cs} are described in more details. It should be noted that \declaretext{axis description cs} is used automatically, so it might never be necessary to use it explicitly.


\begin{coordinatesystem}{axis description cs}
\label{pgfplots:sec:axis:description:cs}
	A coordinate system which is used to place axis descriptions. Whenever the option `|at={(|\meta{x}|,|\meta{y}|)}|' occurs in |label style|, |legend style| or any other axis description, |(|\meta{x}|,|\meta{y}|)| is interpreted to be a coordinate in |axis description cs|.

	The point $(0,0)$ is always the lower left corner of the tightest bounding box around the axis (without any descriptions or ticks) while the point $(1,1)$ is the upper right corner of this bounding box.

	In most cases, it is \emph{not} necessary to explicitly write |axis description cs| as it is the default coordinate system for any axis description. An example for how coordinates are placed is shown below.
	
\begin{codeexample}[width=4cm]
% [See the TikZ manual if you'd like to learn about nodes and pins]
\begin{tikzpicture}
	\tikzset{
		every pin/.style={fill=yellow!50!white,rectangle,rounded corners=3pt,font=\tiny},
		small dot/.style={fill=black,circle,scale=0.3}
	}
	\begin{axis}[
		clip=false,
		title=How \texttt{axis description cs} works
	]
	\addplot {x};

	\node[small dot,pin=120:{$(0,0)$}]      at (axis description cs:0,0) {};
	\node[small dot,pin=-30:{$(1,1)$}]      at (axis description cs:1,1) {};
	\node[small dot,pin=-90:{$(1.03,0.5)$}] at (axis description cs:1.03,0.5) {};
	\node[small dot,pin=125:{$(0.5,0.5)$}]  at (axis description cs:0.5,0.5) {};
	\end{axis}
\end{tikzpicture}
\end{codeexample}

Axis descriptions are \Tikz\ nodes, that means all placement and detail options of \cite{tikz} apply. The point on the node's boundary which is actually shifted to the |at| coordinate needs to be provided with an anchor (cf~\cite[Nodes and Edges]{tikz}):
\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}[
		legend entries={$x$,$x^2$},
		legend style={
			at={(1.03,0.5)},
			anchor=west
		}
	]
	\addplot {x};
	\addplot {x^2};
	\end{axis}
\end{tikzpicture}
\end{codeexample}
	
	Standard anchors of nodes are |north|, |east|, |south|, |west| and mixed components like |north east|.
	Please refer to \cite{tikz} for a complete documentation of anchors.

\paragraph{Remarks:} 
\begin{itemize}
	\item Each of the anchors described in section~\ref{pgfplots:sec:align} can be described by |axis description cs| as well.
	\item The |axis description cs| is independend of axis reversals or skewed axes.
	Only for the default configuration of boxed axes is it the same as |rel axis cs|, i.e.\ |(0,0)| is the same as the smallest axis coordinate and |(1,1)| is the largest one in case of standard boxed axes\footnote{This was different in versions before 1.3: earlier versions did not have the distinction between \texttt{axis description cs} and \texttt{rel axis cs}.}.

	\item Even for three dimensional axes, the |axis description cs| is still two-dimensional: it always refers to coordinates relative to the tightest bounding box around the axis (without any descriptions or ticks).
\begin{codeexample}[width=4cm]
% the same as above for 3D ...
% [See the TikZ manual if you'd like to learn about nodes and pins]
\begin{tikzpicture}
	\tikzset{
		every pin/.style={fill=yellow!50!white,rectangle,rounded corners=3pt,font=\tiny},
		small dot/.style={fill=black,circle,scale=0.3}
	}
	\begin{axis}[
		clip=false,
		title=How \texttt{axis description cs} works in 3D
	]
	\addplot3 coordinates {(-5,-5,-5) (5,5,5)};

	\draw[black!15] (axis description cs:0,0) rectangle (axis description cs:1,1);

	\node[small dot,pin=120:{$(0,0)$}]      at (axis description cs:0,0) {};
	\node[small dot,pin=-30:{$(1,1)$}]      at (axis description cs:1,1) {};
	\node[small dot,pin=-90:{$(1.03,0.5)$}] at (axis description cs:1.03,0.5) {};
	\node[small dot,pin=125:{$(0.5,0.5)$}]  at (axis description cs:0.5,0.5) {};
	\end{axis}
\end{tikzpicture}
\end{codeexample}
	
	\item Since the view does not influence these positions, |axis description cs| might not be a good choice for axis labels in 3D. The \declaretext{ticklabel cs} is used in this case.
\end{itemize}
\end{coordinatesystem}

\begin{coordinatesystemlist}{%
	xticklabel cs,%
	yticklabel cs,%
	zticklabel cs,
	ticklabel cs}
	A set of special coordinate systems intended to place axis descriptions (or any other drawing operation) besides tick labels, in a way such that tick label are not obscured.

	The |xticklabel cs| (and its variants) always refer to one, uniquely identified axis: the one which is annotated with tick labels. The |ticklabel cs| can only be used in contexts where the axis is clear (for example, inside of |xlabel style| -- there, the |ticklabel cs| is equivalent to |xticklabel cs|).

	Each of these coordinate systems allows to specify points on a straight line which is placed parallel to an axis containing tick labels, moved away just far enough to avoid overlaps with the tick labels:
\begin{codeexample}[width=4cm]
\tikzset{
	every pin/.style={fill=yellow!50!white,rectangle,rounded corners=3pt,font=\tiny},
	small dot/.style={fill=black,circle,scale=0.3}
}
\begin{tikzpicture}
\begin{axis}[
	clip=false,
	ticklabel style={draw=red},
	title=Positioning with \texttt{xticklabel cs}]
	\addplot {x};
	\node[small dot,pin=-90:{\texttt{xticklabel cs:0}}]     at (xticklabel cs:0) {};
	\node[small dot,pin=-90:{\texttt{xticklabel cs:0.5}}]   at (xticklabel cs:0.5) {};
	\node[small dot,pin=-90:{\texttt{xticklabel cs:1}}]     at (xticklabel cs:1) {};


	\node[small dot,pin=180:{\texttt{yticklabel cs:0}}]     at (yticklabel cs:0) {};
	\node[small dot,pin=180:{\texttt{yticklabel cs:0.5}}]   at (yticklabel cs:0.5) {};
	\node[small dot,pin=180:{\texttt{yticklabel cs:1}}]     at (yticklabel cs:1) {};
\end{axis}
\end{tikzpicture}
\end{codeexample}

The basic idea is to place coordinates on a straight line which is parallel to the axis containing tick labels -- but shifted such that the line does not cut through tick labels.

Of course, it is relatively simple to get the same coordinates as in the two dimensional example above with \declaretext{axis description cs}, except that |ticklabel cs| always respects the tick label sizes appropriately. However, |ticklabel cs| becomes far superior when it comes to three dimensional positioning:

\begin{codeexample}[width=4cm]
% the same as above for 3D ...
\begin{tikzpicture}
	\tikzset{
		every pin/.style={fill=yellow!50!white,rectangle,rounded corners=3pt,font=\tiny},
		small dot/.style={fill=black,circle,scale=0.3}
	}
	\begin{axis}[
		ticklabel style={draw=red},
		clip=false,
		title=Positioning with \texttt{ticklabel cs} in 3D
	]
	\addplot3 coordinates {(-5,-5,-5) (5,5,5)};

	\node[small dot,pin=-90:{\texttt{xticklabel cs:0}}]     at (xticklabel cs:0) {};
	\node[small dot,pin=-90:{\texttt{xticklabel cs:0.5}}]   at (xticklabel cs:0.5) {};
	\node[small dot,pin=-90:{\texttt{xticklabel cs:1}}]     at (xticklabel cs:1) {};

	\node[small dot,pin=-45:{\texttt{yticklabel cs:0}}]     at (yticklabel cs:0) {};
	\node[small dot,pin=-45:{\texttt{yticklabel cs:0.5}}]   at (yticklabel cs:0.5) {};
	\node[small dot,pin=-45:{\texttt{yticklabel cs:1}}]     at (yticklabel cs:1) {};

	\node[small dot,pin=180:{\texttt{zticklabel cs:0}}]     at (zticklabel cs:0) {};
	\node[small dot,pin=180:{\texttt{zticklabel cs:0.5}}]   at (zticklabel cs:0.5) {};
	\node[small dot,pin=180:{\texttt{zticklabel cs:1}}]     at (zticklabel cs:1) {};
	\end{axis}
\end{tikzpicture}
\end{codeexample}

	The coordinate |ticklabel cs:0| is associated to the lower axis limit while |ticklabel cs:1| is near the upper axis limit.  The value |0.5| is in the middle of the axis, any other values (including negative values or values beyond $1$) are linearly interpolated inbetween.

	The |ticklabel cs| also accepts a second (optional) argument: a shift ``away'' from the tick labels. The shift points to a vector which is orthogonal to the associated axis, away from the tick labels. A shift of |0pt| is directly at the edge of the tick labels in direction of the normal vector, positive values move the position away and negative closer to the tick labels.
\begin{codeexample}[width=4cm]
\tikzset{
	every pin/.style={fill=yellow!50!white,rectangle,rounded corners=3pt,font=\tiny},
	small dot/.style={fill=black,circle,scale=0.3}
}
\begin{tikzpicture}
	\begin{axis}[
		xticklabel style={draw=red},
		clip=false,
		title=\texttt{ticklabel cs} and its optional shift
	]
	\addplot3 coordinates {(-5,-5,-5) (5,5,5)};

	\draw[blue,thick,->]      (xticklabel cs:0,0)     -- (xticklabel cs:1,0);
	\draw[red,thick,->]       (xticklabel cs:0,5pt)   -- (xticklabel cs:1,5pt);
	\draw[magenta,thick,->]   (xticklabel cs:0,10pt)  -- (xticklabel cs:1,10pt);
	\draw[green,thick,->]     (xticklabel cs:0,15pt)  -- (xticklabel cs:1,15pt);
	\node[small dot,pin=0:{\texttt{xticklabel cs:1,0}}]      at (xticklabel cs:1,0) {};
	\node[small dot,pin=0:{\texttt{xticklabel cs:1,15pt}}]   at (xticklabel cs:1,15pt) {};

	\draw[blue,thick,->]      (xticklabel cs:0,0)     -- (xticklabel cs:0,15pt);
	\draw[blue,thick,->]      (xticklabel cs:1,0)     -- (xticklabel cs:1,15pt);
	\end{axis}
\end{tikzpicture}
\end{codeexample}

	Whenever the |ticklabel cs| is used, the anchor should be set to \declaretext{anchor=near ticklabel} (see below).
\end{coordinatesystemlist}


Axis descriptions can also be placed using the predefined node \declaretext{current axis}. At the time when axis descriptions are drawn, all anchors which refer to the axis origin (that means the ``real'' point $(0,0)$) or any of the axis corners can be references using |current axis.|\meta{anchor name}. Please see section~\ref{pgfplots:sec:align}, Alignment, for further details.

\subsubsection{Alignment of Axis Descriptions}
This section describes how to modify the default alignment of axis descriptions. It can be skipped at first reading.

The two topics positioning and alignment always work together: \emph{positioning} means to select an appropriate coordinate and \emph{alignment} means to select an anchor inside of the description which will actually be moved to the desired position.

\Tikz\ uses many anchors to provide alignment; most of them are named like |north|, |north east| etc. These names hold for any axis description as well (as axis description are \Tikz\ nodes). Readers can learn details about this topic in the \Tikz\ manual~\cite{tikz} or some more advice in section~\ref{pgfplots:sec:align}.

When it comes to axis descriptions, \PGFPlots\ offers some specialized anchors and alignment methods which are described below.
\begin{anchorlist}{near xticklabel,near yticklabel,near zticklabel,near ticklabel}
	These anchors can be used to align at the part of an axis description which is nearest to the tick labels of a particular axis.

	These anchors are used for axis labels, especially for three dimensional axes.

	Maybe it is best to demonstrate it by example:
\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}[
		title=Without \texttt{near ticklabel},
		ylabel={$f(x)=x$},
		every axis y label/.style=
			{at={(ticklabel cs:0.5)},rotate=90,anchor=center},
		clip=false,% to display the \path below
		ylabel style={draw=red},
		yticklabel style={draw=red}
	]

		\addplot {x};

		% visualize the position:
		\fill (yticklabel cs:0.5) circle(2pt);
	\end{axis}
\end{tikzpicture}%
~
\begin{tikzpicture}
	\begin{axis}[
		title=With \texttt{near ticklabel},
		ylabel={$f(x)=x$},
		every axis y label/.style=
			{at={(ticklabel cs:0.5)},rotate=90,anchor=near ticklabel},
		clip=false,
		ylabel style={draw=red},
		yticklabel style={draw=red}
	]

		\addplot {x};
		\fill (yticklabel cs:0.5) circle(2pt);
	\end{axis}
\end{tikzpicture}
\end{codeexample}

	The motivation is to place nodes such that they are anchored next to the tick label, regardless of the node's rotation or the position of ticks. The special anchor |near ticklabel| is only available for axis labels (as they have a uniquely identified axis, either $x$, $y$ or $z$).

	In more detail, the anchor is placed such on the intersection of the node's shape with the outer normal vector of the tick label axis. This normal vector is the same which is used for the shift argument in |ticklabel cs|: it is orthogonal to the tick label axis. Furthermore, |near ticklabel| inverts the transformation matrix before it computes this intersection point.

	The |near ticklabel| anchor and its friends will be added temporarily to any shape used for an axis description.
\end{anchorlist}

\begin{pgfplotsxykeylist}{/tikz/sloped like \x\space axis}
	A key which replaces the rotational / scaling parts of the transformation matrix such that the node is sloped like the provided axis. For two dimensional plots, |sloped like y axis| is effectively the same as |rotate=90|. For a three dimensional axis, this will lead to a larger difference:
\pgfplotsexpensiveexample
\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}[
		xlabel=Variable 1,
		ylabel=Variable 2,
		zlabel=value,
		xlabel style={sloped like x axis},
		ylabel style={sloped}
	]

	\addplot3[surf] {y*x*(1-x)};
	\end{axis}
\end{tikzpicture}
\end{codeexample}

	Inside of axis labels, |sloped| is an alias |sloped like |\meta{char}| axis| with the correct \meta{char} chosen automatically.

	Please note that rotated text might not look very good (neither on screen nor printed).
\end{pgfplotsxykeylist}


\subsubsection{Labels}

\begin{pgfplotsxykey}{\x label=\marg{text}}
The options |xlabel| and |ylabel| change axis labels to \marg{text} which is any \TeX\ text. Use curly braces to include special characters, for example ``|xlabel={, = characters}|'' if characters like `|=|' or `|,|' need to be included literally.

Labels are \Tikz-Nodes which are placed with
\begin{codeexample}[code only]
% for x:
\node 
	[style=every axis label,
	style=every axis x label]

% for y:
\node 
	[style=every axis label,
	style=every axis y label] 
\end{codeexample}
so their position and appearance can be customized. 

The label placement has been modified in version 1.3, since the new \declaretext{ticklabel cs} allows to respect the size of adjacent tick label sizes. To maintain backwards compatibility, version 1.3 supports a new-feature switch and uses the same, sub-optimal initial settings as versions before 1.3:

\begin{pgfplotsxykeylist}{\x label near ticks,compat=newest}
	This setting uses the initial label configuration for two dimensional plots:
\begin{codeexample}[code only]
/pgfplots/xlabel near ticks/.style={
	/pgfplots/every axis x label/.style={at={(ticklabel cs:0.5)},anchor=near ticklabel}
},
/pgfplots/ylabel near ticks/.style={
	/pgfplots/every axis y label/.style={at={(ticklabel cs:0.5)},rotate=90,anchor=near ticklabel}
}
\end{codeexample}
	Use
\begin{codeexample}[code only]
\pgfplotsset{compat=newest}
\end{codeexample}
	\noindent in your preamble to install the styles document-wide.
\end{pgfplotsxykeylist}


Whenever possible, consider using |.append style| instead of overwriting the default styles to ensure compatibility with future versions.
\begin{codeexample}[code only]
\pgfplotsset{every axis label/.append style={...}}
\pgfplotsset{every axis x label/.append style={...}}
\pgfplotsset{every axis y label/.append style={...}}
\end{codeexample}
	Use |xlabel/.add=|\marg{prefix}\marg{suffix} to modify an already assigned label.
\end{pgfplotsxykey}

\begin{pgfplotskey}{title=\marg{text}}
Adds a caption to the plot. This will place a \Tikz-Node with
\begin{codeexample}[code only]
\node[style=every axis title] {text};
\end{codeexample}
to the current axis.
\begin{codeexample}[]
\begin{tikzpicture}
\begin{loglogaxis}[
	xlabel=Dof,ylabel=Error,
	title={$\mu=0.1$, $\sigma=0.2$}]

	\addplot coordinates {
		(5,    8.312e-02)
		(17,   2.547e-02)
		(49,   7.407e-03)
		(129,  2.102e-03)
		(321,  5.874e-04)
		(769,  1.623e-04)
		(1793, 4.442e-05)
		(4097, 1.207e-05)
		(9217, 3.261e-06)
	};
\end{loglogaxis}
\end{tikzpicture}%
\end{codeexample}
%--------------------------------------------------
% \hfill
% \begin{tikzpicture}
% \begin{loglogaxis}[
% 	width=0.48\linewidth,
% 	xlabel=Dof,ylabel=Error,
% 	title={$\mu=1$, $\sigma=\frac{1}{2}$}]
% 
% 	\addplot[color=red,mark=*] coordinates {
% 		(7,		8.472e-02)
% 		(31,	3.044e-02)
% 		(111,	1.022e-02)
% 		(351,	3.303e-03)
% 		(1023,	1.039e-03)
% 		(2815,	3.196e-04)
% 		(7423,	9.658e-05)
% 		(18943,	2.873e-05)
% 		(47103,	8.437e-06)
% 	};
% \end{loglogaxis}
% \end{tikzpicture}
%-------------------------------------------------- 
The title's appearance and/or placing can be reconfigured with
\begin{codeexample}[code only]
\pgfplotsset{every axis title/.append style={at={(0.75,1)}}}
\end{codeexample}
This will place the title at~75\% of the $x$-axis. The coordinate~$(0,0)$ is the lower left corner and~$(1,1)$ the upper right one.

Use |title/.add=|\marg{prefix}\marg{suffix} to modify an already assigned title.
\end{pgfplotskey}

\begin{pgfplotscodekey}{extra description}
Allows to insert \marg{commands} after axis labels, titles and legends have been typeset.

As all other axis descriptions, the code can use $(0,0)$ to access the lower left corner and $(1,1)$ to access the upper right one. It won't be clipped.
\begin{codeexample}[]
\pgfplotsset{every axis/.append style={
	extra description/.code={
		\node at (0.5,0.5) {Center!};
	}}}
\begin{tikzpicture}
	\begin{axis}
	\addplot {x^2};
	\end{axis}
\end{tikzpicture}
\end{codeexample}
\end{pgfplotscodekey}


\subsubsection{Legends}
\label{pgfplots:sec:legendopts}
\label{pgfplots:sec:legendcmds}
Legends can be generated in two ways: the first is to use |\addlegendentry| or |\legend| inside of an axis. This method has been presented in section~\ref{pgfplots:sec:legendcmds}, Legend Commands. The other method is to use a key.


\begin{command}{\addlegendentry\marg{name}}
Adds a single legend entry to the legend list. This will also enable legend drawing.
\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}
\addplot[smooth,mark=*,blue] coordinates {
	(0,2)
	(2,3)
	(3,1)
};
\addlegendentry{Case 1}

\addplot[smooth,color=red,mark=x]
	coordinates {
		(0,0)
		(1,1)
		(2,1)
		(3,2)
	};
\addlegendentry{Case 2}
\end{axis}
\end{tikzpicture}
\end{codeexample}
It does not matter where |\addlegendentry| commands are placed, only the sequence matters. You will need one |\addlegendentry| for every |\addplot| command.


Optional argument are accepted with|\addlegendentry|\oarg{key-value-list}|{...}|. This does mainly affect some keys affecting the legend layout, support is very limited.

Using |\addlegendentry| disables the key |legend entries|.
\end{command}



\begin{command}{\legend\marg{list}}
\label{sec:legenddef}%
You can use |\legend|\marg{list} to assign a complete legend.
\begin{codeexample}[code only]
\legend{$d=2$,$d=3$,$d=4$,$d=5$,$d=6$}
\end{codeexample}
The argument of |\legend| is a comma--separated list of entries, one for each plot. It is processed using the \PGF-foreach command\footnote{Older versions of \PGFPlots\ used \texttt{\textbackslash legend\{first\textbackslash\textbackslash second\textbackslash\textbackslash third\textbackslash\textbackslash\}} instead of comma--separated lists. This syntax is still accepted.}.
The short marker/line combination shown in legends is acquired from the \marg{style options} argument of |\addplot|.

Using |\legend| overwrites any other existing legend entries.
\end{command}


\begin{pgfplotskey}{legend entries=\marg{comma separated list}}
	This key can be used to assign legend entries just like the commands |\addlegendentry| and |\legend|. Again, the positioning is relative to the axis rectangle (unless units like |cm| or |pt| are specified explicitly).
\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}[legend entries={$x$,$x^2$}]
	\addplot {x};
	\addplot {x^2};
	\end{axis}
\end{tikzpicture}
\end{codeexample}

	The commands for legend creation take precedence: the key is only considered if there is no legend command in the current axis. Please refer to section~\ref{pgfplots:sec:legendcmds}, Legend Commands, for details about the commands.	
\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}[legend entries={$x$,$x^2$}]
	\addplot {x};
	\addplot {x^2};
	\legend{$a$,$b$}% overrides the option
	\end{axis}
\end{tikzpicture}
\end{codeexample}
	Please be careful with whitespaces in \marg{comma separated list}: they will contribute to legend entries. Consider using `|%|' at the end of each line in multiline arguments (the end of line character is also a whitespace in \TeX).
\end{pgfplotskey}


\subsubsection{Legend Appearance}

{%
\pgfplotsset{every axis/.append style={width=3cm,scale only axis,legend style={font=\footnotesize}}}%


\begin{stylekey}{/pgfplots/every axis legend}
The style ``|every axis legend|'' determines the legend's position and outer appearance:
\begin{codeexample}[code only]
\pgfplotsset{every axis legend/.append style={
		at={(0,0)},
		anchor=south west}}
\end{codeexample}
will draw it at the lower left corner of the axis while
\begin{codeexample}[code only]
\pgfplotsset{every axis legend/.append style={
		at={(1,1)},
		anchor=north east}}
\end{codeexample}
means the upper right corner. The `|anchor|' option determines which point \emph{of the legend} will be placed at $(0,0)$ or $(1,1)$.

The legend is a \Tikz-matrix, so one can use any \Tikz\ option which affects
nodes and matrizes (see~\cite[section 13~and~14]{tikz}). The matrix is created by something like
\begin{codeexample}[code only]
\matrix[style=every axis legend] {
	draw plot specification 1 & \node{legend 1}\\
	draw plot specification 2 & \node{legend 2}\\
	...
};
\end{codeexample}

\begin{codeexample}[]
\pgfplotsset{every axis legend/.append style={
		at={(1.02,1)},
		anchor=north west}}
\begin{tikzpicture}
\begin{axis}
\addplot coordinates {(0,0) (1,1)};
\addplot coordinates {(0,1) (1,2)};
\addplot coordinates {(0,2) (1,3)};
\legend{$l_1$,$l_2$,$l_3$}
\end{axis}
\end{tikzpicture}
\end{codeexample}

Use |legend columns=|\marg{number} to configure the number of horizontal legend entries.
\begin{codeexample}[]
\begin{tikzpicture}
\pgfplotsset{every axis legend/.append style={
		at={(0.5,1.03)},
		anchor=south}}
\begin{axis}[legend columns=4]
\addplot coordinates {(0,0) (1,1)};
\addplot coordinates {(0,1) (1,2)};
\addplot coordinates {(0,2) (1,3)};
\legend{$l_1$,$l_2$,$l_3$}
\end{axis}
\end{tikzpicture}
\end{codeexample}
\noindent
Instead of the |.append style|, it is possible to use |legend style| as in the following example. It has the same effect.

\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[
	legend style={
		at={(1,0.5)},
		anchor=east}]
\addplot coordinates {(0,0) (1,1)};
\addplot coordinates {(0,1) (1,2)};
\addplot coordinates {(0,2) (1,3)};
\legend{$l_1$,$l_2$,$l_3$}
\end{axis}
\end{tikzpicture}
\end{codeexample}

\noindent
The default |every axis legend| style is
\begin{codeexample}[code only]
\pgfplotsset{every axis legend/.style={%
	cells={anchor=center},% Centered entries
	inner xsep=3pt,inner ysep=2pt,nodes={inner sep=2pt,text depth=0.15em},
	anchor=north east,%
	shape=rectangle,%
	fill=white,%
	draw=black,
	at={(0.98,0.98)}
}}
\end{codeexample}
Whenever possible, consider using |.append style| to keep the default styles active. This ensures compatibility with future versions.
\begin{codeexample}[code only]
\pgfplotsset{every axis legend/.append style={...}}
\end{codeexample}
\end{stylekey}

\pgfplotsshortstylekey legend style=every axis legend\pgfeov


\begin{pgfplotskey}{legend pos=\mchoice{south west,south east,north west,north east,outer north east}}
	A style which provides shorthand access to some commonly used legend positions.

	Each of these styles appends |at={(|\meta{x}|,|\meta{y}|)},anchor=|\meta{name} values to |every axis legend|.

\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[legend pos=south west]
\addplot coordinates {(0,0) (1,1)};
\addplot coordinates {(0,1) (1,2)};
\addplot coordinates {(0,2) (1,3)};
\legend{$l_1$,$l_2$,$l_3$}
\end{axis}
\end{tikzpicture}
\end{codeexample}

\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[legend pos=south east]
\addplot coordinates {(0,0) (1,1)};
\addplot coordinates {(0,1) (1,2)};
\addplot coordinates {(0,2) (1,3)};
\legend{$l_1$,$l_2$,$l_3$}
\end{axis}
\end{tikzpicture}
\end{codeexample}

\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[legend pos=north east]
\addplot coordinates {(0,0) (1,1)};
\addplot coordinates {(0,1) (1,2)};
\addplot coordinates {(0,2) (1,3)};
\legend{$l_1$,$l_2$,$l_3$}
\end{axis}
\end{tikzpicture}
\end{codeexample}

\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[legend pos=north west]
\addplot coordinates {(0,0) (1,1)};
\addplot coordinates {(0,1) (1,2)};
\addplot coordinates {(0,2) (1,3)};
\legend{$l_1$,$l_2$,$l_3$}
\end{axis}
\end{tikzpicture}
\end{codeexample}

\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[legend pos=outer north east]
\addplot coordinates {(0,0) (1,1)};
\addplot coordinates {(0,1) (1,2)};
\addplot coordinates {(0,2) (1,3)};
\legend{$l_1$,$l_2$,$l_3$}
\end{axis}
\end{tikzpicture}
\end{codeexample}
\end{pgfplotskey}

}

\begin{pgfplotskey}{legend columns=\marg{number} (default 1)}
Allows to configure the maximum number of adjacent legend entries. The default value~|1| places legend entries vertically below each other. 

Use |legend columns=-1| to draw all entries horizontally.
\end{pgfplotskey}

\begin{pgfplotskey}{legend plot pos=\mchoice{left,right,none} (initially left)}
Configures where the small line specifications will be drawn: left of the description, right of the description or not at all.
\end{pgfplotskey}

\begin{pgfplotscodekey}{legend image code}
\label{opt:legend:image:code}
Allows to replace the default images which are drawn inside of legends. The first argument\footnote{As of version 1.3, this is no longer true -- now, the argument is empty and the plot specification is set \emph{before} \texttt{legend image code} is evaluated. This allows plot styles to change legend drawing commands.} to this option is the plot specification, a key-value list which has been determined by |\addplot|.

The default is
\begin{codeexample}[code only]
/pgfplots/legend image code/.code={%
	\draw[#1,mark repeat=2,mark phase=2] 
		plot coordinates {
			(0cm,0cm) 
			(0.3cm,0cm)
			(0.6cm,0cm)%
		};%
}
\end{codeexample}
\end{pgfplotscodekey}

\begin{pgfplotskey}{reverse legend=\mchoice{true,false} (initially false)}
	Allows to reverse the order in which the pairs (legend entry, plot style) are drawn.
\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}[reverse legend]
	\addplot {x};
	\addlegendentry{$x$}
	\addplot {x^2};
	\addlegendentry{$x^2$}
	\addplot {x^3};
	\addlegendentry{$x^3$}
	\end{axis}
\end{tikzpicture}
\end{codeexample}
\end{pgfplotskey}

\begin{stylekey}{/pgfplots/area legend}
	A style which sets |legend image code| to
\begin{codeexample}[code only]
\pgfplotsset{
	/pgfplots/legend image code/.code={%
		\draw[#1] (0cm,-0.1cm) rectangle (0.6cm,0.1cm);
	}}	
\end{codeexample}
	
% \usetikzlibrary{patterns}
\begin{codeexample}[]
% \usetikzlibrary{patterns}
\begin{tikzpicture}
\begin{axis}[area legend,
	axis x line=bottom,
	axis y line=left,
	domain=0:1,
	legend style={at={(0.03,0.97)},
		anchor=north west},
	axis on top,xmin=0]
\addplot[pattern=crosshatch dots,
	pattern color=blue,draw=blue]
expression[samples=500] 
	{sqrt(x)}	\closedcycle;

\addplot[pattern=crosshatch,
	pattern color=blue!30!white,
	draw=blue!30!white]
expression {x^2} \closedcycle;

\addplot[red] coordinates {(0,0) (1,1)};
\legend{$\sqrt x$,$x^2$,$x$}
\end{axis}
\end{tikzpicture}
\end{codeexample}
\end{stylekey}

\subsubsection{Legends with \texttt{\textbackslash label} and \texttt{\textbackslash ref}}
\label{pgfplots:legend:labelref}
\PGFPlots\ offers a |\label| and |\ref| feature for \LaTeX\ to assemble a legend manually, for example as part of the figure caption. These references work as usual \LaTeX\ references: a |\label| remembers where and what needs to be referenced and a |\ref| expands to proper text. In context of plots, a |\label| remembers the plot specification of one plot and a |\ref| expands to the small image which would also be used inside of legends.
\begin{codeexample}[]
\begin{tikzpicture}[baseline]
\begin{axis}
	\addplot+[only marks] 
		expression[samples=15,
			error bars/y dir=both,
			error bars/y fixed=2.5]
		{3*x+2.5*rand};
	\label{pgfplots:label1}

	\addplot+[mark=none] {3*x};
	\label{pgfplots:label2}

	\addplot {4*cos(deg(x))};
	\label{pgfplots:label3}
\end{axis}
\end{tikzpicture}
\end{codeexample}
\begin{codeexample}[code only]
The picture shows the estimations \ref{pgfplots:label1} which are subjected to noise.
It appears the model \ref{pgfplots:label2} fits the data appropriately. 
Finally, \ref{pgfplots:label3} is only here to get three examples.
\end{codeexample}
\noindent The picture shows the estimations \ref{pgfplots:label1} which are subjected to noise.
It appears the model \ref{pgfplots:label2} fits the data appropriately. 
Finally, \ref{pgfplots:label3} is only here to get three examples.

\begin{command}{\label\marg{label name}}
	When used after |\addplot|, this command creates a \LaTeX\ label named \marg{label name}\footnote{This feature is \emph{only} available in \LaTeX, sorry.}. If this label is cross-referenced with |\ref|\marg{label name} somewhere, the associated plot specification will be inserted.
\begin{codeexample}[]
Label3 = \ref{pgfplots:label3}; 
Label2 = \ref{pgfplots:label2}
\end{codeexample}
	The label is assembled using |legend image code| and the plot style of the last plot. Any \PGFPlots\ option is expanded until only \Tikz\ (or \pgfname) options remain; these options are used to get an independant label\footnote{Please note that you can't use the label/ref mechanism in conjunction with image externalization as this will (naturally) lead to undefined references.}.

	More precisely, the small image generated by |\ref|\marg{label name} is 
\begin{codeexample}[code only]
\tikz[/pgfplots/every crossref picture] {...}
\end{codeexample}
	\noindent where the contents is determined by |legend image code| and the plot style.
\end{command}

\begin{command}{\ref\marg{label name}}
	Can be used to reference a labeled, single plot. See the example above.

	This will also work together with |hyperref| links and |\pageref|\footnote{Older versions of \PGFPlots\ required the use of \texttt{\textbackslash protect\textbackslash ref} when used inside of captions or section headings. This is no longer necessary.}.
\end{command}

\begin{key}{/pgfplots/refstyle=\marg{label name}}
	Can be used to set the \emph{styles} of a labeled, single plot. This allows to write
\begin{codeexample}[code only]
\addplot[/pgfplots/refstyle={pgfplots:label2}]
\end{codeexample}
	\noindent somewhere. Please note that it may be easier to define a style with |.style|.
\end{key}

\begin{stylekey}{/pgfplots/every crossref picture}
	A style which will be used by the cross-referencing feature for plots. The default is
\begin{codeexample}[code only]
\pgfplotsset{every crossref picture/.style={baseline,yshift=0.3em}}
\end{codeexample}
\end{stylekey}

\subsubsection{Axis Lines}
By default the axis lines are drawn as a |box|, but it is possible to change the appearance of the $x$~and~$y$ axis lines.

\begin{pgfplotskeylist}{
	axis x line=\mchoice{box,top,middle,center,bottom,none} (initially box),
	axis x line*=\mchoice{box,top,middle,center,bottom,none} (initially box),
	axis y line=\mchoice{box,left,middle,center,right,none} (initially box),
	axis y line*=\mchoice{box,left,middle,center,right,none} (initially box)}
Allows to choose the location of the axis line(s). Ticks and tick labels are placed accordingly.
The choice |bottom| will draw the $x$ line at $y=y_\text{min}$, |middle| will draw the $x$~line at $y=0$, and |top| will draw it at $y=y_\text{max}$. Finally, |box| is a combination of options |top| and |bottom|. The $y$~variant works similarly.

The case |center| is a synonym for |middle|, both draw the line through the respective coordinate~$0$. If this coordinate is not part of the axis limit, the lower axis limit is chosen instead.

The starred versions $\dotsc$|line*| \emph{only} affect the axis lines, without correcting the positions of axis labels, tick lines or other keys which are (possibly) affected by a changed axis line. The non-starred versions are actually styles which set the starred key \emph{and} some other keys which also affect the figure layout:
\begin{itemize}
	\item In case |axis x line=box|, the style |every boxed x axis| will be installed immediately.
	\item In case |axis x line|$\neq$|box|, the style |every non boxed x axis| will be installed immediately. Furthermore, axis labels positions will be adjusted to fit the choosen value.
\end{itemize}
The same holds true for the |y|-variants. The default styles are defined as
\begin{codeexample}[code only]
\pgfplotsset{
	/pgfplots/every non boxed x axis/.style={
		xtick align=center,
		enlarge x limits=false,
		x axis line style={-stealth}
	},
	/pgfplots/every boxed x axis/.style={}
}
\end{codeexample}
Feel free to overwrite these styles if the default doesn't fit your needs or taste. 

\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[
	xlabel=$x$,ylabel=$\sin x$]

	\addplot[blue,mark=none] 
		expression[domain=-10:0,samples=40]
		{sin(deg(x))};
\end{axis}
\end{tikzpicture}
\end{codeexample}

\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[
	axis x line=middle,
	axis y line=right,
	ymax=1.1, ymin=-1.1,
	xlabel=$x$,ylabel=$\sin x$
]
	\addplot[blue,mark=none] 
		expression[domain=-10:0,samples=40]
		{sin(deg(x))};
\end{axis}
\end{tikzpicture}
\end{codeexample}


\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[
	axis x line=bottom,
	axis y line=left,
	xlabel=$x$,ylabel=$\sqrt{|x|}$
]
\addplot[blue,mark=none] 
	expression[domain=-4:4,samples=501]
	{sqrt(abs(x))};
\end{axis}
\end{tikzpicture}
\end{codeexample}

\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[
	minor tick num=3,
	axis y line=center,
	axis x line=middle,
	xlabel=$x$,ylabel=$\sin x$
	]
	\addplot[smooth,blue,mark=none] 
		[domain=-5:5,samples=40] 
		{sin(deg(x))};
\end{axis}
\end{tikzpicture}
\end{codeexample}

\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[
	minor tick num=3,
	axis y line=left,
	axis x line=middle,
	xlabel=$x$,ylabel=$\sin x$
	]
	\addplot[smooth,blue,mark=none] 
		[domain=-5:5,samples=40] 
		{sin(deg(x))};
\end{axis}
\end{tikzpicture}
\end{codeexample}

In case |middle|, the style |every inner axis x line| allows to adjust the appearenace.
\end{pgfplotskeylist}

\begin{pgfplotsxykey}{every inner \x\ axis line}
	A style key which can be redefined to customize the appearance of \emph{inner} axis lines. Inner axis lines are those drawn by the |middle| (or |center|) choice of |axis x line|, see above.

	This style affects \emph{only} the line as such.
\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[
	minor tick num=1,
	axis x line=middle,
	axis y line=middle,
	every inner x axis line/.append style=
		{|->>},
	every inner y axis line/.append style=
		{|->>},
	xlabel=$x$,ylabel=$y^3$
]
\addplot[blue] expression[domain=-3:5] {x^3};
\end{axis}
\end{tikzpicture}
\end{codeexample}
\end{pgfplotsxykey}

\begin{pgfplotsxykey}{every outer \x\ axis line}
	Similar to |every inner x axis line|, this style configures the appearance of all axis lines which are part of the outer box.
\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[
	separate axis lines, % important !
	every outer x axis line/.append style=
		{-stealth},
	every outer y axis line/.append style=
		{-stealth},
]
\addplot[blue] plot[id=DoG,
		samples=100,
		domain=-15:15] 
  gnuplot{1.3*exp(-x**2/10) - exp(-x**2/20)};
\end{axis}
\end{tikzpicture}
\end{codeexample}
\end{pgfplotsxykey}

\begin{pgfplotskey}{separate axis lines=\marg{true,false} (default true)}
	Enables or disables separate path commands for every axis line. This option affects \emph{only} the case if axis lines are drawn as a \emph{box}.

	Both cases have their advantages and disadvantages, I fear there is no reasonable default (suggestions are welcome).

	The case |separate axis lines=true| allows to draw arrow heads on each single axis line, but it can't close edges very well -- in case of thick lines, unsatisfactory edges occur.
\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[
	separate axis lines,
	every outer x axis line/.append style=
		{-stealth,red},
	every outer y axis line/.append style=
		{-stealth,green!30!black},
]
\addplot[blue]
	expression[
		samples=100,
		domain=-15:15] 
	{1.3*exp(0-x^2/10) - exp(0-x^2/20)};
  % Unfortunately, there is a bug in PGF 2.00
  % something like exp(-10^2)
  % must be written as exp(0-10^2) :-(
\end{axis}
\end{tikzpicture}
\end{codeexample}

	The case |separate axis lines=false| issues just \emph{one} path for all axis lines. It draws a kind of rectangle, where some parts of the rectangle may be skipped over if they are not wanted. The advantage is that edges are closed properly. The disadvantage is that at most one arrow head is added to the path (and yes, only one drawing color is possible).
\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[
	separate axis lines=false,
	every outer x axis line/.append style=
		{-stealth,red},
	every outer y axis line/.append style=
		{-stealth,green!30!black},
]
\addplot[blue] plot[id=DoG,
		samples=100,
		domain=-15:15] 
  gnuplot{1.3*exp(-x**2/10) - exp(-x**2/20)};
\end{axis}
\end{tikzpicture}
\end{codeexample}
\end{pgfplotskey}


\label{pgfplots:page:axislines}
\begin{pgfplotskey}{axis line style=\marg{key-value-list}}
	A command which appends \marg{key-value-list} to \emph{all} axis line appearance styles.
\end{pgfplotskey}

\begin{pgfplotskey}{inner axis line style=\marg{key-value-list}}
	A command which appends \marg{key-value-list} to both, |every inner x axis line| and the $y$ variant.
\end{pgfplotskey}
\begin{pgfplotskey}{outer axis line style=\marg{key-value-list}}
	A command which appends \marg{key-value-list} to both, |every outer x axis line| and the $y$ variant.
\end{pgfplotskey}
\begin{pgfplotsxykey}{\x\ axis line style=\marg{key-value-list}}
	A command which appends \marg{key-value-list} to all axis lines styles for either $x$ or $y$ axis.
\end{pgfplotsxykey}

\begin{pgfplotsxykey}{every boxed \x\ axis}
	A style which will be installed as soon as |axis x line=box| (|y|) is set.

	The default is simply empty.
\end{pgfplotsxykey}
\begin{pgfplotsxykey}{every non boxed \x\ axis}
	A style which will be installed as soon as |axis x line| (|y|) will be set to something different than |box|. 
	
	The default is 
\begin{codeexample}[code only]
\pgfplotsset{
	/pgfplots/every non boxed x axis/.style={
		xtick align=center,
		enlarge x limits=false,
		x axis line style={-stealth}}}
\end{codeexample}
	\noindent with similar values for the |y|-variant. Feel free to redefine this style to your needs / taste.
\end{pgfplotsxykey}

\subsubsection[Two Ordinates]{Two Ordinates ($y$ axis)}
{%
\pgfplotsset{every axis/.append style={width=4.5cm}}%
In some applications, more than one $y$ axis is used if the $x$ range is the same. This section demonstrates how to create them.

\begin{codeexample}[]
\begin{tikzpicture}
  \begin{axis}[
    scale only axis,
    xmin=-5,xmax=5,
    axis y line=left,
    xlabel=$x$,
    ylabel=First ordinate]
  \addplot {x^2};
  \end{axis}
  
  \begin{axis}[
    scale only axis,
    xmin=-5,xmax=5,
    axis y line=right,
    axis x line=none,
    ylabel=Second ordinate]
  \addplot[red] {3*x};
  \end{axis}
\end{tikzpicture}
\end{codeexample}
\noindent The basic idea is to draw two axis ``on top'' of each other -- one, which contains the $x$ axis and the left $y$ axis, and one which has \emph{only} the right $y$ axis. Since \PGFPlots\ does not really know what it's doing here, user attention in the following possibly non-obvious aspects is required:
\begin{enumerate}
	\item Scaling. You should set |scale only axis| because this forces equal dimensions for both axis, without respecting any labels.
	\item Same $x$ limits. You should set those limits explicitly.
\end{enumerate}
You may want to consider different legend styles.
It is also possible to use only the axis, without any plots:
% \usepackage{textcomp}
\begin{codeexample}[]
% \usepackage{textcomp}
\begin{tikzpicture}
  \begin{axis}[
    scale only axis,
    xmin=-5,xmax=5,
    axis y line=left,
    xlabel=$x$,
    ylabel=Absolute]
  \addplot {x^2};
  \end{axis}
  
  \begin{axis}[
    scale only axis,
    xmin=-5,xmax=5,
    ymin=0,ymax=1000,
    yticklabel=
{$\pgfmathprintnumber{\tick}$\textperthousand},
    axis y line=right,
    axis x line=none,
    y label style={yshift=-10pt},
    ylabel=per thousand]
  \end{axis}
\end{tikzpicture}
\end{codeexample}
}

\subsubsection{Axis Discontinuities}
In case the range of either of the axis do not include the zero value, it is possible to visualize this with a discontinuity decoration on the corresponding axis line.

\begin{pgfplotsxykey}{axis \x\ discontinuity=\mchoice{crunch,parallel,none} (initially none)}
Insert a discontinuity decoration on the $x$ (or $y$, respectively) axis. 
This is to visualize that the $y$ axis does cross the $x$ axis at its $0$ value, because the minimum $x$ axis value is positive or the maximum value is negative.

The description applies |axis y discontinuity| as well, with interchanged meanings of $x$~and~$y$.

\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[
	axis x line=bottom,
	axis x discontinuity=parallel,
	axis y line=left,
	xmin=360, xmax=600,
	ymin=0, ymax=7,
 	enlargelimits=false
]
	\addplot coordinates {
		(420,2)
		(500,6)
		(590,4)
	};
\end{axis}
\end{tikzpicture}
\end{codeexample}

\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[
	axis x line=bottom,
	axis y line=center,
	tick align=outside,
	axis y discontinuity=crunch,
	ymin=95, enlargelimits=false
]
	\addplot[blue,mark=none] 
		expression[domain=-4:4,samples=20] 
		{x*x+x+104};
\end{axis}
\end{tikzpicture}
\end{codeexample}
\end{pgfplotsxykey}

A problem might occur with the placement of the ticks on the axis.
This can be solved by specifying the minimum or maximum axis value for which a tick will be placed.

\begin{pgfplotsxykeylist}{\x tickmin=\marg{coord} (default axis limits), \x tickmax=\marg{coord} (default axis limits)}
\label{key:xytickminmax}
The options |xtickmin|, |xtickmax| and |ytickmin|, |ytickmax| allow to define the axis tick limits, i.e.\ the axis values before respectively after no ticks will be placed.
Everything outside of the axis tick limits will be not drawn.
Their default values are equal to the axis limits.

\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[
	axis x line=bottom,
	axis y line=center,
	tick align=outside,
	axis y discontinuity=crunch,
	xtickmax=3,
	ytickmin=110,
	ymin=95, enlargelimits=false
]
	\addplot[blue,mark=none] 
		plot[domain=-4:4,samples=20] 
		expression{x*x+x+104};
\end{axis}
\end{tikzpicture}
\end{codeexample}
\end{pgfplotsxykeylist}

\begin{pgfplotsxykey}{hide \x\ axis=\mchoice{true,false} (initially false)}
Allows to hide either the $x$ or the $y$ axis. No outer rectangle, no tick marks and no labels will be drawn. Only titles and legends will be processed as usual.

Axis scaling and clipping will be done as if you did not use |hide x axis|.
\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}[
		hide x axis,
		hide y axis,
		title={$x^2\cos(x)$}]
	\addplot {cos(x)*x^2};
	\end{axis}
\end{tikzpicture}
\end{codeexample}

\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}[
		hide x axis,
		axis y line=left,
		title={$x^2\cos(x)$}]
	\addplot {cos(x)*x^2};
	\end{axis}
\end{tikzpicture}
\end{codeexample}
\end{pgfplotsxykey}

\begin{stylekey}{/pgfplots/hide axis=\mchoice{true,false} (default true)}
	A style which sets both, |hide x axis| and |hide y axis|.
\end{stylekey}

\subsubsection{Color Bars}
\label{pgfplots:colorbar}
\PGFPlots\ supports mesh, surface and scatter plots which can use color maps. While color maps can be chosen as described in section~\ref{pgfplots:colormap}, they can be visualized using color bars.

\begin{pgfplotskey}{colorbar=\mchoice{true,false} (initially false)}
	Activates or deactivates color bars.

\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}[colorbar]
		\addplot[mesh,ultra thick] {x};
	\end{axis}
\end{tikzpicture}
\end{codeexample}

\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}[colorbar,colormap/greenyellow]
		\addplot[mesh,ultra thick] {x};
	\end{axis}
\end{tikzpicture}
\end{codeexample}

\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}[colorbar horizontal]
		\addplot[mesh,ultra thick] {x};
	\end{axis}
\end{tikzpicture}
\end{codeexample}
	
	A color bar is only useful for plots which actually use color data -- that is, the special data which is called ``point meta'' in \PGFPlots\ (see section~\ref{pgfplots:point:meta}). Activating color bars for a plot without color map results in an empty color bar.

	Color bars are just normal axes which are placed right besides their parent axes. The only difference is that they inherit several styles such as line width and fonts and they contain a bar shaded with the color map of the current axis.
	
	Color bars are drawn with
\begin{codeexample}[code only]
\axis[every colorbar,colorbar shift,colorbar=false]
	\addplot graphics {};
\endaxis
\end{codeexample}
	\noindent where the placement, alignment, appearance and other options are done by the two styles \declaretext{every colorbar} and \declaretext{colorbar shift}. These styles and the possible placement and alignment options are described below.

	\paragraph{Remarks for special cases:}
	\begin{itemize}
		\item Since there is always only one color bar per plot, this color bar uses the axis wide configurations of color map and color data.
		\item If someone needs more than one color bar, the draw command above needs to be updated. See the key 
		\declaretext{colorbar/draw/.code} for this special case.
	\end{itemize}
\end{pgfplotskey}

\begin{stylekey}{/pgfplots/colorbar right}
	A style which defines |every colorbar| and |colorbar shift| such that color bars are placed right of their parent axis.

	This is the initial configuration.
\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}[colorbar right]
	\addplot[mesh,thick,samples=150,domain=0.1:3] 
		{1/x};
	\end{axis}
\end{tikzpicture}
\end{codeexample}
	
	The style |colorbar right| is defined to be
\begin{codeexample}[code only]
/pgfplots/colorbar right/.style={%
	/pgfplots/colorbar=true,
	/pgfplots/colorbar shift/.style={xshift=0.3cm},
	/pgfplots/every colorbar/.style={%
		title=,
		xlabel=,
		ylabel=,
		zlabel=,
		legend entries=,
		axis on top,
		at={(parent axis.right of north east)},
		anchor=north west,
		xmin=0,
		xmax=1,
		ymin=\pgfkeysvalueof{/pgfplots/point meta min},
		ymax=\pgfkeysvalueof{/pgfplots/point meta max},
		plot graphics/xmin=0,%
		plot graphics/xmax=1,
		plot graphics/ymin=\pgfkeysvalueof{/pgfplots/point meta min},
		plot graphics/ymax=\pgfkeysvalueof{/pgfplots/point meta max},
		enlargelimits=false,
		scale only axis,
		height=\pgfkeysvalueof{/pgfplots/parent axis height},%
		x=\pgfkeysvalueof{/pgfplots/colorbar/width},
		yticklabel pos=right,
		xtick=\empty,
		colorbar vertical/lowlevel,
	}%
},%
/pgfplots/colorbar vertical/lowlevel/.style={%
	plot graphics/lowlevel draw/.code 2 args={%
		\pgfplotscolormaptoshadingspec{\pgfkeysvalueof{/pgfplots/colormap name}}{##2}\pgfplots@loc@TMPa
		\def\pgfplots@loc@TMPb{%
			\pgfdeclareverticalshading{tempshading}{\pgfkeysvalueof{/pgfplots/colorbar/width}}}%
		\expandafter\pgfplots@loc@TMPb\expandafter{\pgfplots@loc@TMPa}%
		\pgfuseshading{tempshading}%
	},%
},
\end{codeexample}
\end{stylekey}

\begin{stylekey}{/pgfplots/colorbar left}
	A style which defines |every colorbar| and |colorbar shift| such that color bars are placed left of their parent axis.
\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}[colorbar left]
	\addplot[mesh,thick,samples=150] 
		{x*sin(deg(4*x))};
	\end{axis}
\end{tikzpicture}
\end{codeexample}
	
	The style |colorbar left| is defined to be
\begin{codeexample}[code only]
/pgfplots/colorbar left/.style={%
	/pgfplots/colorbar right,
	/pgfplots/colorbar shift/.style={xshift=-0.3cm},
	/pgfplots/every colorbar/.append style={%
		at={(parent axis.left of north west)},
		anchor=north east,
		yticklabel pos=left,
	}%
}%
\end{codeexample}
\end{stylekey}

\begin{stylekey}{/pgfplots/colorbar horizontal}
	A style which defines |every colorbar| and |colorbar shift| such that color bars are placed below their parent axis, with a horizontal bar.
\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}[colorbar horizontal]
	\addplot[only marks,scatter,
		scatter src={mod(\coordindex,15)},samples=150] 
		{rand};
	\end{axis}
\end{tikzpicture}
\end{codeexample}

	This style is defined to be
\begin{codeexample}[code only]
/pgfplots/colorbar horizontal/.style={%
	/pgfplots/colorbar=true,
	/pgfplots/colorbar shift/.style={yshift=-0.3cm},
	/pgfplots/every colorbar/.style={%
		title=,
		xlabel=,
		ylabel=,
		zlabel=,
		legend entries=,
		axis on top,
		at={(parent axis.below south west)},
		anchor=north west,
		ymin=0,
		ymax=1,
		xmin=\pgfkeysvalueof{/pgfplots/point meta min},
		xmax=\pgfkeysvalueof{/pgfplots/point meta max},
		plot graphics/ymin=0,%
		plot graphics/ymax=1,
		plot graphics/xmin=\pgfkeysvalueof{/pgfplots/point meta min},
		plot graphics/xmax=\pgfkeysvalueof{/pgfplots/point meta max},
		enlargelimits=false,
		scale only axis,
		width=\pgfkeysvalueof{/pgfplots/parent axis width},%
		y=\pgfkeysvalueof{/pgfplots/colorbar/width},
		xticklabel pos=left,
		ytick=\empty,
		colorbar horizontal/lowlevel,
	}%
},%
/pgfplots/colorbar horizontal/lowlevel/.style={%
	plot graphics/lowlevel draw/.code 2 args={%
		\pgfplotscolormaptoshadingspec{\pgfkeysvalueof{/pgfplots/colormap name}}{##1}\pgfplots@loc@TMPa
		\def\pgfplots@loc@TMPb{%
			\pgfdeclarehorizontalshading{tempshading}{\pgfkeysvalueof{/pgfplots/colorbar/width}}}%
		\expandafter\pgfplots@loc@TMPb\expandafter{\pgfplots@loc@TMPa}%
		\pgfuseshading{tempshading}%
	},%
},%
\end{codeexample}
\end{stylekey}

\begin{stylekey}{/pgfplots/every colorbar}
	This style governs the placement, alignment and appearance of color bars. Any desired detail changes for color bars can be put into this style. Additionally, there is a style \declaretext{colorbar shift} which is set after |every colorbar|. The latter style is intented to contain only shift transformations like |xshift| or |yshift| (making it easier to overwrite or deactivate them).

	While a color bar is drawn, the predefined node |parent axis| can be used to align at the parent axis.
\begin{predefinednode}{parent axis}
	A node for the parent axis of a color bar. It is only valid for color bars.
\end{predefinednode}

	Thus, 
\begin{codeexample}[code only]
colorbar style={
	at={(parent axis.right of north east)},
	anchor=north west,
},
colorbar shift/.style={xshift=0.3cm}
\end{codeexample}
	\noindent places the colorbar in a way that its top-left (north west) corner is aligned right of the top right corner (|right of north east|) of its parent axis. Combining this with the |colorbar shift| is actually the same as the initial setting.

	Since color bars depend on some of its parent's properties, these properties are available as values of the following keys:
\begin{pgfplotskeylist}{point meta min,point meta max}
	The values of these keys contain the lower and upper bound of the color map, i.e.\ the lower and upper limit for the color bar. 
	
	The value is |\pgfkeysvalueof{/pgfplots/point meta min}| inside of |every colorbar|.
\end{pgfplotskeylist}
\begin{pgfplotskeylist}{parent axis width,parent axis height}
	The values of these keys contain the size of the parent axis. They can be used as |width| and/or |height| arguments for |every colorbar| with |\pgfkeysvalueof{/pgfplots/parent axis width}|.

	These values are only valid inside of color bars.
\end{pgfplotskeylist}

	Besides these values, each color bar inherits a list of styles of its parent axis, namely

	\begin{itemize}
		\item |every tick|,
		\item |every minor tick|,
		\item |every major tick|,
		\item |every axis grid|,
		\item |every minor grid|,
		\item |every major grid|,
		\item |every tick label|.
	\end{itemize}
	This can be used to inherit line width and/or fonts.

	Please take a look at the predefined styles for |every colorbar| for examples.

	\paragraph{Remark:} A color bar is just a normal axis. That means |every colorbar| can contain specifications where to place tick labels, extra ticks, scalings and most other features of a normal axis as well (except nested color bars).
\end{stylekey}

\begin{pgfplotskey}{colorbar style=\marg{key-value list}}
	A shortcut for |every colorbar/.append style=|\marg{key-value list}. It appends options to the colorbar style.
\end{pgfplotskey}

\begin{pgfplotskey}{colorbar/width=\marg{dimension} (initially 0.5cm)}
	Sets the width of a color bar.
\pgfplotsexpensiveexample
\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}[
		view/az=45,
		colorbar,
		colorbar/width=2cm,
		colormap/blackwhite]

	\addplot3[surf,domain=0:1,y domain=-3:3] {x*(1-x)*tanh(y)};
	\end{axis}
\end{tikzpicture}
\end{codeexample}

	For vertical color bars, this sets the height.
\end{pgfplotskey}


\begin{stylekey}{/pgfplots/colorbar shift}
	This style is installed after |every colorbar|. It is intented to contain only shift transformations like |xshift| and/or |yshift|. The reason to provide two separate styles is to allow easier deactivation of shift transformations.

\begin{codeexample}[code only]
colorbar shift/.style={xshift=1cm}
\end{codeexample}
\end{stylekey}

\begin{predefinednode}{current colorbar axis}
	A predefined node for the color bar of an axis. After |\end{axis}|, this node can be used to align further graphical elements at the color bar. Note that \declaretext{current axis} refers to the axis as such while |current colorbar axis| refers to the color bar (which is an axis itsself).
\end{predefinednode}

\begin{pgfplotscodekey}{colorbar/draw}
	This code key belongs to the low level interface of colorbars. It is invoked whenever a color bar needs to be drawn. Usually, it won't be necessary to use or modify this key explicitly.
	
	In the context when this key is invoked, the styles inherited from the parent axis are already set and the required variables (see the documentation of |every colorbar|) are initialised.

	This code key can be replaced if one needs more than one color bar (or other wrinkles).

	The initial configuration is
\begin{codeexample}[code only]
\pgfplotsset{colorbar/draw/.code={%
	\axis[every colorbar,colorbar shift,colorbar=false]
	\addplot graphics {};
	\endaxis
	}
}
\end{codeexample}

	Please note that a color bar axis is nothing special as such -- it is just a normal axis with one |plot graphics| command and it is invoked with a special set of options. The only special thing is that a set of styles and some variables are inherited from its parent axis.
\end{pgfplotscodekey}

\subsubsection{Scaling Descriptions: Predefined Styles}
It is reasonable to change font sizes, marker sizes etc. together with the overall plot size: Large plots should also have larger fonts and small plots should have small fonts and a smaller distance between ticks.

\begin{keylist}{
	/tikz/font=\mchoice{\textbackslash normalfont,\textbackslash small,\textbackslash tiny,$\dotsc$},
	/pgfplots/max space between ticks=\marg{integer},
	/tikz/mark size=\marg{integer}}
	These keys should be adjusted to the figure's dimensions. Use 
\begin{codeexample}[code only]
\pgfplotset{tick label style={font=\footnotesize},
	label style={font=\small},
	legend style={font=\small}
}
\end{codeexample}
	to provide different fonts for different descriptions.

	The |max space between ticks| is described on page~\pageref{maxspacebetweenticks} and configures the approximate distance between successive tick labels (in |pt|). Please omit the |pt| suffix here.
\end{keylist}

There are a couple of predefined scaling styles which set some of these options:

\begin{stylekey}{/pgfplots/normalsize}
	Re-initialises the standard scaling options of \PGFPlots.

\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}[normalsize,
		title=A ``normalsize'' figure,
		xlabel=The $x$ axis,
		ylabel=The $y$ axis,
		legend entries={Leg}]
		\addplot {max(4*x,7*x)};
	\end{axis}
\end{tikzpicture}
\end{codeexample}

	The initial setting is
\begin{codeexample}[code only]
/pgfplots/normalsize/.style={
	/pgfplots/width=240pt,
	/pgfplots/height=207pt,
	/pgfplots/max space between ticks=35
}
\end{codeexample}
\end{stylekey}

\begin{stylekey}{/pgfplots/small}
	Redefines several keys such that the axis is ``smaller''.

\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}[small,
		title=A ``small'' figure,
		xlabel=The $x$ axis,
		ylabel=The $y$ axis,
		legend entries={Leg}]
		\addplot {x^2};
	\end{axis}
\end{tikzpicture}
\end{codeexample}
	The initial setting is
\begin{codeexample}[code only]
/pgfplots/small/.style={
	/pgfplots/width=6.5cm,
	/pgfplots/height=,
	/pgfplots/max space between ticks=25
}
\end{codeexample}
Feel free to redefine the scaling -- the option may still be useful to get more ticks without typing too much. You could, for example, set |small,width=6cm|.
\end{stylekey}

\begin{stylekey}{/pgfplots/footnotesize}
	Redefines several keys such that the axis is even smaller. The tick labels will have |\footnotesize|.

\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}[footnotesize,
		title=A ``footnotesize'' figure,
		xlabel=The $x$ axis,
		ylabel=The $y$ axis,
		legend entries={Leg}]
		\addplot+[const plot]
			coordinates {
			(0,0) (1,1) (3,3) (5,10)
		};
	\end{axis}
\end{tikzpicture}
\end{codeexample}
	The initial setting is
\begin{codeexample}[code only]
/pgfplots/footnotesize/.style={
	/pgfplots/width=5cm,
	/pgfplots/height=,
	legend style={font=\footnotesize},
	tick label style={font=\footnotesize},
	label style={font=\small},
	/pgfplots/max space between ticks=20,
	every mark/.append style={mark size=8},
	ylabel style={yshift=-0.3cm}
},
\end{codeexample}
As for |small|, it can be convenient to set |footnotesize| and set |width| afterwards.
\end{stylekey}

\subsection{Scaling Options}

\begin{pgfplotskey}{width=\marg{dimen}}
Sets the width of the final picture to \marg{dimen}. If no |height| is specified, scaling will respect aspect ratios.

\noindent\underline{Remarks:} 
\begin{itemize}
	\item The scaling only affects the width of one unit in $x$-direction or the height for one unit in $y$-direction. Axis labels and tick labels won't be resized, but their size is used to determine the axis scaling.

	\item You can use the |scale=|\marg{number} option,
\begin{codeexample}[code only]
\begin{tikzpicture}[scale=2]
\begin{axis}
...
\end{axis}
\end{tikzpicture}
\end{codeexample}
	to scale the complete picture.

	\item The \Tikz-options |x| and |y| which set the unit dimensions in $x$ and $y$ directions can be specified as arguments to |\begin{axis}[x=1.5cm,y=2cm]| if needed (see below). These settings override the |width| and |height| options.

	\item You can also force a fixed width/height of the axis (without looking at labels) with
	\begin{codeexample}[code only]
\begin{tikzpicture}
\begin{axis}[width=5cm,scale only axis]
	...
\end{axis}
\end{tikzpicture}
	\end{codeexample}

	\item Please note that up to the writing of this manual, \PGFPlots\ only estimates the size needed for axis- and tick labels. It does not include legends which have been placed outside of the axis\footnote{I.e. the `|width|' option will not work as expected, but the bounding box is still ok.}. This may be fixed in future versions.

	Use the |x=|\marg{dimension}, |y=|\marg{dimension} and |scale only axis| options if the scaling happens to be wrong.
\end{itemize}
\end{pgfplotskey}

\begin{pgfplotskey}{height=\marg{dimen}}
	See |width|.
\end{pgfplotskey}

\begin{pgfplotskey}{scale only axis=\mchoice{true,false} (initially false)}
If |scale only axis| is enabled, label, tick and legend dimensions won't influence the size of the axis rectangle, that means |width| and |height| apply only to the axis rectangle

If |scale only axis=false| (the default), \PGFPlots\ will try to produce the desired width \emph{including} labels, titles and ticks.
\end{pgfplotskey}

\begin{pgfplotsxykeylist}{
	\x=\marg{dimen},
	\x={\{(\meta{x},\meta{y})\}}}
Sets the unit vectors for $x$ (or $y$). Every logical plot coordinate $(x,y)$ is drawn at the position
\[ x \cdot \begin{bmatrix} e_{xx} \\ e_{xy} \end{bmatrix} + y \cdot \begin{bmatrix} e_{yx} \\ e_{yy} \end{bmatrix}. \]
The unit vectors $e_x$ and $e_y$ determine the paper position in the current (always two dimensional) image.

The key |x=|\marg{dimen} simply sets $e_x = (\meta{dimen},0)^T $ while |y=|\marg{dimen} sets $e_y = (0,\meta{dimen})^T$.
Here, \marg{dimen} is any \TeX\ size like |1mm|, |2cm| or |5pt|. It is allowed to specify a negative \marg{dimen}.
\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[x=1cm,y=1cm]
\addplot expression[domain=0:3] {2*x};
\end{axis}
\end{tikzpicture}
\end{codeexample}

\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[x=1cm,y=-0.5cm]
\addplot expression[domain=0:3] {2*x};
\end{axis}
\end{tikzpicture}
\end{codeexample}

The second syntax, |x={(|\meta{x}|,|\meta{y}|)}| sets $e_x = (\meta{x},\meta{y})^T$ explicitly\footnote{Please note that you need extra curly braces around the vector. Otherwise, the comma will be interpreted as separator for the next key-value pair.}; the corresponding |y| key works similiarly. This allows to define skewed or rotated axes.

\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[x={(1cm,0.1cm)},y=1cm]
\addplot expression[domain=0:3] {2*x};
\end{axis}
\end{tikzpicture}
\end{codeexample}

\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[
		x={(5pt,1pt)},
		y={(-4pt,4pt)}]
\addplot {1-x^2};
\end{axis}
\end{tikzpicture}
\end{codeexample}

	Setting $x$ explicitly overrides the |width| option. Setting $y$ explicitly overrides the |height| option.

	Setting |x| and/or |y| for logarithmic axis will set the dimension used for $1 \cdot e \approx 2.71828$.

	Please note that it is \emph{not} possible to specify |x| as argument to |tikzpicture|. The option 
\begin{codeexample}[code only]
\begin{tikzpicture}[x=1.5cm]
\begin{axis}
	...
\end{axis}
\end{tikzpicture}
\end{codeexample}
	won't have any effect because an axis rescales its coordinates (see the |width| option).

\paragraph{Limitations:} Unfortunately, skewed axes are \textbf{not available for bar plots}.
\index{Errors!Skewed axes and bar plots}%
\index{Bar Plots!Skewed axes problems}%
\end{pgfplotsxykeylist}

\begin{pgfplotsxykey}{\x\ dir=\mchoice{normal,reverse} (initially normal)}
	Allows to revert axis directions such that values are given in decreasing order.

	See also the documentation for this key in section~\ref{key:pgfplots:xydir} on page~\pageref{key:pgfplots:xydir}.
\end{pgfplotsxykey}

\begin{pgfplotskey}{axis equal=\marg{true,false} (initially false)}
	Each unit vector is set to the same length while the axis dimensions stay constant. Afterwards, the size ratios for each unit in $x$ and $y$ will be the same.
	
	Axis limits will be enlarge to compensate for the scaling effect.
\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}[axis equal=false]
		\addplot[blue] expression[domain=0:2*pi,samples=300] {sin(deg(x))*sin(2*deg(x))};
	\end{axis}
\end{tikzpicture}
\hspace{1cm}
\begin{tikzpicture}
	\begin{axis}[axis equal=true]
		\addplot[blue] expression[domain=0:2*pi,samples=300] {sin(deg(x))*sin(2*deg(x))};
	\end{axis}
\end{tikzpicture}
\end{codeexample}
	
\begin{codeexample}[]
\begin{tikzpicture}
	\begin{loglogaxis}[axis equal=false]
		\addplot expression[domain=1:10000] {x^-2};
	\end{loglogaxis}
\end{tikzpicture}
\hspace{1cm}
\begin{tikzpicture}
	\begin{loglogaxis}[axis equal=true]
		\addplot expression[domain=1:10000] {x^-2};
	\end{loglogaxis}
\end{tikzpicture}
\end{codeexample}
\end{pgfplotskey}

\begin{pgfplotskey}{axis equal image=\marg{true,false} (initially false)}
	Similar to |axis equal|, but the axis limits will stay constant as well (leading to smaller images).
\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}[axis equal image=false]
		\addplot[blue] expression[domain=0:2*pi,samples=300] {sin(deg(x))*sin(2*deg(x))};
	\end{axis}
\end{tikzpicture}
\hspace{1cm}
\begin{tikzpicture}
	\begin{axis}[axis equal image=true]
		\addplot[blue] expression[domain=0:2*pi,samples=300] {sin(deg(x))*sin(2*deg(x))};
	\end{axis}
\end{tikzpicture}
\end{codeexample}
	
\begin{codeexample}[]
\begin{tikzpicture}
	\begin{loglogaxis}[axis equal image=false]
		\addplot expression[domain=1:10000] {x^-2};
	\end{loglogaxis}
\end{tikzpicture}
\hspace{1cm}
\begin{tikzpicture}
	\begin{loglogaxis}[axis equal image=true]
		\addplot expression[domain=1:10000] {x^-2};
	\end{loglogaxis}
\end{tikzpicture}
\end{codeexample}
\end{pgfplotskey}

\subsection{3D Axis Configuration}
This section described keys which are used to configure the appearance of three dimensional figures. Some of them apply for twodimensional plots as special case as well, and they will also be discussed in the respective sections of this manual.

\begin{pgfplotskey}{view=\marg{azimuth}\marg{elevation} (initially \{25\}\{30\})}
	Changes both view angles of a 3D axis. The azimuth (first argument) is the horizontal angle which is rotated around the $z$ axis. For a 3D plot, the $z$ axis always points to the top. The elevation (second argument) is the vertical rotation around the (rotated) $x$ axis. Positive elevation values indicate a view from above, negative a view from below. All values are measured in degree.

\pgfplotsexpensiveexample
\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}[view={0}{0},
		xlabel=$x$,
		zlabel=$z$,
		title=View along the positive $y$ axis]
		\addplot3[surf] {x};
	\end{axis}
\end{tikzpicture}
\end{codeexample}

\pgfplotsexpensiveexample
\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}[view={0}{90},
		xlabel=$x$,
		ylabel=$y$,
		title=View from top]
		\addplot3[surf] {x};
	\end{axis}
\end{tikzpicture}
\end{codeexample}

\pgfplotsexpensiveexample
\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}[view={-45}{45},
		xlabel=$x$,ylabel=$y$,zlabel=$z$]
		\addplot3[surf] {x};
	\end{axis}
\end{tikzpicture}
\end{codeexample}
\end{pgfplotskey}

\begin{pgfplotskeylist}{view/az=\marg{azimuth},view/h=\marg{azimuth} (initially 25)}
	Changes only the azimuth view angle, i.e.\ the horizontal (first) view angle which is rotated around the~$z$ axis.

\pgfplotsexpensiveexample
\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}[view/h=-30]
	\addplot3[
		surf,
		shader=interp,
		samples=50,
		domain=-3:3,y domain=-2:2] 
		{sin(deg(x+y^2))};
	\end{axis}
\end{tikzpicture}
\end{codeexample}

\pgfplotsexpensiveexample
\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}[view/h=10]
	\addplot3[
		surf,
		shader=interp,
		samples=50,
		domain=-3:3,y domain=-2:2] 
		{sin(deg(x+y^2))};
	\end{axis}
\end{tikzpicture}
\end{codeexample}

\pgfplotsexpensiveexample
\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}[view/h=40,colormap/violet]
	\addplot3[
		surf,
		shader=interp,
		samples=50,
		domain=-3:3,y domain=-2:2] 
		{sin(deg(x+y^2))};
	\end{axis}
\end{tikzpicture}
\end{codeexample}

\pgfplotsexpensiveexample
\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}[view/h=70]
	\addplot3[
		surf,
		shader=interp,
		samples=50,
		domain=-3:3,y domain=-2:2] 
		{sin(deg(x+y^2))};
	\end{axis}
\end{tikzpicture}
\end{codeexample}
\end{pgfplotskeylist}

\begin{pgfplotskeylist}{view/el=\marg{elevation},view/v=\marg{elevation} (initially 30)}
	Changes only the vertical elevation, i.e.\ the second argument to |view|. Positive values view from above, negative values from below. 
\end{pgfplotskeylist}

\begin{stylekey}{/pgfplots/every 3d description}
	This style is a relatively low level method to change the appearance of \emph{descriptions} for three dimensional axes. Naturally, a three dimensional axis will display axis labels for $x$ and $y$ differently  than a two dimensional axis (for example, the $y$ axis label won't be rotated by 90 degrees). The \declaretext{every 3d description} style installs the necessary display options for three dimensional axis descriptions.

	The initial value is:
\begin{codeexample}[code only]
/pgfplots/every 3d description/.style={
	% Only these description styles can be changed here:
	/pgfplots/every axis x label/.style={at={(ticklabel cs:0.5)},
		anchor=near ticklabel},
	/pgfplots/every axis y label/.style={at={(ticklabel cs:0.5)},
		anchor=near ticklabel},
	/pgfplots/every x tick scale label/.style={
		at={(xticklabel cs:0.85,10pt)},
		anchor=near xticklabel,inner sep=0pt},
	/pgfplots/every y tick scale label/.style={
		at={(yticklabel cs:0.85,10pt)},
		anchor=near yticklabel,inner sep=0pt}
}%
\end{codeexample}

	As the name suggests, |every 3d description| can only be used to set styles for axis labels, tick labels and titles. It has \emph{not} been designed to reset other styles, you will need to change these options either for each axis separately or by means of user defined styles. The reason for this limitation is: other options can (and, in many cases) need to be set before the axis is processed. However, the decision whether we have a two dimensional or a three dimensional axis has to be postponed until the processing is more or less complete -- so only some remaining keys can be set.	
\end{stylekey}

\begin{stylekey}{/pgfplots/every 3d view \marg{h}\marg{v}}
	A style which can be used for fine tuning of the output for specific views.

	This style will be installed right after |every 3d description|, but before other axis description related keys are set (in other words: it has higher precedence than |every 3d description| but less precedence than keys provided to the axis directly).

	One example is preconfigured for |view={0}{90}| (from top):
\begin{codeexample}[code only]
/pgfplots/every 3d view {0}{90}/.style={
	/pgfplots/xlabel near ticks,
	/pgfplots/ylabel near ticks,
	/pgfplots/axis on top=true
}
\end{codeexample}
\end{stylekey}

\begin{pgfplotskeylist}{%
	xticklabel shift=\marg{dimension} (initially 0cm),%
	yticklabel shift=\marg{dimension} (initially 0cm),%
	zticklabel shift=\marg{dimension} (initially 0cm)}
	FIXME
\end{pgfplotskeylist}

\begin{pgfplotsxykey}{\x ticklabel anchor=\mchoice{auto,paraxial,tikz} (initially auto)}
	FIXME
\end{pgfplotsxykey}

\begin{pgfplotskey}{plot box ratio=\marg{x stretch}\marg{y stretch}\marg{z stretch} (initially {1}{1}{1})}
	Allows to customize the aspect ratio between the three different axes in a three dimensional plot.

	The |plot box ratio| is applied before any rotations and stretch--to--fill routines have been invoked. Thus, the initial setting |{1}{1}{1}| makes all axes equally long.

\pgfplotsexpensiveexample
\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[
	view/h=60,
	plot box ratio={1}{1}{1},
	colormap={violet}{[1cm] rgb255(0cm)=(25,25,122)
		color(1cm)=(white) rgb255(5cm)=(238,140,238)},
	xlabel=$x$,
	ylabel=$t$,
	zlabel={$p(x,t)$},
	shader=faceted,
	title=Initial \texttt{plot box ratio},
]
	\addplot3[surf,y domain=0.02:3.5,samples=81]
		{1/(2*sqrt(pi*y)) * exp(-x^2/y)};
\end{axis}
\end{tikzpicture}
\end{codeexample}

\pgfplotsexpensiveexample
\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[
	view/h=60,
	plot box ratio={1}{2}{1},
	colormap={violet}{[1cm] rgb255(0cm)=(25,25,122)
		color(1cm)=(white) rgb255(5cm)=(238,140,238)},
	xlabel=$x$,
	ylabel=$t$,
	zlabel={$p(x,t)$},
	shader=interp,
	title=\texttt{plot box ratio=1 2 1},
]
	\addplot3[surf,y domain=0.02:3.5,samples=81] 
		{1/(2*sqrt(pi*y)) * exp(-x^2/y)};
\end{axis}
\end{tikzpicture}
\end{codeexample}

	This key applies only to three dimensional axes. After the scaling, the axes will be stretched to fill the |width| and |height| for this plot. Thus, the effects of |plot box ratio| might be undone by this stretching for particular views.
\end{pgfplotskey}

\subsection{Error Bars}
\label{sec:errorbars}
{%
\def\pgfplotserror#1{\ensuremath{\epsilon_{#1}}}%
\PGFPlots\ supports error bars for normal and logarithmic plots. 

Error bars are enabled for each plot separately, using \meta{options} after |\addplot|:
\begin{codeexample}[code only]
\addplot+[error bars/.cd,x dir=both,y dir=both] ...
\end{codeexample}
Error bars inherit all drawing options of the associated plot, but they use their own marker and style arguments additionally.

\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}
\addplot+[error bars/.cd,
	y dir=plus,y explicit]
coordinates {
	(0,0)     +- (0.5,0.1) 
	(0.1,0.1) +- (0.05,0.2)
	(0.2,0.2) +- (0,0.05)
	(0.5,0.5) +- (0.1,0.2)
	(1,1)     +- (0.3,0.1)};
\end{axis}
\end{tikzpicture}
\end{codeexample}

\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}
\addplot+[error bars/.cd,
	y dir=both,y explicit,
	x dir=both,x fixed=0.05,
	error mark=diamond*]
coordinates {
	(0,0)     +- (0.5,0.1) 
	(0.1,0.1) +- (0.05,0.2)
	(0.2,0.2) +- (0,0.05)
	(0.5,0.5) +- (0.1,0.2)
	(1,1)     +- (0.3,0.1)};
\end{axis}
\end{tikzpicture}
\end{codeexample}

\pgfplotsset{anchor=center,/tikz/every picture/.append style={baseline}}
\begin{codeexample}[]
\pgfplotstabletypeset{pgfplots.testtable2.dat}

\begin{tikzpicture}
\begin{loglogaxis}
\addplot+[error bars/.cd,
	x dir=both,x fixed relative=0.5,
	y dir=both,y explicit relative,
	error mark=triangle*]
	table[x=x,y=y,y error=errory] 
	{pgfplots.testtable2.dat};
\end{loglogaxis}
\end{tikzpicture}
\end{codeexample}
%--------------------------------------------------
% coordinates {
% 	(32,32)
% 	(64,64)
% 	(128,128) +- (0,0.3)
% 	(1024,1024) +- (0,0.2)
% 	(32068,32068) +- (0,0.6)
% 	(64000,64000) +- (0,0.6)
% 	(128000,128000) +- (0,0.6)
% };
%-------------------------------------------------- 

\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[enlargelimits=false]
\addplot[red,mark=*] 
	plot[error bars/.cd,
	y dir=minus,y fixed relative=1,
	x dir=minus,x fixed relative=1,
	error mark=none,
	error bar style={dotted}]
coordinates
	{(0,0) (0.1,0.1) (0.2,0.2) 	
	 (0.5,0.5) (1,1)};
\end{axis}
\end{tikzpicture}
\end{codeexample}

\begin{pgfplotsxykey}{error bars/\x\ dir=\mchoice{none,plus,minus,both} (initially none)}
Draws either no error bars at all, only marks at $x+\pgfplotserror x$, only marks at $x-\pgfplotserror x$ or marks at both, $x+\pgfplotserror x$ and $x-\pgfplotserror x$. The $x$-error $\pgfplotserror x$ is acquired using one of the following options.

The same holds for the |y dir| option.
\end{pgfplotsxykey}

\begin{pgfplotsxykey}{error bars/\x\ fixed=\marg{value} (initially 0)}
Provides a common, absolute error $\pgfplotserror x=\text{\meta{value}}$ for all input coordinates.

For linear $x$~axes, the error mark is drawn at $x \pm \pgfplotserror x$ while for logarithmic $x$~axes, it is drawn at $\log( x \pm \pgfplotserror x)$. Computations are performed in \PGF's floating point arithmetics.
\end{pgfplotsxykey}

\begin{pgfplotsxykey}{error bars/\x\ fixed relative=\marg{percent} (initially 0)}
Provides a common, relative error $\pgfplotserror x = \text{\meta{percent}} \cdot x$ for all input coordinates. The argument \meta{percent} is thus given relatively to input $x$ coordinates such that $\text{\meta{percent}} = 1$ means $100\%$.

Error marks are thus placed at $x \cdot (1 \pm \pgfplotserror x)$ for linear axes and at $\log(x \cdot (1 \pm \pgfplotserror x))$ for logarithmic axes. Computations are performed in floating point for linear axis and using the identity $\log(x \cdot (1 \pm \pgfplotserror x)) = \log(x) + \log( 1 \pm \pgfplotserror x)$ for logarithmic scales.
\end{pgfplotsxykey}

\begin{pgfplotsxykey}{error bars/\x\ explicit}
Configures the error bar algorithm to draw $x$-error bars at any input coordinate for which user-specified errors are available.
 Each error is interpreted as absolute error, see |x fixed| for details.

The different input formats of errors are described in section~\ref{sec:errorbar:input}.
\end{pgfplotsxykey}

\begin{pgfplotsxykey}{error bars/\x\ explicit relative}
Configures the error bar algorithm to draw $x$-error bars at any input coordinate for which user-specified errors are available.
 Each error is interpreted as relative error, that means error marks are placed at $x (1 \pm \text{\meta{value}}(x))$ (works as for |error bars/x fixed relative|).
\end{pgfplotsxykey}


\begin{pgfplotskey}{error bars/error mark=\meta{marker}}
Sets an error marker for any error bar. \marg{marker} is expected to be a valid plot mark, see section~\ref{sec:markers}.
\end{pgfplotskey}

\begin{pgfplotskey}{error bars/error mark options=\marg{key-value-list}}
Sets a key-value list of options for any error mark. This option works similary to the \Tikz\ `|mark options|' key.
\end{pgfplotskey}

\begin{pgfplotskey}{error bars/error bar style=\marg{key-value-list}}
Appends the argument to `|/pgfplots/every error bar|' which is installed at the beginning of every error bar.
\end{pgfplotskey}

\begin{pgfplotscodetwokey}{error bars/draw error bar}
Allows to change the default drawing commands for error bars. The two arguments are
\begin{itemize} 
\item the source point, $(x,y)$ and
\item the target point, $(\tilde x,\tilde y)$.
\end{itemize}
Both are determined by \PGFPlots\ according to the options described above. The default code is
\begin{codeexample}[code only]
/pgfplots/error bars/draw error bar/.code 2 args={%
	\pgfkeysgetvalue{/pgfplots/error bars/error mark}%
		{\pgfplotserrorbarsmark}%
	\pgfkeysgetvalue{/pgfplots/error bars/error mark options}%
		{\pgfplotserrorbarsmarkopts}%
	\draw #1 -- #2 node[pos=1,sloped,allow upside down] {%
		\expandafter\tikz\expandafter[\pgfplotserrorbarsmarkopts]{%
			\expandafter\pgfuseplotmark\expandafter{\pgfplotserrorbarsmark}%
			\pgfusepath{stroke}}%
	};
}
\end{codeexample}
\end{pgfplotscodetwokey}

\subsubsection{Input Formats of Error Coordinates}
\label{sec:errorbar:input}%
Error bars with explicit error estimations for single data points require some sort of input format. This applies to `|error bars/|\meta{[xy]}| explicit|' and `|error bars/|\meta{[xy]}| explicit relative|'.

Error bar coordinates can be read from `|plot coordinates|' or from `|plot table|'. The inline plot coordinates format is
\begin{codeexample}[code only]
\addplot coordinates {
	(1,2) +- (0.4,0.2)
	(2,4) +- (1,0)
	(3,5)
	(4,6) +- (0.3,0.001)
}
\end{codeexample}
where $(1,2) \pm (0.4,0.2)$ is the first coordinate, $(2,4) \pm (1,0)$ the second and so forth. The point $(3,5)$ has no error coordinate.

The `|plot table|' format is
\begin{codeexample}[code only]
\addplot table[x error=COLNAME,y error=COLNAME]
\end{codeexample}
or
\begin{codeexample}[code only]
\addplot table[x error index=COLINDEX,y error index=COLINDEX]
\end{codeexample}
These options are used as the `|x|' and `|x index|' options.

You can supply error coordinates even if they are not used at all; they will be ignored silently in this case.

}%

\subsection{Number Formatting Options}
\label{sec:number:printing}%
\PGFPlots\ typeset tick labels rounded to given precision and in configurable number formats. The command to do so is |\pgfmathprintnumber|; it uses the current set of number formatting options.

These options are described in all detail in the manual for \PGFPlotstable, which comes with \PGFPlots. Please refer to that manual.

\begin{command}{\pgfmathprintnumber\marg{x}}
Generates pretty-printed output for the (real) number \marg{x}. The input number \marg{x} is parsed using |\pgfmathfloatparsenumber| which allows arbitrary precision.

Numbers are typeset in math mode using the current set of number printing options, see below. Optional arguments can also be provided using |\pgfmathprintnumber[|\meta{options}|]|\marg{x}.

Please refer to the manual of \PGFPlotstable\ (shipped with this package) for details about the number options.
\end{command}

\label{sec:identify:minor:log}%
\begin{pgfplotskey}{log identify minor tick positions=\mchoice{true,false} (initially false)}
Set this to |true| if you want to identify log--plot tick labels at positions 
\[ i \cdot 10^j \]
with $i \in \{2,3,4,5,6,7,8,9\},\, j \in \Z$. This may be valueable in conjunction with the `|extra x ticks|' and `|extra y ticks|' options.
\begin{codeexample}[]
\begin{tikzpicture}%
\begin{loglogaxis}
	[title=Standard options,
	width=6cm]
\addplot coordinates {
	(1e-2,10)
	(3e-2,100)
	(6e-2,200)
};
\end{loglogaxis}
\end{tikzpicture}%
\end{codeexample}

\begin{codeexample}[]
\pgfplotsset{every axis/.append style={%
	width=6cm,
	xmin=7e-3,xmax=7e-2,
	extra x ticks={3e-2,6e-2},
	extra x tick style={major tick length=0pt,font=\footnotesize}
}}%

\begin{tikzpicture}%
	\begin{loglogaxis}[
		xtick={1e-2},
		title=with minor tick identification,
		extra x tick style={
			log identify minor tick positions=true}]
	\addplot coordinates {
		(1e-2,10)
		(3e-2,100)
		(6e-2,200)
	};
	\end{loglogaxis}
\end{tikzpicture}%

\begin{tikzpicture}%
	\begin{loglogaxis}[
		xtick={1e-2},
		title=without minor tick identification,
		extra x tick style={
			log identify minor tick positions=false}]
	\addplot coordinates {
		(1e-2,10)
		(3e-2,100)
		(6e-2,200)
	};
	\end{loglogaxis}%
\end{tikzpicture}%
\end{codeexample}
	This key is set by the default styles for extra ticks.
\end{pgfplotskey}

\begin{pgfplotscodekey}{log number format code}
Provides \TeX-code to generate log plot tick labels. Argument `|#1|' is the (natural) logarithm of the tick position.
The default implementation invokes |log base 10 number format code| after it changed the log basis to~$10$. It also checks the other log plot options.

This key will have a different meaning when the log basis has been chosen explicitly, see the \declaretext{log basis x} key.
\end{pgfplotscodekey}


\begin{pgfplotscodekey}{log base 10 number format code}
Allows to change the overall appearance of base 10 log plot tick labels. The default is
\begin{codeexample}[code only]
log base 10 number format code/.code={%
	$10^{\pgfmathprintnumber{#1}}$}
\end{codeexample}
where the `|log plot exponent style|' allows to change number formatting options.
\end{pgfplotscodekey}

\begin{pgfplotscodekey}{log number format basis}
	This part of the representation routines for log ticks in \emph{arbitrary} basis (see the \declaretext{log basis x} key). It is used instead of the key above if the log basis has been changed. The first supplied argument is the log basis, the second the exponent. The initial configuration is
\begin{codeexample}[code only]
/pgfplots/log number format basis/.code 2 args={$#1^{\pgfmathprintnumber{#2}}$}
\end{codeexample}
\end{pgfplotscodekey}

\begin{pgfplotskey}{log plot exponent style=\marg{key-value-list}}
Allows to configure the number format of log plot exponents. This style is installed just before `|log base 10 number format code|' will be invoked. Please note that this style will be installed within the default code for `|log number format code|'.
\begin{codeexample}[]
\pgfplotsset{
	samples=15,
	width=7cm,
	xlabel=$x$,
	ylabel=$f(x)$,
	extra y ticks={45},
	legend style={at={(0.03,0.97)},
		anchor=north west}}

\begin{tikzpicture}
\begin{semilogyaxis}[
	log plot exponent style/.style={
		/pgf/number format/fixed zerofill,
		/pgf/number format/precision=1},
	domain=-5:10]

	\addplot {exp(x)};
	\addplot {exp(2*x)};

	\legend{$e^x$,$e^{2x}$}
\end{semilogyaxis}
\end{tikzpicture}
\end{codeexample}

\begin{codeexample}[]
\pgfplotsset{
	samples=15,
	width=7cm,
	xlabel=$x$,
	ylabel=$f(x)$,
	extra y ticks={45},
	legend style={at={(0.03,0.97)},
		anchor=north west}}

\begin{tikzpicture}
\begin{semilogyaxis}[
	log plot exponent style/.style={
		/pgf/number format/fixed,
		/pgf/number format/use comma,
		/pgf/number format/precision=2},
	domain=-5:10]

	\addplot {exp(x)};
	\addplot {exp(2*x)};

	\legend{$e^x$,$e^{2x}$}
\end{semilogyaxis}
\end{tikzpicture}
\end{codeexample}
\end{pgfplotskey}




\subsection{Specifying the Plotted Range}

\begin{pgfplotsxykeylist}{\x min=\marg{coord},\x max=\marg{coord}}
The options |xmin|, |xmax| and |ymin|, |ymax| allow to define the axis limits, i.e.\ the lower left and the upper right corner. Everything outside of the axis limits will be clipped away.

Each missing limit will be determined automatically.

If $x$-limits have been specified explicitly and $y$-limits are computed automatically, the automatic computation of $y$-limits will only considers points which fall into the specified $x$-range (and vice--versa). The same holds true if, for example, only |xmin| has been provided explicitly: in that case, |xmax| will be updated only for points for which $x \ge $|xmin| holds. This feature can be disabled using |clip limits=false|. 

Axis limits can be increased automatically using the |enlargelimits| option.
\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}
	\addplot {x^2};
	\end{axis}
\end{tikzpicture}
\end{codeexample}

\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}[xmin=0]
	\addplot {x^2};
	\end{axis}
\end{tikzpicture}
\end{codeexample}

\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}[ymax=10]
	\addplot {x^2};
	\end{axis}
\end{tikzpicture}
\end{codeexample}
\end{pgfplotsxykeylist}

\begin{pgfplotsxykey}{\x mode=\mchoice{normal,linear,log} (initially normal)}
Allows to choose between linear (=normal) or logarithmic axis scaling or logplots for each $x,y$-combination.
\end{pgfplotsxykey}

\begin{pgfplotsxykey}{\x\ dir=\mchoice{normal,reverse} (initially normal)}
\label{key:pgfplots:xydir}
	Allows to revert axis directions such that values are given in decreasing order.
\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[x dir=reverse]
	\addplot {x+rand*0.3};
\end{axis}
\end{tikzpicture}
\end{codeexample}

\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[y dir=reverse]
	\addplot {x^2};
\end{axis}
\end{tikzpicture}
\end{codeexample}
\end{pgfplotsxykey}

\begin{pgfplotskey}{clip limits=\mchoice{true,false} (initially true)}
	Configures what to do if some, but not all axis limits have been specified explicitly. In case |clip limits=true|, the automatic limit computation will \emph{only} consider points which do not contradict the explicitly set limits. 

	This option has nothing to do with path clipping, it only affects how the axis limits are computed.
\end{pgfplotskey}

\begin{pgfplotsxykey}{enlarge \x\ limits=\mchoice{auto,true,false,upper,lower,\marg{val},value=\marg{val},abs value=\marg{absolute val},abs=\marg{absolute value},rel=\marg{val}} (initially auto)}
Enlarges the axis size for one axis somewhat if enabled.

You can set |xmin|, |xmax| and |ymin|, |ymax| to the minimum/maximum values of your data and |enlarge x limits| will enlarge the canvas such that the axis doesn't touch the plots.

\begin{itemize}
	\item The value \declaretext{true} enlarges the lower and upper limit.
	\item The value \declaretext{false} uses tight axis limits as specified by the user (or read from input coordinates).
	\item The value \declaretext{auto} will enlarge limits only for axis for which axis limits have been determined automatically.

	For threedimensional figures, the \declaretext{auto} mechanism applies only for the $z$ axis. The $x$ and $y$ axis won't be enlarged. 
	\item The value \declaretext{upper} enlarges only the upper axis limit while \declaretext{lower} enlarges only the lower axis limit.
	\item Values like `|enlarge x limits=0.1|' will enlarge lower and upper axis limit relatively (in this example, $10\%$ of the axis limits will be added on both sides).
	\item It is also possible to change just the relative threshold using the \declaretext{value=}\marg{val} key. It can be combined with any of the other possible values. For example, 

		|\pgfplotsset{enlarge x limits={value=0.2,upper}}|
	
	will enlarge (only) the upper axis limit by $20\%$ of the axis range. Another example is

		|\pgfplotsset{enlarge x limits={value=0.2,auto}}|

	which changes the default threshold of the \declaretext{auto} value to $20\%$.
	\item While |value| uses relative thresholds, \declaretext{abs value} is used in the same way with absolute values.

	\paragraph{Attention:} |abs value| is applied \emph{multiplicative} for logarithmic axes! That means |abs value=10| for a logarithmic axis adds $\log 10$ to upper and/or lower axis limits.

	\item Finally, \declaretext{abs=}\marg{value} is the same as |true,abs value=|\marg{value} and \declaretext{rel=}\marg{value} is the same as |true,value=|\marg{value}.
\end{itemize}
\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}
		\addplot {5 * x^3 - x^2 + 4*x -2};
	\end{axis}
\end{tikzpicture}
\end{codeexample}

\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}[enlarge x limits=0.2]
		\addplot {5 * x^3 - x^2 + 4*x -2};
	\end{axis}
\end{tikzpicture}
\end{codeexample}

\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}[minor x tick num=4,
		enlarge x limits={rel=0.5,upper}
	]
		\addplot {5 * x^3 - x^2 + 4*x -2};
	\end{axis}
\end{tikzpicture}
\end{codeexample}

\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}[minor x tick num=4,
		enlarge x limits={abs=3}
	]
		\addplot {5 * x^3 - x^2 + 4*x -2};
	\end{axis}
\end{tikzpicture}
\end{codeexample}

\begin{codeexample}[]
\begin{tikzpicture}
	\begin{loglogaxis}[enlarge x limits={abs=11}]
		\addplot+[domain=1:100000] {x^-2};
	\end{loglogaxis}
\end{tikzpicture}
\end{codeexample}

\end{pgfplotsxykey}

\begin{stylekey}{/pgfplots/enlargelimits=\marg{value} (default true)}
	A style which sets |enlarge x limits| and |enlarge y limits| to the specified value.
\end{stylekey}

\begin{environment}{{pgfplotsinterruptdatabb}}
\index{Bounding Box Control!Disable \protect\emph{data} bounding box modifications}
	Everything in \marg{environment contents} will not contribute to the data bounding box.
\end{environment}

\subsection{Tick Options}

\subsubsection{Tick Positions and Labels}
\begin{pgfplotsxykey}{\x tick=\mchoice{\textbackslash empty,data,\normalfont\marg{coordinate list}} (initially \marg{})}
The options |xtick| and |ytick| assigns a list of \emph{Positions} where ticks shall be placed. The argument is either the command |\empty|, |data| or a list of coordinates. The choice |\empty| will result in no tick at all. The special value |data| will produce tick marks at every coordinate of the first plot. Otherwise, tick marks will be placed at every coordinate in  \marg{coordinate list}. If this list is empty, \PGFPlots\ will compute a default list. 

\marg{coordinate list} will be used inside of a |\foreach \x in |\marg{coordinate list} statement. The format is as follows:
\begin{itemize}
	\item |{0,1,2,5,8,1e1,1.5e1}| (a series of coordinates),
	\item |{0,...,5}| (the same as |{0,1,2,3,4,5}|),
	\item |{0,2,...,10}| (the same as |{0,2,4,6,8,10}|),
	\item |{9,...,3.5}| (the same as |{9, 8, 7, 6, 5, 4}|),
	\item See \cite[Section~34]{tikz} for a more detailed definition of the options.
	\item Please be careful with whitespaces inside of \marg{coordinate list} (at least around the dots).
\end{itemize}
For logplots, \PGFPlots\ will apply $\log(\cdot)$ to each element in `\marg{coordinate list}'. 
\begin{codeexample}[]
\begin{tikzpicture}
	\begin{loglogaxis}[xtick={12,9897,1468864}]
	% see above for this macro:
	\plotcoords
	\end{loglogaxis}
\end{tikzpicture}
\end{codeexample}

\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[
	xtick=\empty,
	ytick={-2,0.3,3,3.7,4.5}]
\addplot+[smooth] coordinates {
	(-2,3) (-1.5,2) (-0.3,-0.2) 
	(1,1.2) (2,2) (3,5)};
\end{axis}
\end{tikzpicture}
\end{codeexample}

\paragraph{Attention:} You can't use the `|...|' syntax if the elements are too large for \TeX! For example, `|xtick=1.5e5,2e7,3e8|' will work (because the elements are interpreted as strings, not as numbers), but `|xtick=1.5,3e5,...,1e10|' will fail because it involves real number arithmetics beyond \TeX's capacities.
\vspace*{0.3cm}

\noindent
The default choice for tick \emph{positions} in normal plots is to place a tick at each coordinate~$i\cdot h$. The step size~$h$ depends on the axis scaling and the axis limits. It is chosen from a list a ``feasable'' step sizes such that neither too much nor too few ticks will be generated. The default for logplots is to place ticks at positions $10^i$ in the axis' range. Which positions depends on the axis scaling and the dimensions of the picture. If log plots contain just one (or two) positions $10^i$ in their limits, ticks will be placed at positions $10^{i\cdot h}$ with ``feasable'' step sizes $h$ as in the case of linear axis.

\FIXME{Improve docs here}

\noindent
The tick \emph{appearance} can be (re-)configured with
\begin{codeexample}[code only]
\pgfplotsset{every tick/.style={very thin,gray}}
\pgfplotsset{every minor tick/.style={}}
\end{codeexample}
or
\begin{codeexample}[code only]
\pgfplotsset{every tick/.append style={very thin,gray}}
\pgfplotsset{every minor tick/.append style={black}}
\end{codeexample}
Please prefer the `|.append style|' versions whenever possible to ensure compatibility with future versions.

These style commands can be used at any time. The tick line width can be configured with `|major tick length|' and `|minor tick length|'.

\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[xtick=data,xmajorgrids]
	\addplot coordinates {
		(1,2)
		(2,5)
		(4,6.5)
		(6,8)
		(10,9)
	};
\end{axis}
\end{tikzpicture}
\end{codeexample}

\begin{codeexample}[]
\begin{tikzpicture}
\begin{loglogaxis}[
	title=A log plot with small axis range]

	\addplot coordinates {
		(10,1e-4)
		(17,8.3176e-05)
		(25,7.0794e-05)
		(50,5e-5)
	};
\end{loglogaxis}
\end{tikzpicture}
\end{codeexample}
\end{pgfplotsxykey}

\begin{pgfplotskey}{minor tick num=\marg{number}}
	Sets both, |minor x tick num| and |minor y tick num| to \marg{number}.

	Minor ticks will be disabled if the major ticks don't have the same distance.
\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}[minor tick num=1]
	\addplot {x^3};
	\addplot {-20*x};
	\end{axis}
\end{tikzpicture}
\end{codeexample}

\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}[minor tick num=3]
	\addplot {x^3};
	\addplot {-20*x};
	\end{axis}
\end{tikzpicture}
\end{codeexample}

\end{pgfplotskey}

\begin{pgfplotsxykey}{minor \x\ tick num=\marg{number} (initially 0)}
	Sets the number of minor tick lines used for linear $x$~or~$y$ axis separately.

	Minor ticks will be disabled if the major ticks don't have the same distance.
\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}[minor x tick num=1,
	             minor y tick num=3]
	\addplot {x^3};
	\addplot {-20*x};
	\end{axis}
\end{tikzpicture}
\end{codeexample}

\end{pgfplotsxykey}

\begin{pgfplotsxykey}{extra \x\ ticks=\marg{coordinate list}}
Adds \emph{additional} tick positions and tick labels to the $x$~or~$y$ axis. `Additional' tick positions do not affect the normal tick placement algorithms, they are drawn after the normal ticks. This has two benefits: first, you can add single, important tick positions without disabling the default tick label generation and second, you can draw tick labels `on top' of others, possibly using different style flags.


\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[
	xmin=0,xmax=3,ymin=0,ymax=15,
	extra y ticks={2.71828},
	extra y tick labels={$e$},
	extra x ticks={2.2},
	extra x tick style={grid=major,
		tick label style={
			rotate=90,anchor=east}},
	extra x tick labels={Cut},
]
	\addplot {exp(x)};
	\addlegendentry{$e^x$}
\end{axis}
\end{tikzpicture}
\end{codeexample}
\begin{codeexample}[]
\pgfplotsset{every axis/.append style={width=5.3cm}}
\begin{tikzpicture}
\begin{loglogaxis}[
	xtickten={1,2},
	ytickten={-5,-6}]
\addplot coordinates 
	{(10,1e-5) (20,5e-6) (40,2.5e-6)};
\end{loglogaxis}
\end{tikzpicture}

\begin{tikzpicture}
\begin{loglogaxis}[
	xtickten={1,2},
	ytickten={-5,-6},
	extra x ticks={20,40},
	extra y ticks={5e-6,2.5e-6}]
\addplot coordinates 
	{(10,1e-5) (20,5e-6) (40,2.5e-6)};
\end{loglogaxis}
\end{tikzpicture}

\begin{tikzpicture}
\begin{loglogaxis}[
	log identify minor tick positions=false,
	xtickten={1,2},
	ytickten={-5,-6},
	extra x ticks={20,40},
	extra y ticks={5e-6,2.5e-6}]
\addplot coordinates 
	{(10,1e-5) (20,5e-6) (40,2.5e-6)};
\end{loglogaxis}
\end{tikzpicture}
\end{codeexample}

Remarks:
\begin{itemize} 
\item Use |extra x ticks| to highlight special tick positions. The use of |extra x ticks| does not affect minor tick/grid line generation, so you can place extra ticks at positions $j\cdot 10^i$ in log--plots. 
\item Extra ticks are always typeset as major ticks.

They are affected by |major tick length| or options like |grid=major|.
\item Use the style |every extra x tick| (|every extra y tick|) to configure the appearance.
\item You can also use `|extra x tick style=|\marg{...}' which has the same effect.
\end{itemize}
\end{pgfplotsxykey}


\begin{pgfplotsxykey}{\x tickten=\marg{exponent base 10 list}}
These options allow to place ticks at selected positions $10^k, k \in \text{\marg{exponent base 10 list}}$. They are only used for logplots. The syntax for \marg{exponent base 10 list} is the same as above for |xtick=|\marg{list} or |ytick=|\marg{list}.

Using `|xtickten={1,2,3,4}|' is equivalent to `|xtick={1e1,1e2,1e3,1e4}|', but it requires fewer computational time and it allows to use the short syntax `|xtickten={1,...,4}|'.
\begin{codeexample}[]
\begin{tikzpicture}
\begin{semilogyaxis}[
	samples=8,
	ytickten={-6,-4,...,4},
	domain=0:10]

\addplot {2^(-2*x + 6)};
\addlegendentry{$2^{-2x + 6}$}

% or invoke gnuplot to generate coordinates:
\addplot gnuplot[id=pow2] 
	{2**(-1.5*x -3)};
\addlegendentry{$2^{-1.5x -3}$}
\end{semilogyaxis}
\end{tikzpicture}
\end{codeexample}
\end{pgfplotsxykey}

\begin{pgfplotsxykey}{\x ticklabels=\marg{label list}}
\label{pgfplots:key:xticklabels}%
Assigns a \emph{list} of tick \emph{labels} to each tick position. Tick \emph{positions} are assigned using the |xtick| and |ytick|-options.

This is one of two options to assign tick labels directly. The other option is |xticklabel=|\marg{command} (or |yticklabel=|\marg{command}).
Option `|xticklabel|' offers higher flexibility while `|xticklabels|' is easier to use.

The argument \marg{label list} has the same format as for ticks, that means
\begin{codeexample}[code only]
xticklabels={$\frac{1}{2}$,$e$}
\end{codeexample}
Denotes the two--element--list $\{\frac 12, e\}$. The list indices match the indices of the tick positions. If you need commas inside of list elements, use 
\begin{codeexample}[code only]
xticklabels={{0,5}, $e$}.
\end{codeexample}


\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[
	xtick={-1.5,-1,...,1.5},
	xticklabels={%
		$-1\frac 12$,
		$-1$,
		$-\frac 12$,
		$0$,
		$\frac 12$,
		$1$}
]
\addplot[smooth,blue,mark=*] 
coordinates {
	(-1,    1)
	(-0.75, 0.5625)
	(-0.5,  0.25)
	(-0.25, 0.0625)
	(0,     0)
	(0.25,  0.0625)
	(0.5,   0.25)
	(0.75,  0.5625)
	(1,     1)
};
\end{axis}
\end{tikzpicture}
\end{codeexample}

\begin{codeexample}[]
\begin{tikzpicture}
\begin{semilogyaxis}[
  ytickten={-2,-1,0,1,2},
  yticklabels={$\frac{1}{100}$,%
  	$\frac{1}{10}$,%
	1,10,100},
]
	\addplot {exp(x)};
\end{semilogyaxis}
\end{tikzpicture}
\end{codeexample}
\end{pgfplotsxykey}


\begin{pgfplotsxykey}{\x ticklabel=\marg{command}}
Use |xticklabel| or |yticklabel| to change the \TeX-command which creates the tick \emph{labels} assigned to each tick position (see options |xtick| and |ytick|). 

This is one of two options to assign tick labels directly. The other option is `|xticklabels=|\marg{label list}' (or |yticklabels=|\marg{label list}). Option `|xticklabel|' offers higher flexibility while `|xticklabels|' is easier to use.

The argument \marg{command} can be any \TeX-text. The following commands are valid inside of \marg{command}:
\begin{description}
	\item[\textbackslash tick] The current element of option |xtick| (or |ytick|).
	\item[\textbackslash ticknum] The current tick number, starting with~0 (a counter).
	\item[\textbackslash nexttick] This command is only valid in case if the |x tick label as interval| option is set (or the corresponding variable for~$y$). It will contain the position of the next tick position, that means the right boundary of the tick interval.
\end{description}
The default argument is 
\begin{itemize}
	\item |\axisdefaultticklabel| for normal plots and 
	\item |\axisdefaultticklabellog| for logplots, see below.
\end{itemize}
(the same holds for |yticklabel|). The defaults are set to
\begin{codeexample}[code only]
\def\axisdefaultticklabel{%
	$\pgfmathprintnumber{\tick}$%
}

\def\axisdefaultticklabellog{%
	\pgfkeysgetvalue{/pgfplots/log number format code/.@cmd}\pgfplots@log@label@style
	\expandafter\pgfplots@log@label@style\tick\pgfeov
}
\end{codeexample}
that means you can configure the appearance of linear axis with the number formatting options described in section~\ref{sec:number:printing} and logarithmic axis with |log number format code|, see below.

\begin{codeexample}[]
\begin{tikzpicture}
	\begin{semilogyaxis}[
		yticklabel style={/pgf/number format/fixed},
		% changes tick labels to a number instead 
		% of exponential notation:
		yticklabel={%
			\pgfmathfloatparsenumber{\tick}%
			\pgfmathfloatexp{\pgfmathresult}%
			\pgfmathprintnumber{\pgfmathresult}%
		},
	]
		\addplot {exp(x)};
	\end{semilogyaxis}
\end{tikzpicture}
\end{codeexample}

The following example uses explicitly formatted $x$ tick labels and a small \TeX\ script to format $y$ tick labels in the form \meta{sign}\meta{number}|/10|.
\begin{codeexample}[width=4cm]
\begin{tikzpicture}
\begin{axis}[
	title=A special Prewavelet,
	xtick={0,1,0.5,0.25,0.75},
	xticklabels={$0$,$1$,$\frac12$,$\frac14$,$\frac34$},
	ytick=data,
	ymajorgrids,
	yticklabel={%
		\scriptsize
		\ifdim\tick pt<0pt % a TeX \if -- see TeX Book
			\pgfmathparse{-10*\tick}%
			$-\pgfmathprintnumber{\pgfmathresult}/10$%
		\else
			\pgfmathparse{10*\tick}%
			$\pgfmathprintnumber{\pgfmathresult}/10$%
		\fi
	}
	]
	\addplot coordinates {(0,-1.2) (0.25,1.1) 
		(0.5,-0.6) (0.75,0.1) (1,0)};
\end{axis}
\end{tikzpicture}
\end{codeexample}

You can change the appearance of tick labels with
\begin{codeexample}[code only]
\pgfplotsset{every tick label/.append style={
	font=\tiny,
	/pgf/number format/sci}}
\end{codeexample}
and/or
\begin{codeexample}[code only]
\pgfplotsset{every x tick label/.append style={
	above,
	/pgf/number format/fixed zerofill}}
\end{codeexample}
and
\begin{codeexample}[code only]
\pgfplotsset{every y tick label/.append style={font=\bfseries}}
\end{codeexample}
Another possibility is to use 
\begin{codeexample}[code only]
\begin{axis}[y tick label style={above,
	/pgf/number format/fixed zerofill}
]
...
\end{axis}
\end{codeexample}
which has the same effect as the `|every x tick label|' statement above. This is possible for all \PGFPlots-|every|-styles, see section~\ref{sec:styles}.
\end{pgfplotsxykey}

\begin{pgfplotsxykey}{\x\ tick label as interval=\mchoice{true,false} (initially false)}
\label{key:pgfplots:ticklabelasinterval}
	Allows to treat tick labels as intervals; that means the tick positions denote the interval boundaries. If there are $n$ positions, $(n-1)$ tick labels will be generated, one for each interval.
\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[x tick label as interval]
	\addplot {3*x};
\end{axis}
\end{tikzpicture}
\end{codeexample}
	This mode enables the use of |\nexttick| inside of |xticklabel| (or |yticklabel|). A common application might be a bar plot.
\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[
	ybar interval=0.9,
	x tick label as interval,
	xmin=2003,xmax=2030,
	ymin=0,ymax=140,
	xticklabel={
	   $\pgfmathprintnumber{\tick}$
	-- $\pgfmathprintnumber{\nexttick}$},
	xtick=data,
	x tick label style={
		rotate=90,anchor=east,
		/pgf/number format/1000 sep=}
]

	\addplot[draw=blue,fill=blue!40!white]
		coordinates
		{(2003,40) (2005,100) (2006,15) 
		 (2010,90) (2020,120) (2030,3)};
\end{axis}
\end{tikzpicture}
\end{codeexample}
\end{pgfplotsxykey}



\begin{pgfplotsxykeylist}{\x minorticks=\mchoice{true,false} (initially true),\x majorticks=\mchoice{true,false} (initially true),ticks=\mchoice{minor,major,both,none} (initially both)}
Enables/disables the small tick lines either for single axis or for all of them. Major ticks are those placed at the tick positions and minor ticks are between tick positions. Please note that minor ticks are automatically disabled if |xtick| is not a uniform range\footnote{A uniform list means the difference between all elements is the same for linear axis or, for logarithmic axes, $\log(10)$.}.

The key |minor tick length=|\marg{dimen} configures the tick length for minor ticks while the |major| variant applies to major ticks.
You can configure the appearance using the following styles:
\begin{codeexample}[code only]
\pgfplotsset{every tick/.append style={color=black}} % applies to major and minor ticks,
\pgfplotsset{every minor tick/.append style={thin}}  % applies only to minor ticks,
\pgfplotsset{every major tick/.append style={thick}} % applies only to major ticks.
\end{codeexample}
There is also the style ``|every tick|'' which applies to both, major and minor ticks.
\end{pgfplotsxykeylist}

\begin{pgfplotsxykeylist}{\x tickmin=\marg{coord}, \x tickmax=\marg{coord}}
	These keys can be used to modify minimum/maximum values before ticks are drawn. Because this applies to axis discontinuities, it is described on page~\pageref{key:xytickminmax} under section~\ref{key:xytickminmax}, ``Axis Discontinuities"'.
\end{pgfplotsxykeylist}

\subsubsection{Tick Alignment}

\begin{pgfplotsxykey}{\x tick pos=\mchoice{left,right,both} (initially both)}
Allows to choose where to place the small tick lines. In the default configuration, this does also affect tick \emph{labels}, see below.

For $x$, the additional choices |bottom| and |top| can be used which are equivalent to |left| and |right|, respectively. Both are accepted for $y$.
\end{pgfplotsxykey}

\begin{pgfplotskey}{tickpos=\mchoice{left,right,both}}
	A style which sets both, |xtick pos| and |ytick pos|.
\end{pgfplotskey}

\begin{pgfplotsxykey}{\x ticklabel pos=\mchoice{left,right,default} (initially default)}
Allows to choose where to place tick \emph{labels}. The choices |left| and |right| place tick labels either at the left or at the right side of the complete axis. The choice |default| uses the same setting as |xtick pos| (or |ytick pos|). This option is only useful for boxed axis -- keep it to |default| for non-boxed figures.

For $x$, the additional choices |bottom| and |top| can be used which are equivalent to |left| and |right|, respectively. Both are accepted for $x$.
\end{pgfplotsxykey}

\begin{pgfplotskey}{ticklabel pos=\mchoice{left,right,default}}
	A style which sets both, |xticklabel pos| and |yticklabel pos|.
\end{pgfplotskey}

\begin{pgfplotsxykey}{\x tick align=\mchoice{inside,center,outside} (initially inside)}
Allows to change the location of the ticks relative to the axis lines.
Default is ``|inside|''.
\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[
	xtick=data,ytick=data,
	xtick align=center,
	axis x line=center,
	axis y line=center,
	enlargelimits=0.05]
\addplot coordinates 
	{(-3,0) (-2,0.1) (-1,-0.6) 
	 (0,1)
	 (1,-0.6) (2,0.1) (3,0)};
\end{axis}
\end{tikzpicture}
\end{codeexample}

\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[
	xtick=data,ytick=data,
	axis x line=bottom,
	ytick align=outside,
	axis y line=left,
	enlargelimits=0.05]
\addplot coordinates 
	{(-3,0) (-2,0.1) (-1,-0.6)
	 (0,1) 
	 (1,-0.6) (2,0.1) (3,0)};
\end{axis}
\end{tikzpicture}
\end{codeexample}

\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[
	xtick=data,
	axis x line=center,
	xticklabels={,,},
	ytick={-0.6,0,0.1,1},
	yticklabels={
		$-\frac{6}{10}$,,
		$\frac{1}{10}$,$1$},
	ymajorgrids,
	axis y line=left,
	enlargelimits=0.05]
\addplot coordinates 
	{(-3,0) (-2,0.1) (-1,-0.6)
	 (0,1) 
	 (1,-0.6) (2,0.1) (3,0)};
\end{axis}
\end{tikzpicture}
\end{codeexample}
\end{pgfplotsxykey}

\begin{stylekey}{/pgfplots/tick align=\mchoice{inside,center,outside} (initially inside)}
	A style which sets both, |xtick align| and |ytick align| to the specified value.
\end{stylekey}

\subsubsection{Tick Scaling - Common Factors In Ticks}
\label{sec:scaled:ticks}%
\begin{pgfplotsxykeylist}{
	scaled \x\ ticks=\mchoice{true,false,base 10:{\normalfont\meta{e}},real:{\normalfont\meta{number}},manual:{\normalfont\marg{text}\marg{tick scale code}}} (initially true),
	scaled ticks=\mchoice{true,false,base 10:{\normalfont\meta{e}},real:{\normalfont\meta{number}},manual:{\normalfont\marg{text}\marg{tick scale code}\hfill}} (initially true)}
Allows to factor out common exponents in tick labels for \emph{linear axes}. For example, if you have tick labels $20000,40000$ and $60000$, you may want to save some space and write $2,4,6$ with a separate factor `$\cdot 10^4$'. Use `|scaled ticks=true|' to enable this feature. In case |true|, tick scaling will be triggered if the data range is either too large or too small (see below).
\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[scaled ticks=true]
	\addplot coordinates {
		(20000,0.0005)
		(40000,0.0010)
		(60000,0.0020)
	};
\end{axis}
\end{tikzpicture}%
\end{codeexample}

\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[scaled ticks=false]
	\addplot coordinates {
		(20000,0.0005)
		(40000,0.0010)
		(60000,0.0020)
	};
\end{axis}
\end{tikzpicture}
\end{codeexample}

	The |scaled ticks| key is a style which simply sets scaled ticks for both, $x$ and $y$.

	The value |base 10:|\meta{e} allows to adjust the algorithm manually. For example, |base 10:3| will divide every tick label by $10^3$:
\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}[scaled ticks=base 10:3,
		/pgf/number format/sci subscript]
	\addplot coordinates
		{(-0.00001,2e12) (-0.00005,4e12) };
	\end{axis}
\end{tikzpicture}
\end{codeexample}
\noindent Here, the \texttt{sci subscript} option simply saves space.
In general, |base 10:|$e$ will divide every tick by $10^e$. The effect
is not limited by the ``too large or too small'' decisions mentioned
above.

	The value |real:|\meta{number} allows to divide every tick by a fixed \meta{number}.
	For example, the following plot is physically ranged from $0$ to $2\pi$, but the tick scaling algorithm is configured to divide every tick label by $\pi$.
\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}[
		xtick={0,1.5708,...,10},
		domain=0:2*pi,
		scaled x ticks={real:3.1415},
		xtick scale label code/.code={$\cdot \pi$}]
	\addplot {sin(deg(x))};
	\end{axis}
\end{tikzpicture}
\end{codeexample}
	\noindent Setting |scaled ticks=real:|\meta{number} also changes the |tick scale label code| to
\begin{codeexample}[code only]
\pgfkeys{/pgfplots/xtick scale label code/.code=
	{$\pgfkeysvalueof{/pgfplots/tick scale binop} \pgfmathprintnumber{#1}$}}.
\end{codeexample}
\noindent The key \declaretext{tick scale binop} is described below, it is set initially to |\cdot|.

A further -- not very useful -- example is shown below. Every $x$ tick label has been divided by $2$, every $y$ tick label by $3$.
\nobreak
\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}[
		scaled x ticks=real:2,
		scaled y ticks=real:3]
	\addplot {x^3};
	\node[pin=135:{$(3,9)$}] at (axis cs:3,9) {};
	\end{axis}
\end{tikzpicture}
\end{codeexample}

	Unfortunately, \meta{number} can't be evaluated with \PGF's math parser (yet) to maintain the full data range accepted by \PGFPlots.

	The last option, |scaled ticks=manual:|\marg{text}\marg{tick scale code} allows even more customization. It allows \emph{full control} over the displayed scaling label \emph{and} the scaling code: \marg{text} is used as-is inside of the tick scaling label while \marg{tick scale code} is supposed to be a one-argument-macro which scales each tick. Example:
\begin{codeexample}[]
\begin{tikzpicture} 
\begin{axis}[
	% warning: the '%' signs are necessary (?)
	scaled y ticks=manual:{$+65\,535$}{%
		\pgfmathfloatcreate{1}{6.5535}{4}%
		\pgfmathfloatsubtract{#1}{\pgfmathresult}%
	},
	yticklabel style={
		/pgf/number format/fixed,
		/pgf/number format/precision=1},
] 
\addplot coordinates { 
	(0, 65535) 
	(13, 65535) 
	(14, 65536) 
	(15, 65537) 
	(30, 65537) 
}; 
\end{axis} 
\end{tikzpicture} 	
\end{codeexample}
\noindent The example uses |$+65\,535$| as tick scale label content. Furthermore, it defines the customized tick label formula $y - (+6.5535\cdot 10^4) = y - 65535$ to generate $y$ tick labels.

The \marg{text} can be arbitrary. It is completely in user control. The second argument, \marg{tick scale code} is supposed to be a one-argument-macro in which |#1| is the current tick position in floating point representation. The macro is expected to assign |\pgfmathresult| (also in floating point representation). The \PGF\ manual~\cite{tikz} contains detailed documentation about its math engine (including floating point\footnote{However, that particular stuff is newer than \PGF\ $2.00$. At the time of this writing, it is only available as (public) CVS version.}).

This feature may also be used do transform coordinates in case they can't be processed with \PGFPlots: transform them and supply a proper tick scaling method such that tick labels represent the original range.

If \marg{text} is empty, the tick scale label won't be drawn (and no space will be occupied).

Tick scaling does \emph{not} work for logarithmic axes.
\end{pgfplotsxykeylist}

\begin{pgfplotsxycodekeylist}{\x tick scale label code}
Allows to change the default code for scaled tick labels. The default is
\begin{codeexample}[code only]
xtick scale label code/.code={$\cdot 10^{#1}$}.
\end{codeexample}

More precisely, it is
\begin{codeexample}[code only]
xtick scale label code/.code={$\pgfkeysvalueof{/pgfplots/tick scale binop} 10^{#1}$}
\end{codeexample}
\noindent and the initial value of |tick scale binop| is |\cdot|, but it can be changed to |\times| if desired.

If the code is empty, no tick scale label will be drawn (and no space is consumed).
\end{pgfplotsxycodekeylist}

\begin{pgfplotscodekey}{tick scale label code}
	A style which sets |xtick scale label code| and those for $y$ and $z$.
\end{pgfplotscodekey}


\begin{pgfplotskey}{tick scale binop=\marg{\TeX\ math operator} (initially \textbackslash cdot)}
	Sets the binary operator used to display tick scale labels.
\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[
	title=\texttt{tick scale 
		binop=\textbackslash cdot}]
\addplot
	[mark=none,blue,samples=250,
	 domain=0:5]
	{exp(10*x)};
\end{axis}
\end{tikzpicture}
\end{codeexample}

\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[
	title=\texttt{tick scale 
		binop=\textbackslash times},
	tick scale binop=\times]
\addplot
	[mark=none,blue,samples=250,
	 domain=0:5] 
	{exp(10*x)};
\end{axis}
\end{tikzpicture}
\end{codeexample}
\end{pgfplotskey}

\begin{pgfplotskey}{scale ticks below=\marg{exponent}}
Allows fine tuning of the `|scaled ticks|' algorithm: if the axis limits are of magnitude $10^e$ and $e<$\marg{exponent}, the common prefactor~$10^e$ will be factored out. The default is 
\makeatletter
\pgfplots@scale@ticks@below@exponent
\makeatother.
\end{pgfplotskey}

\begin{pgfplotskey}{scale ticks above=\marg{exponent}}
Allows fine tuning of the '|scaled ticks|' algorithm: if the axis limits are of magnitude $10^e$ and $e>$\marg{exponent}, the common prefactor~$10^e$ will be factored out. The default is
\makeatletter
\pgfplots@scale@ticks@above@exponent
\makeatother.
\end{pgfplotskey}


\subsubsection{Tick Fine Tuning}
The tick placement algorithm depends on a number of parameters which can be tuned to get better results.
\begin{pgfplotskey}{max space between ticks=\marg{number} (initially 35)}
\label{maxspacebetweenticks}
	Configures the maximum space between adjacent ticks in full points. The suffix ``|pt|'' has to be omitted and fractional numbers are not supported. The default is~\axisdefaulttickwidth.
\end{pgfplotskey}

\begin{pgfplotskey}{try min ticks=\marg{number} (initially 4)}
	Configures a loose lower bound on the number of ticks. It should be considered as a suggestion, not a tight limit. The default is~\axisdefaulttryminticks. This number will increase the number of ticks if `|max space between ticks|' produces too few of them.

	The total number of ticks may still vary because not all fractional numbers in the axis' range are valid tick positions.
\end{pgfplotskey}

\begin{pgfplotskey}{try min ticks log=\marg{number} (initially 3)}
	The same as |try min ticks|, but for logarithmic axis.
\end{pgfplotskey}

\begin{pgfplotskeylist}{tickwidth=\marg{dimension} (initially 0.15cm),major tick length=\marg{dimension} (initially 0.15cm)}
	Sets the width of major tick lines.
\end{pgfplotskeylist}

\begin{pgfplotskeylist}{subtickwidth=\marg{dimension} (initially 0.1cm),minor tick length=\marg{dimension} (initially 0.1cm)}
	Sets the width of minor tick lines.
\end{pgfplotskeylist}

\begin{pgfplotsxykeylist}{\x tick placement tolerance (initially 0.05pt)}
	Tick lines and labels will be placed if they are no more than this tolerance beyond the axis limits. This threshold should be chosen such that it does not produce visible differences while still providing fault tolerance.

	The threshold is given in paper units of the final figure.
\end{pgfplotsxykeylist}

\begin{pgfplotsxykey}{log basis \x=\marg{number} (initially empty)}
	Allows to change the logarithms used for logarithmic axes.

	Changing to a different log basis is nothing but a scale. However, it also changes the way tick labels are displayed: they will also be shown in the new basis.

\begin{codeexample}[]
\begin{tikzpicture}
	\begin{semilogyaxis}[log basis y=2,grid=major]
		\addplot {2^x};
	\end{semilogyaxis}
\end{tikzpicture}
~
\begin{tikzpicture}
	\begin{semilogyaxis}[log basis y=10]
		\addplot {2^x};
	\end{semilogyaxis}
\end{tikzpicture}
\end{codeexample}
	
	The initial setting is `|log basis x=|' which defaults to: the natural logarithm for any coordinates (basis $\exp(1)$), and the logarithm base $10$ for the display of tick labels.

	If the log basis is changed to something different than the empty string, the chosen logarithm will be applied to any input coordinate (if the axis scale is log as well) and tick labels will be displayed in this basis. 
	
	Furthermore, a technical thing happens: the style \declaretext{log basis ticks=}\marg{axis char} will be installed (for example |log basis ticks=y|). This style in turn will change \declaretext{log number format code}.

	Please note that the \declaretext{[xyz]tickten} will be used differently now: it will provide the desired ticks in the new basis! Despite the misleading name ``|ten|'', |xtickten={1,2,3,4}| will yield ticks at $2^1,2^2,2^3,2^4$ if |log basis x=2| has been set.
\end{pgfplotsxykey}

\subsection{Grid Options}
	
\begin{pgfplotsxykeylist}{\x minorgrids=\mchoice{true,false} (initially true),\x majorgrids=\mchoice{true,false} (initially true),grids=\mchoice{minor,major,both,none} (initially both)}
Enables/disables different grid lines. Major grid lines are placed at the normal tick positions (see |xmajorticks|) while minor grid lines are placed at minor ticks (see |xminorticks|). 

This example employs the coordinates defined on page~\pageref{page:plotcoords:src}.
\begin{codeexample}[]
\begin{tikzpicture}
\begin{loglogaxis}[
	xlabel={\textsc{Dof}},
	ylabel={$L_2$ Error},
	grid=major
]
% see above for this macro:
\plotcoords
\end{loglogaxis}
\end{tikzpicture}
\end{codeexample}

\begin{codeexample}[]
\begin{tikzpicture}
\begin{loglogaxis}[
	grid=both,
	tick align=outside,
	tickpos=left]
\addplot coordinates 
	{(100,1e-4) (500,1e-5) (1000,3e-6)};
\addplot coordinates 
	{(100,1e-5) (500,4e-6) (1000,2e-6)};
\end{loglogaxis}
\end{tikzpicture}
\end{codeexample}

Grid lines will be drawn before tick lines are processed, so ticks will be drawn on top of grid lines. You can configure the appearance of grid lines with the styles
\begin{codeexample}[code only]
\pgfplotsset{every axis grid/.style={style=help lines}}
\pgfplotsset{every minor grid/.append style={color=blue}}
\pgfplotsset{every major grid/.append style={thick}}
\end{codeexample}
\noindent and/or the keys |grid style=|\marg{keys}, |minor grid style=|\marg{keys} and |major grid style=|\marg{keys}.
\end{pgfplotsxykeylist}


\subsection{Accessing Axis Coordinates for Annotations}
\label{sec:axis:coords}%
\begin{coordinatesystem}{axis cs}
\PGFPlots\ provides a new coordinate system for use inside of an axis, the ``axis coordinate system'', |axis cs|.

It can be used to draw any \Tikz-graphics at axis coordinates. It is used like
\begin{codeexample}[code only]
\draw 
   (axis cs:18943,2.873391e-05) 
|- (axis cs:47103,8.437499e-06);
\end{codeexample}
\begin{codeexample}[]
\tikzstyle{every pin}=[fill=white,
	draw=black,
	font=\footnotesize]
\begin{tikzpicture}
	\begin{loglogaxis}[
		xlabel={\textsc{Dof}},
		ylabel={$L_2$ Error}]

	\addplot coordinates {
		(11,     6.887e-02)
		(71,     3.177e-02)
		(351,    1.341e-02)
		(1471,   5.334e-03)
		(5503,   2.027e-03)
		(18943,  7.415e-04)
		(61183,  2.628e-04)
		(187903, 9.063e-05)
		(553983, 3.053e-05)
	};

	\node[coordinate,pin=above:{Bad!}] 
		at (axis cs:5503,2.027e-03) {};
	\node[coordinate,pin=left:{Good!}] 
		at (axis cs:187903,9.063e-05)	{};
	\end{loglogaxis}
\end{tikzpicture}
\end{codeexample}

\begin{codeexample}[]
\begin{tikzpicture}
\begin{loglogaxis}[
	xlabel=\textsc{Dof},
	ylabel=$L_2$ Error
]
\draw 
		(axis cs:1793,4.442e-05)
	|-  (axis cs:4097,1.207e-05)
	node[near start,left] 
	{$\frac{dy}{dx} = -1.58$};

\addplot coordinates {
	(5,    8.312e-02)
	(17,   2.547e-02)
	(49,   7.407e-03)
	(129,  2.102e-03)
	(321,  5.874e-04)
	(769,  1.623e-04)
	(1793, 4.442e-05)
	(4097, 1.207e-05)
	(9217, 3.261e-06)
};
\end{loglogaxis}
\end{tikzpicture}
\end{codeexample}

\paragraph{Attention:} Whenever you draw additional graphics, consider using |axis cs|! It applies any logarithms, data scaling transformations or whatever \PGFPlots\ usually does!

There is also a low--level interface to access the transformations and coordinates, see section~\ref{sec:pgfplots:lowlevel} on page~\pageref{sec:pgfplots:lowlevel}.
\end{coordinatesystem}

\begin{coordinatesystem}{rel axis cs}
The ``relative axis coordinate system'', |rel axis cs|, uses the complete axis vectors as units. That means `$x=0$' denotes the point on the lower $x$ axis range and `$x=1$' the point on the upper $x$ axis range.

\pgfplotsexpensiveexample
\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}

	\addplot3[surf] {x^2 - y^2};
	\draw  (rel axis cs:0,0,1) 
		-- (rel axis cs:1,1,1);
\end{axis}
\end{tikzpicture}
\end{codeexample}

\pgfplotsexpensiveexample
\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[
	xlabel=$x$,
	ylabel=$y$,
	zlabel=$z$,
	every axis x label/.style={
		at={(rel axis cs:0.5,-0.15,-0.15)}},
	every axis y label/.style={
		at={(rel axis cs:1.15,0.5,-0.15)}},
	every axis z label/.style={
		at={(rel axis cs:-0.15,-0.15,0.5)}},
]

	\addplot3[surf] {x*(1-x)*y};
\end{axis}
\end{tikzpicture}
\end{codeexample}

There is also a low--level interface to access the transformations and coordinates, see section~\ref{sec:pgfplots:lowlevel} on page~\pageref{sec:pgfplots:lowlevel}.
\end{coordinatesystem}

\begin{predefinednode}{current plot begin}
	This coordinate will be defined for every plot and can be used is \meta{trailing path commands} or after a plot. It is the first coordinate of the current plot.	
\end{predefinednode}

\begin{predefinednode}{current plot end}
	This coordinate will be defined for every plot. It is the last coordinate of the current plot.	
\end{predefinednode}



\subsection{Style Options}
\label{sec:styles}
\subsubsection{All Supported Styles}
\PGFPlots\ provides many styles to customize its appearance and behavior. They can be defined and changed in any place where keys are allowed. Furthermore, own styles are defined easily.

\begin{handler}{{.style}=\marg{key-value-list}}
	Defines or redefines a style \meta{key}. A style is a normal key which will set all options in \marg{key-value-list} when it is set.

	Use	|\pgfplotsset{|\meta{key}|/.style={|\meta{key-value-list}|}}| to (re-) define a style \meta{key} in the namespace |/pgfplots|.
\end{handler}

\begin{handler}{{.append style}=\marg{key-value-list}}
	Appends \marg{key-value-list} to an already existing style \meta{key}. This is the preferred method to change the predefined styles: if you only append, you maintain compatibility with future versions.

	Use	|\pgfplotsset{|\meta{key}|/.append style={|\meta{key-value-list}|}}| to append \marg{key-value-list} to the style \meta{key}. This will assume the prefix |/pgfplots|.
\end{handler}

\subsubsection*{Styles installed for linear/logarithmic axis}

\begin{stylekey}{/pgfplots/every axis (initially empty)}
 Installed at the beginning of every axis. \Tikz\ options inside of it will be used for anything inside of the axis rectangle and any axis descriptions.
\end{stylekey}

\begin{stylekey}{/pgfplots/every semilogx axis (initially empty)}
 Installed at the beginning of every plot with linear $x$~axis and logarithmic $y$~axis, but after `|every axis|'.
\end{stylekey}

\begin{stylekey}{/pgfplots/every semilogy axis (initially empty)}
 Likewise, but with interchanged roles for $x$~and~$y$.
\end{stylekey}

\begin{stylekey}{/pgfplots/every loglog axis (initially empty)}
 Installed at the beginning of every double--logarithmic plot.
\end{stylekey}

\begin{stylekey}{/pgfplots/every linear axis (initially empty)}
 Installed at the beginning of every plot with normal axis scaling.
\end{stylekey}

\subsubsection*{Styles installed for single plots}

\begin{stylekey}{/pgfplots/every axis plot (initially empty)}
	Installed for each plot. This style may contain options like samples, gnuplot parameters, error bars and it may contain options which affect the final drawing commands.
\end{stylekey}

\begin{stylekey}{/pgfplots/every axis plot post (initially empty)}
 This style is similar to |every axis plot| in that is applies to any drawing command in |\addplot|. However, it is set \emph{after} any user defined styles or |cycle list| options.
\begin{codeexample}[]
\begin{tikzpicture}
\pgfplotsset{
	every axis plot post/.append style=
		{mark=none}}

\begin{axis}[
	legend style={
		at={(0.03,0.97)},anchor=north west},
	domain=0:1]
	\addplot {x^2};
	\addplot {exp(x)};
	\legend{$x^2$,$e^x$}
\end{axis}
\end{tikzpicture}
\end{codeexample}
\end{stylekey}

\begin{stylekey}{/pgfplots/every axis plot no \# (initially empty)}
 Used for every \#th plot where $\#=0,1,2,3,4,\dotsc$.
\end{stylekey}

\begin{stylekey}{/pgfplots/every forget plot (initially empty)}
 Used for every plot which has |forget plot| activated.
\end{stylekey}

\subsubsection*{Styles for axis descriptions}

\begin{stylekey}{/pgfplots/every axis label (initially empty)}
 Used for $x$~and~$y$ axis label. You can use `|at=|\parg{x,y} to set its position where $(0,0)$ refers to the lower left corner and $(1,1)$ to the upper right one.
\end{stylekey}

\pgfplotsshortstylekey label style=every axis label\pgfeov

\begin{xystylekey}{/pgfplots/every axis \x\ label}
 Used only~$x$ or only for~$y$ labels, installed after `|every axis label|'.

 The initial settings are
\begin{codeexample}[code only]
\pgfplotsset{
	every axis x label/.style={at={(0.5,0)},below,yshift=-15pt},
	every axis y label/.style={at={(0,0.5)},xshift=-35pt,rotate=90}}
\end{codeexample}

 The predefined node |current axis| can be used to refer to anchors of the unfinished picture. For example
 `|at={(current axis.origin)}|' will position a label at the \emph{data} coordinate $(0,0)$. More useful is probably
 `|at={(current axis.right of origin)}|', see
 section~\ref{pgfplots:sec:align} for more details. This remark holds
 for any axis description, but it is mostly useful for axis labels.

\paragraph{Attention:} These styles will be overwritten by |axis x line| and/or |axis y line|. Please remember to place your modifications after the axis line variations.
\end{xystylekey}

\pgfplotsshortxystylekeys \x\ label style,\x label style=every axis \x\ label\pgfeov

\begin{stylekey}{/pgfplots/every axis title}
 Used for any axis title. The |at=|\parg{x,y} command works as for `|every axis label|'.

The initial setting is
\begin{codeexample}[code only]
\pgfplotsset{every axis title/.style={at={(0.5,1)},above,yshift=6pt}}
\end{codeexample}
\end{stylekey}

\pgfplotsshortstylekey title style=every axis title\pgfeov

\begin{stylekey}{/pgfplots/every axis legend}
 Installed for each legend. As for |every axis label|, the legend's position can be placed using coordinates between $0$~and~$1$, see above.

 The initial setting is
\begin{codeexample}[code only]
\pgfplotsset{every axis legend/.style={
		cells={anchor=center},
		inner xsep=3pt,inner ysep=2pt,nodes={inner sep=2pt,text depth=0.15em},
		anchor=north east,
		shape=rectangle,
		fill=white,draw=black,
		at={(0.98,0.98)}}}
\end{codeexample}
\end{stylekey}

\pgfplotsshortstylekey legend style=every axis legend\pgfeov

\subsubsection*{Styles for axis lines}
\begin{xystylekey}{/pgfplots/every outer \x\ axis line (initially empty)}
	Installed for every axis line which lies on the outer box.

	If you want arrow heads, you may also need to check the |separate axis lines| boolean key.
\end{xystylekey}

\begin{xystylekey}{/pgfplots/every inner \x\ axis line (initially empty)}
	Installed for every axis line which is drawn using the |center| or |middle| options.
\end{xystylekey}

\begin{pgfplotsxykeylist}{%
	axis line style=\marg{key-value-list},
	inner axis line style=\marg{key-value-list},
	outer axis line style=\marg{key-value-list},
	\x\ axis line style=\marg{key-value-list}}
	These options modify selects parts of the axis line styles. They set |every inner x axis line| and |every outer x axis line| and the respective $y$ variants.
\end{pgfplotsxykeylist}

\noindent
Please refer to section~\ref{pgfplots:page:axislines} on page~\pageref{pgfplots:page:axislines} for details about styles for axis lines.



\subsubsection*{Styles for ticks}

\begin{stylekey}{/pgfplots/every tick (initially very thin,gray)}
 Installed for each of the small tick \emph{lines}.
\end{stylekey}

\pgfplotsshortstylekey tick style=every tick\pgfeov

\begin{stylekey}{/pgfplots/every minor tick  (initially empty)}
 Used for each minor tick line, installed after `|every tick|'.
\end{stylekey}

\pgfplotsshortstylekey minor tick style=every minor tick\pgfeov

\begin{stylekey}{/pgfplots/every major tick (initially empty)}
 Used for each major tick line, installed after `|every tick|'.
\end{stylekey}

\pgfplotsshortstylekey major tick style=every major tick\pgfeov

\begin{stylekey}{/pgfplots/every tick label (initially empty)}
 Used for each $x$~and~$y$ tick labels.
\end{stylekey}

\pgfplotsshortxystylekeys tick label style,ticklabel style=every tick label\pgfeov

\begin{xystylekey}{/pgfplots/every \x\ tick label (initially empty)}
 Used for each $x$ (or $y$, respectively) tick label, installed after `|every tick label|'.
\end{xystylekey}

\pgfplotsshortxystylekeys \x\ tick label style,\x ticklabel style=every \x\ tick label\pgfeov

\begin{xystylekey}{/pgfplots/every \x\ tick scale label}
 Configures placement and display of the nodes containing the order of magnitude of tick labels, see section~\ref{sec:scaled:ticks} for more information about |scaled ticks|.

The initial settings are
\begin{codeexample}[code only]
\pgfplotsset{
	every x tick scale label/.style={at={(1,0)},yshift=-2em,left,inner sep=0pt},
	every y tick scale label/.style={at={(0,1)},above right,inner sep=0pt,yshift=0.3em}}
\end{codeexample}
\end{xystylekey}

\pgfplotsshortxystylekey \x\ tick scale label style=every \x\ tick scale label\pgfeov

\begin{xystylekey}{/pgfplots/every \x\ tick (initially empty)}
	Installed for tick \emph{lines} on either $x$ or $y$ axis.
\end{xystylekey}

\pgfplotsshortxystylekey \x\ tick style=every \x\ tick\pgfeov

\begin{xystylekey}{/pgfplots/every minor \x\ tick (initially empty)}
	Installed for minor tick lines on either $x$ or $y$ axis.
\end{xystylekey}

\pgfplotsshortxystylekey minor \x\ tick style=every minor \x\ tick\pgfeov

\begin{xystylekey}{/pgfplots/every major \x\ tick (initially empty)}
	Installed for major tick lines on either $x$ or $y$ axis.
\end{xystylekey}
\pgfplotsshortxystylekey major \x\ tick style=every major \x\ tick\pgfeov

\begin{xystylekey}{/pgfplots/every extra \x\ tick}
 Allows to configure the appearance of `|extra x ticks|'. This style is installed before touching the first extra $x$~tick. It is possible to set any option which affects tick or grid line generation.

The initial setting is
\begin{codeexample}[code only]
\pgfplotsset{
	every extra x tick/.style={/pgfplots/log identify minor tick positions=true},
	every extra y tick/.style={/pgfplots/log identify minor tick positions=true}}
\end{codeexample}

 Useful examples are shown below.
\begin{codeexample}[code only]
\pgfplotsset{every extra x tick/.append style={grid=major}}
\pgfplotsset{every extra x tick/.append style={major tick length=0pt}}
\pgfplotsset{every extra x tick/.append style={/pgf/number format=sci subscript}}
\end{codeexample}
\end{xystylekey}

\pgfplotsshortxystylekey extra \x\ tick style=every extra \x\ tick\pgfeov



\subsubsection*{Styles for grid lines}

\begin{stylekey}{/pgfplots/every axis grid (initially thin,black!25)}
 Used for each grid line.
\end{stylekey}

\pgfplotsshortstylekey grid style=every axis grid\pgfeov

\begin{stylekey}{/pgfplots/every minor grid (initially empty)}
 Used for each minor grid line, installed after `|every axis grid|'.
\end{stylekey}

\pgfplotsshortstylekey minor grid style=every minor grid\pgfeov

\begin{stylekey}{/pgfplots/every major grid (initially empty)}
 Likewise, for major grid lines.
\end{stylekey}

\pgfplotsshortstylekey major grid style=every major grid\pgfeov

\begin{xystylekey}{/pgfplots/every axis \x\ grid (initially empty)}
	Used for each grid line in either $x$ or $y$ direction.
\end{xystylekey}

\pgfplotsshortxystylekey \x\ grid style=every axis \x\ grid\pgfeov

\begin{xystylekey}{/pgfplots/every minor \x\ grid (initially empty)}
	Used for each minor grid line in either $x$ or $y$ direction.
\end{xystylekey}

\pgfplotsshortxystylekey minor \x\ grid style=every minor \x\ grid\pgfeov

\begin{xystylekey}{/pgfplots/every major \x\ grid (initially empty)}
	Used for each major grid line in either $x$ or $y$ direction.
\end{xystylekey}

\pgfplotsshortxystylekey major \x\ grid style=every major \x\ grid\pgfeov

\subsubsection*{Styles for error bars}

\begin{stylekey}{/pgfplots/every error bar (initially thin)}
 Installed for every error bar. 
\end{stylekey}

\pgfplotsshortstylekey error bars/error bar style=every error bar\pgfeov

\subsubsection{(Re-)Defining Own Styles}
\label{sec:styles:own}%
Use |\pgfplotsset{|\meta{style name}|/.style=|\marg{key-value-list}|}|
to create own styles. If \meta{style name} exists already, it will be replaced. Please note that it is \emph{not} possible to use the \Tikz-command |\tikzstyle|\marg{style name}|=[]| in this context\footnote{This was possible in a previous version and is still supported for backwards compatibility. But in some cases, it may not work as expected.}.
\begin{codeexample}[]
\pgfplotsset{my personal style/.style=
	{grid=major,font=\large}}

\begin{tikzpicture}
\begin{axis}[my personal style]
	\addplot coordinates {(0,0) (1,1)};	
\end{axis}
\end{tikzpicture}
\end{codeexample}

\subsection{Alignment Options and Bounding Box Control}
\label{pgfplots:sec:align}

\subsubsection{Basic Alignment}
Alignment works with two main methods: a coordinate where the axis shall be drawn and an ``anchor'' inside of the axis which shall be drawn at this particular coordinate. This methodology is common for each \Tikz\ node -- and an axis is nothing but a (special) \Tikz\ node. The coordinate can be specified using the \declaretext{at} key, while the anchor can be specified with the \declaretext{anchor} key. In most cases, it is sufficient to provide only an anchor -- unless one needs more than one axis in the same picture environment.

\begin{pgfplotskey}{at=\marg{coordinate expression}}
Assigns a position for the complete axis image. This option works similarly to the |at|-option of |\node[at=|\marg{coordinate expression}|]|, see~\cite{tikz}. The common syntax is |at={|\parg{x,y}|}|.

The idea is to provide an \marg{coordinate expression} where the axis will be placed. The axis' anchor will be placed at \marg{coordinate expression}.
\end{pgfplotskey}

\begin{pgfplotskey}{anchor=\marg{name} (initially south west)}
\label{option:anchor}%
This option shifts the axis horizontally and vertically such that the axis anchor (a point on the axis) is placed at canvas coordinate $(0,0)$ (this is \emph{not} the logical coordinate, it is an image coordinate). For users who are familiar with \Tikz: an axis is actually a very special node, so anchors work as in~\cite{tikz}.

Anchors are useful in conjunction with horizontal or vertical alignment of plots, see the examples below.

There are four sets of anchors available: anchors positioned on the axis rectangle, anchors on the outer bounding box and anchors which have one coordinate on the outer bounding box and the other one at a position of the axis rectangle. Finally, one can place anchors near the origin.

{%
%\pgfplotsset{every picture/.append style={background rectangle/.style={help lines},show background rectangle}}%
\pgfplotstableread{pgfplots.testplot}\plottable
\def\plot{%
	\begin{axis}[
		width=5cm,
		name=test plot,
		xlabel=$x$,
		ylabel={$y$},% = \frac 12 \cdot x^3 - 4 x^2 -16 x$},
		y label style={yshift=-15pt},
		legend style={at={(1.03,1)},anchor=north west},
		title=A test plot.
	]
		\addplot table from{\plottable};
		%\addplot coordinates {(0,0) (1,1)};
		\addlegendentry{$f(x)$}
		\addplot[red] plot[id=gnuplot_ppp,domain=-40:40,samples=120] gnuplot{10000*sin(x/3)};
		\addlegendentry{$g(x)$}
	\end{axis}
}%
\def\showit#1#2{%
	%\node[show them,#2] at (test plot.#1) {(s.#1)};
	\node[pin=#2:(s.#1),fill=black,circle,scale=0.3] at (test plot.#1) {};
}%
In more detail, we have
\tikzstyle{every pin}=[opacity=0.5,fill=yellow,rectangle,rounded corners=3pt,font=\tiny]
Anchors on the axis rectangle,
		\begin{center}
			\begin{tikzpicture}
				\plot
				\showit{north}{90}
				\showit{north west}{135}
				\showit{west}{180}
				\showit{south west}{225}
				\showit{south}{270}
				\showit{south east}{305}
				\showit{east}{0}
				\showit{north east}{45}
				\showit{center}{90}
			\end{tikzpicture}
		\end{center}
Anchors on the outer bounding box,
		\begin{center}
			\begin{tikzpicture}
				\plot
				\showit{outer north}{90}
				\showit{outer north west}{135}
				\showit{outer west}{180}
				\showit{outer south west}{225}
				\showit{outer south}{270}
				\showit{outer south east}{305}
				\showit{outer east}{0}
				\showit{outer north east}{45}
				\showit{outer center}{90}
			\end{tikzpicture}
		\end{center}
There are anchors which have one coordinate on the outer bounding box, and one on the axis rectangle,
		\begin{center}
			\begin{tikzpicture}
				\plot
				{\pgfplotsset{every pin/.append style={pin distance=1cm}}%
				\showit{above north}{90}
				}%
				\showit{above north east}{90}
				\showit{right of north east}{0}
				\showit{right of east}{0}
				\showit{right of south east}{0}
				\showit{below south east}{-90}
				{\pgfplotsset{every pin/.append style={pin distance=1cm}}%
				\showit{below south}{-90}
				}%
				\showit{below south west}{-90}
				\showit{left of south west}{180}
				\showit{left of west}{180}
				\showit{left of north west}{180}
				\showit{above north west}{90}
			\end{tikzpicture}
		\end{center}
And finally, we have origin anchors which are especially useful when axis lines pass through the origin,
		\begin{center}
			\begin{tikzpicture}
					\begin{axis}[
						name=test plot,
						axis x line=center,
						axis y line=center,
						enlargelimits=false,
						minor tick num=3,
						tick style={semithick},
						tick align=center,
						xlabel=$x$,
						ylabel=$y$,
						every axis x label/.style={at={(current axis.right of origin)},anchor=north east},
						every axis y label/.style={at={(current axis.above origin)},anchor=north east},
						inner axis line style={->},
					]
					\addplot+[domain=-2:5] {20*x};
					\end{axis}
				{\pgfplotsset{every pin/.append style={pin distance=1cm}}%
				\showit{above origin}{45}
				}%
				\showit{right of origin}{45}
				{\pgfplotsset{every pin/.append style={pin distance=1cm}}%
				\showit{below origin}{0}
				}%
				\showit{left of origin}{135}
				\showit{origin}{135}
			\end{tikzpicture}
		\end{center}
The default value is |anchor=south west|. You can use anchors in conjunction with the \Tikz\ |baseline| option and/or |\begin{pgfinterruptboundingbox}| to perform alignment.

\paragraph{Remarks:} Each of the anchors on the axis rectangle has an equivalent to a coordinate in the \declaretext{axis description cs} described in section~\ref{pgfplots:sec:axis:description:cs}. That means the first set of anchors actually lives on the \emph{tight bounding box around the axis} (without any ticks or descriptions). The |south west| anchor will always be the lower left corner of this bounding box, even in case of a rotated or skewed coordinate system\footnote{Note that this is only true for versions since 1.3.}. Similar statements hold for the other anchors.
}

\subsubsection{Vertical alignment with \texttt{baseline}}
\label{sec:align}%
The default axis anchor is |south west|, which means that the picture coordinate $(0,0)$ is the lower left corner of the axis. As a consequence, the \Tikz\ option ``|baseline|'' allows vertical alignment of adjacent plots:
\begin{codeexample}[]
\pgfplotsset{domain=-1:1}
\begin{tikzpicture}
	\begin{axis}[xlabel=A normal sized $x$ label]
	\addplot[smooth,blue,mark=*] {x^2};
	\end{axis}
\end{tikzpicture}%
\hspace{0.15cm}
\begin{tikzpicture}
	\begin{axis}[xlabel={$\displaystyle \sum_{i=0}^N n_i $ }]
	\addplot[smooth,blue,mark=*] {x^2};
	\end{axis}
\end{tikzpicture}
\end{codeexample}

\begin{codeexample}[]
\pgfplotsset{domain=-1:1}
\begin{tikzpicture}[baseline]
	\begin{axis}[xlabel=A normal sized $x$ label]
	\addplot[smooth,blue,mark=*] {x^2};
	\end{axis}
\end{tikzpicture}%
\hspace{0.15cm}
\begin{tikzpicture}[baseline]
	\begin{axis}[xlabel={$\displaystyle \sum_{i=0}^N n_i $ }]
	\addplot[smooth,blue,mark=*] {x^2};
	\end{axis}
\end{tikzpicture}
\end{codeexample}
The |baseline| option configures \Tikz\ to shift position $y=0$ to the text's baseline and the |south west| anchor shifts the axis such the $y=0$ is at the lower left axis corner.

\subsubsection{Horizontal Alignment}
\label{sec:halign}%
If you place multiple |axes| into a single |tikzpicture| and use the `|anchor|'-option, you can control horizontal alignment:
\begin{codeexample}[]
\begin{tikzpicture}
\pgfplotsset{every axis/.append style={
cycle list={
	{red,only marks,mark options={
		fill=red,scale=0.8},mark=*},
	{black,only marks,mark options={
		fill=black,scale=0.8},mark=square*}}}}

\begin{axis}[width=4cm,scale only axis,
	name=main plot]
\addplot file 
	{plotdata/pgfplots_scatterdata1.dat};
\addplot file 
	{plotdata/pgfplots_scatterdata2.dat};
\addplot[blue] coordinates {
	(0.093947,	-0.011481)
	(0.101957,	0.494273)
	(0.109967,	1.000027)};
\end{axis}

% introduce named coordinate:
\path (main plot.below south west) ++(0,-0.1cm) 
	coordinate (lower plot position);

\begin{axis}[at={(lower plot position)},
	anchor=north west,
	width=4cm,scale only axis,height=0.8cm,
	ytick=\empty]

\addplot file 
  {plotdata/pgfplots_scatterdata1_latent.dat};
\addplot file 
  {plotdata/pgfplots_scatterdata2_latent.dat};
\end{axis}
\end{tikzpicture}
\end{codeexample}


\subsubsection{Bounding box restrictions}
Bounding box restrictions can be realized with several methods of \PGF:
\begin{enumerate}
	\item The |overlay| option,
	\item The |pgfinterruptboundingbox| environment,
	\item The |\useasboundingbox| path.
\end{enumerate}
\begin{key}{/tikz/overlay}
\index{Bounding Box Control!Excluding Image Parts}
	A special key of \PGF\ which disables bounding box updates for (parts of) the image. The effect is that those parts are an ``overlay'' over the document.

	For \PGFPlots, |overlay| can be useful to position legends or other axis descriptions outside of the axis~-- without affecting its size (and without affecting alignment).

For example, one may want to include only certain parts of the axis into the final bounding box. This would allow horizontal alignment (centering):
\begin{codeexample}[]
\begin{tikzpicture}%
   \begin{axis}[
      title=A title,
      ylabel style={overlay},
      yticklabel style={overlay},
      xlabel={$x$},
      ylabel={$y$},
      legend style={at={(0.5,0.97)},
         anchor=north,legend columns=-1},
      domain=-2:2
   ]
   \addplot {x^2};
   \addplot {x^3};
   \addplot {x^4};
   \legend{$x^2$,$x^3$,$x^4$}
   \end{axis}
\end{tikzpicture}%
\end{codeexample}
\noindent Now, the left axis descriptions ($y$ label and $y$ ticks) stick out of the bounding box.
	
The following example places a legend somewhere without affecting the bounding box.
\begin{codeexample}[]
\begin{tikzpicture}
   \begin{axis}[
      domain=0:6.2832,samples=200,
      legend style={
         overlay,
         at={(-0.5,0.5)},
         anchor=center},
      every axis plot post/.append style={mark=none},
      enlargelimits=false]

   \addplot {sin(deg(x)+3)+rand*0.05};
   \addplot {cos(deg(x)+2)+rand*0.05};
   \legend{Signal 1,Signal 2}
   \end{axis}
\end{tikzpicture}
\end{codeexample}

	More information about the |overlay| option can be found in the \PGF\ manual~\cite{tikz}.
\end{key}


\label{sec:bounding:box:example}%
\index{Bounding Box Control}
\index{Bounding Box Control!pgfinterruptboundingbox}
{%
An alternative to |overlay| is shown below: the figure has a truncated bounding box with is shown using |\fbox|.
\begin{codeexample}[]
\setlength{\fboxsep}{0pt}%
\fbox{%
\begin{tikzpicture}%
	\begin{pgfinterruptboundingbox}
	\begin{axis}[
		name=my plot,
		title=A title,
		xlabel={$x$},
		ylabel={$y$},
		legend style={at={(0.5,0.97)},
			anchor=north,legend columns=-1},
		domain=-2:2
	]
	\addplot {x^2};
	\addplot {x^3};
	\addplot {x^4};
	\legend{$x^2$,$x^3$,$x^4$}
	\end{axis}
	\end{pgfinterruptboundingbox}

	\useasboundingbox 
			  (my plot.below south west)
	rectangle (my plot.above north east);
\end{tikzpicture}%
}%
\end{codeexample}%
}%
The |pgfinterruptboundingbox| environment does not include its content into the image's bounding box, and |\useasboundingbox| sets the pictures bounding box to the following argument (see~\cite{tikz}).

\end{pgfplotskey}

\subsubsection{Alignment In Array Form (Subplots)}
\index{Subplots}%
\index{Alignment!Subplots}%
\index{Alignment!Array}%
\index{array!Array Alignment}%
Sometimes alignment in array form is desired. While it is possible to use (for example) |tabular| combined with the vertical and horizontal alignment methods discussed above, it might be better to use a \Tikz\ \declaretext{matrix}.

A \Tikz\ matrix is some sort of ``graphical'' table. It knows everything about picture alignment and it has more flexibility than |tabular|. The complete documentation of a \Tikz\ matrix is beyond the scope of this manual, please refer to \cite{tikz} for details. But we provide an example here:
\begin{codeexample}[]
\begin{tikzpicture}
	\matrix {
		\begin{axis}
			\addplot {x};
		\end{axis}
		&
		% differently large labels are aligned automatically:
		\begin{axis}[ylabel={$f(x)=x^2$},ylabel style={font=\Huge}]
			\addplot {x^2};
		\end{axis}
		\\
		%
		\begin{axis}[xlabel=$x$,xlabel style={font=\Huge}]
			\addplot {x^3};
		\end{axis}
		&
		\begin{axis}
			\addplot {x^4};
		\end{axis}
		\\
	};
\end{tikzpicture}
\end{codeexample}
\noindent So, a matrix is a picture element inside of |tikzpicture|. Its cells are separated by `|&|' as in tabular (or, if `|&|' causes problems, with \declaretext{\textbackslash pgfmatrixnextcell}). Its rows are separated by `|\\|'. Each cell is aligned using the cells' anchor. Since, by default, the anchor of an axis is placed at the lower left corner, the example above is completely aligned, without the need for any bounding box modifications -- even the labels are aligned correctly. If another anchor shall be used, simply place 
\begin{codeexample}[code only]
\pgfplotsset{anchor=....}
\matrix {
  ...
};
\end{codeexample}
\noindent in front of the matrix. This will use the same configuration for every sub-plot.

\paragraph{Attention:} Unfortunately, the array alignment with |\matrix| is \emph{incompatible} with legends. A legend is also a matrix and, unfortunately, \Tikz\ matrizes can't be nested. Of course, this does not affect the manually created legends by means of |\label| and |\ref|, see section~\ref{pgfplots:legend:labelref} for details.

\subsubsection{Miscellaneous for Alignment}

\begin{predefinednode}{current axis}
	A node which refers to the current axis or the last typeset axis.

	You can use this node in axis descriptions, for example to place axis labels or titles.

	\paragraph{Remark:} If you use |current axis| inside of axis descriptions, the ``current axis'' is not yet finished. That means you \emph{can't use any outer anchor} inside of axis descriptions.

	It is also possible to use |current axis| in any drawing or plotting commands inside of an axis (but no outer anchor as these are not defined when drawing commands are processed). This usage is similar to the |axis description cs|.
\end{predefinednode}

\subsection{Closing Plots (Filling the Area Under Plots)}
\begin{command}{\closedcycle}
	Provide |\closedcycle| as \meta{trailing path commands} after |\addplot| to draw a closed line from the last plot coordinate to the first one.
	
	Use |\closedcycle| whenevery you intend to fill the area under a plot.

\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}
	\addplot {x^2+2} \closedcycle;
	\end{axis}
\end{tikzpicture}
\end{codeexample}

\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}
	\addplot+[fill] {x^2+2} \closedcycle;
	\end{axis}
\end{tikzpicture}
\end{codeexample}
	In case of stacked plots, |\closedcycle| connects the current plot with the previous plot instead of connecting with the $x$~axis\footnote{The implementation for stacked plots requires some additional logic to determine the filled area: \lstinline{\\closedcycle} will produce a |plot coordinates| command with \emph{reversed} coordinates of the previous plot. This is usually irrelevant for end users, but it assumes that the plot's type is symmetric. Since constant plots are inherently unsymmetric, \lstinline{\\closedcycle} will use \texttt{const plot mark right} as reversed sequence for \texttt{const plot mark left}.}.
\begin{codeexample}[]
\begin{tikzpicture}
	\begin{axis}[stack plots=y]
	\addplot+[fill] coordinates 
		{(0,1) (1,1) (2,2) (3,2)} \closedcycle;
	\addplot+[fill] coordinates 
		{(0,1) (1,1) (2,2) (3,2)} \closedcycle;
	\end{axis}
\end{tikzpicture}
\end{codeexample}
\end{command}

\subsection{Symbolic Coordinates and User Transformations}
\label{pgfplots:sec:symbolic:coords}
\PGFPlots\ supports user transformations which can be applied to input and output coordinates. Suppose the plot shall display days versus account statements over time. Then, one wants to visualize date versus credit balance. But: dates need to be transformed to numbers before doing so! Furthermore, tick labels shall be displayed as dates as well. This, and more general transformations, can be realized using the |x coord trafo| and |y coord trafo| keys.

\paragraph{Remark:} This section applies to users who want to have non-standard input \emph{coordinates}. If you have normal numbers which don't need to be transformed and you like to have special symbols as tick labels, you should consider using the \declaretext{[xyz]ticklabels} key described on page~\pageref{pgfplots:key:xticklabels}.

\begin{pgfplotsxycodekeylist}{
	\x\ coord trafo,
	\x\ coord inv trafo}
	These code keys allow arbitrary coordinate transformations which are applied to input coordinates and output tick labels.

	The |x coord trafo| and |y coord trafo| command keys take one argument which is the input coordinate. They are expected to set |\pgfmathresult| to the final value.

	At this level, the input coordinate is provided as it is found in the |\addplot| statement. For example, if $x$ coordinates are actually of the form \meta{year}-\meta{month}-\meta{day}, for example |2008-01-05|, then a useful coordinate transformation would transform this string into a number (see below for a predefined realization).

	In short, \emph{no} numerics has been applied to input coordinates when this transformation is applied\footnote{Of course, if coordinates have been generated by gnuplot or \pgfname, this does no longer hold.}.

	The input coordinate transformation is applied to
	\begin{itemize}
		\item any input coordinates (specified with |\addplot| or |axis cs|),
		\item any user-specified |xtick| or |ytick| options,
		\item any user-specified |extra x ticks| and |extra y ticks| options,
		\item any user-specified axis limits like |xmin| and |xmax|.
	\end{itemize}

	The output coordinate transformation |x coord inv trafo| is applied to tick positions just before evaluating the |xticklabel| and |yticklabel| keys. The argument to |x coord inv trafo| is a fixed point number (which may have trailing zeros after the period).
	The tick label code may use additional macros defined by the inverse transformation.

	Remark: \PGFPlots\ will continue to produce tick positions as usual, no extra magic is applied. It may be necessary to provide tick positions explicitly if the default doesn't respect the coordinate space properly.

	The initial value of these keys is
\begin{codeexample}[code only]
\pgfplotsset{
	x coord trafo/.code={},
	x coord inv trafo/.code={}}
\end{codeexample}
	\noindent which simply disables the transformation (the same for $y$, of course).

	\paragraph{Remark:} It might be necessary to set
\begin{codeexample}[code only]
\pgfplotsset{
	/pgfplots/xticklabel={\tick},
	/pgfplots/scaled x ticks=false
}
\end{codeexample}
	\noindent in order to avoid number formatting routines on |\tick| or numerics for tick scale methods. This is done automatically by the predefined symbolic coordinate styles (see below).
\end{pgfplotsxycodekeylist}

\subsubsection{String Symbols as Input Coordinates}
It is possible to provide a string dictionary to \PGFPlots. An input coordinate can then use any symbol provided in that dictionary.
\begin{pgfplotsxykeylist}{symbolic \x\space coords=\marg{dictionary}}%
	A styles which sets |x coord trafo| and |x coord inv trafo| (or the respective |y| or |z| variants) such that any element in \marg{dictionary} is a valid input coordinate. The \marg{dictionary} can be a comma separated list or a list terminated with `|\\|'. In both case, white spaces are considered to be part of the names (use `|%|' at end of lines).

	The dictionary will assign integer numbers to every element. These integers are used internally for arithmetics. Finally, the inverse transformation takes a fixed point number and maps it to the nearest integer, and that integer is mapped into the dictionary.
\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[symbolic x coords={a,b,c,d,e,f,g,h,i}]
	\addplot+[smooth] coordinates {
		(a,42)
		(b,50)
		(c,80)
		(f,60)
		(g,62)
		(i,90)};
\end{axis}
\end{tikzpicture}
\end{codeexample}
	
	The effect of the transformation is simply that input coordinates can be elements of the dictionary and tick labels will be chosen out of this dictionary as well.
\end{pgfplotsxykeylist}

\subsubsection{Dates as Input Coordinates}
\label{pgfplots:sec:date:coords}
The already mentioned application of using dates as input coordinates has been predefined, together with support for hours and minutes. It relies on the \pgfname\ calendar library which converts dates to numbers in the julian calendar. Then, one coordinate unit is one day.

\begin{tikzlibrary}{pgfplots.dateplot}
	Loads the coordinate transformation code.
\end{tikzlibrary}

\begin{stylekey}{/pgfplots/date coordinates in=\mchoice{x,y}}
	Installs |x coord trafo| and |x coord inv trafo| (or the respective $y$ variant) such that ISO dates of the form \meta{year}|-|\meta{month}|-|\meta{day} are accepted. For example, |2006-02-28| will be converted to an ``appropriate'' integer using the julian calender. Input coordinates may be of the form
		
		\meta{year}|-|\meta{month}|-|\meta{day}

	\noindent or they may contain times as

		\meta{year}|-|\meta{month}|-|\meta{day} \meta{hour}|:|\meta{minute}.

	The result of the transformation are numbers where one unit is one day and times are fractional numbers.

	The transformation is realized using the \pgfname-calendar module, see \cite[Calendar Library]{tikz}. This reference also contains more information about extended syntax options for dates.

	The inverse transformation provides the following macros which are available during tick label evaluation (i.e. when used inside of |xticklabel| or |yticklabel|):
	\begin{itemize}
		\item |\year| expands to the year component,
		\item |\month| expands to the month component,
		\item |\day| expands to the day component,
		\item |\hour| expands to the hour component (using two digits),
		\item |\Hour| expands to the hour component (but omits leading zeros),
		\item |\minute| expands to the minute component (two digits),
		\item |\Minute| expands to the minute component (omits leadings zeros),
		\item |\lowlevel| expands to the low level number representing the tick,
		\item |\second| will always be |00|.
	\end{itemize}
	This allows to use |\day.\month.\year| or |\day. \hour:\minute| inside of |xticklabel|, for example.

	A complete example (with fictional data) is shown below.
\pgfplotsset{anchor=center,/tikz/every picture/.append style={baseline}}
% \usetikzlibrary{pgfplots.dateplot}\usepackage{eurosym}
\begin{codeexample}[]
% requires \usetikzlibrary{pgfplots.dateplot} !

\pgfplotstabletypeset[string type]{plotdata/accounts.dat}

\begin{tikzpicture}
	\begin{axis}[
		date coordinates in=x,
		xticklabel={\day.\month.},
		xlabel={2008},
		stack plots=y,
		yticklabel={\pgfmathprintnumber{\tick}\EUR{}}, % <- requires \usepackage{eurosym}
		ylabel=Total credit,
		ylabel style={yshift=10pt},
		legend style={
			at={(0.5,-0.3)},anchor=north,legend columns=-1}]
		
	\addplot table[x=date,y=account1] {plotdata/accounts.dat};
	\addplot table[x=date,y=account2] {plotdata/accounts.dat};
	\addplot table[x=date,y=account3] {plotdata/accounts.dat};
	\legend{Giro,Tagesgeld,Sparbuch}
	\end{axis}
\end{tikzpicture}
\end{codeexample}

% \usetikzlibrary{pgfplots.dateplot}\usepackage{eurosym}
\begin{codeexample}[]
% requires \usetikzlibrary{pgfplots.dateplot} !
\begin{tikzpicture}
  \begin{axis}[
    date coordinates in=x,
    xtick=data,
    xticklabel style=
		{rotate=90,anchor=near xticklabel},
    xticklabel=\day. \hour:\minute,
    date ZERO=2009-08-18,% <- improves precision!
  ]
  \addplot coordinates {
    (2009-08-18 09:00,  050)
    (2009-08-18 12:00,  100)
    (2009-08-18 15:00,  100)
    (2009-08-18 18:35,  100)
    (2009-08-18 21:30,  040)
    (2009-08-19,        020)
    (2009-08-19 3:00,   000)
    (2009-08-19 6:0,    035)
  };
  \end{axis}
\end{tikzpicture}
\end{codeexample}

\paragraph{Attention:} If you intend to use hours and minutes, you should \emph{always} provide the |date ZERO| to maintain adequate precision!
\end{stylekey}

\begin{pgfplotskey}{date ZERO=\meta{year}-\meta{month}-\meta{day} (initially 2006-01-01)}
	A technical key which defines the $0$ coordinate of |date coordinates in|. Users will never see the resulting numbers, so one probably never needs to change it. However, the resulting numbers may become very large and a mantisse of 6 significant digits may not be enough to get accurate results. In this case, |date ZERO| should be set to a number which falls into the input date range.
\end{pgfplotskey}


\subsection{Miscellaneous Options}
\label{pgfplots:misc}

\begin{pgfplotskey}{disablelogfilter=\mchoice{true,false} (initally false, default true)}
Disables numerical evaluation of $\log(x)$ in \TeX. If you specify this option, any plot coordinates and tick positions must be provided as $\log(x)$ instead of $x$. This may be faster and -- possibly -- more accurate than the numerical log. The current implementation of $\log(x)$ normalizes~$x$ to $m\cdot 10^e$ and computes
\[ \log(x) = \log(m) + e \log(10) \]
where $y = \log(m)$ is computed with a newton method applied to $\exp(y) - m$. The normalization involves string parsing without \TeX-registers. You can savely evaluate $\log(1\cdot 10^{-7})$ although \TeX-registers would produce an underflow for such small numbers. 
\end{pgfplotskey}

\label{sec:disabledatascaling}%
\begin{pgfplotskey}{disabledatascaling=\mchoice{true,false} (initally false, default true)}
\index{Accuracy!Data Transformation}%
\index{Errors!dimension too large}%
Disables internal re-scaling of input data. Normally, every input data like plot coordinates, tick positions or whatever, are parsed without using \TeX's limited number precision. Then, a transformation like 
	\[ T(x) = 10^{q-m} \cdot x - a \]
is applied to every input coordinate/position where $m$ is ``the order of $x$'' base~$10$. Example: $x=1234 = 1.234\cdot 10^3$ has order~$m=4$ while $x=0.001234 = 1.234\cdot 10^{-3}$ has order $m=-2$. The parameter~$q$ is the order of the axis' width/height.

The \textbf{effect} of the transformation is that your plot coordinates can be of \emph{arbitrary magnitude} like $0.0000001$ and $0.0000004$. For these two coordinates, \PGFPlots\ will use 100pt and 400pt internally. The transformation is quit fast since it relies only on period shifts. This scaling allows precision beyond \TeX's capabilities.
%\footnote{Please note that while plot coordinates can be of quite large magnitude like $10^12$ or $10^{-9}$, \PGFPlots\ still uses \TeX-registers internally (the math parser of \PGF). If your axis interval is $[1234567.8, 1234567.9]$ or something like that, }.

The option ``|disabledatascaling|'' disables this data transformation. This has two consequences: first, coordinate expressions like \parg{{\normalfont\texttt{axis cs:}}x,y} have the same effect like \parg{x,y}, no re-scaling is applied. Second, coordinates are restricted to what \TeX\ can handle\footnote{Please note that the axis' scaling requires to compute $1/( x_\text{max} - x_{\text{min}} )$. The option |disabledatascaling| may lead to overflow or underflow in this context, so use it with care! Normally, the data scale transformation avoids this problem.}.

So far, the data scale transformation applies only to normal axis (logarithmic scales do not need it). 
\end{pgfplotskey}


\begin{pgfplotsxycodekeylist}{\x\ filter,filter point}
The code keys |x filter| and |y filter| allow coordinate filtering which are based on a \emph{single} coordinate. A coordinate filter gets an input coordinate as |#1|, applies some operation and writes the result into the macro |\pgfmathresult|. If |\pgfmathresult| is empty afterwards, the coordinate is discarded. You can also set |\pgfmathresult| to |nan| or |inf| in which case the coordinate can be either discarded (if \declaretext{unbounded coords=discard} is set) or the plot can be interrupted (the case \declaretext{unbounded coords=jump}).

The \declaretext{filter point}|.code| filter allows filter dependend on all components forming a complete point ($x$, $y$ and $z$); it is described below.

It is allowed if filters do not change |\pgfmathresult|. In this case, the unfiltered coordinate will be used.

Coordinate filters are useful in automatic processing system, where \PGFPlots\ is used to display automatically generated plots. You may not want to filter your coordinates by hand, so these options provide a tool to do this automatically.

The following filter adds $0.5$ to every $x$ coordinate.
\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[x filter/.code=
	{\pgfmathadd{#1}{0.5}}]
\addplot coordinates {
	(4,0)
	(6,1)
};
\end{axis}
\end{tikzpicture}
\end{codeexample}
Please refer to~\cite[pgfmath manual]{tikz} for details about the math engine of \PGF. Please keep in mind that the math engine works with limited \TeX\ precision.

During evaluation of the filter, the macro |\coordindex| contains the number of the current coordinate (starting with~$0$). Thus, the following filter discards all coordinates after the $5$th and before the $10$th.
\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[
	samples=20,
	x filter/.code={
		\ifnum\coordindex>4
			\ifnum\coordindex<11
				\def\pgfmathresult{}
			\fi
		\fi
	}]
\addplot {x^2};
\end{axis}
\end{tikzpicture}
\end{codeexample}
There is also a style key which simplifies selection by index, see below.

	\PGFPlots\ invokes the filter with argument |#1| set to the input coordinate. For $x$-filters, this is the $x$-coordinate as it is specified to |\addplot|, for $y$-filters it is the $y$-coordinate.

	If the corresponding axis is logarithmic, |#1| is the \emph{logarithm} of the coordinate as a real number, for example |#1=4.2341|.

	The arguments to coordinate filters are usually as they have been found in the input data (i.e.\ no transformation or number parsing has been done at this stage). The ``usually'' has two exceptions: first, for logarithmic axes, the \emph{log} of the argument is supplied.  Second, any high level coordinate maps (which may be used to map dates to numbers or string to numbers or so) are applied (meaning that the |#1| argument is a number).

	The |filter point| key is more technical. It doesn't take an argument: its arguments are given in terms of the |pgfkeys| variables |/data point x|, |/data point y| and |/data point z|. It may change its coordinates using |\pgfkeyssetvalue{/data point x}|\marg{the new value}; access to variables can be get with |\pgfkeysvalueof{/data point/x}| or, if the argument shall be written into a macro, with |\pgfkeysgetvalue|. This filter is evaluated after the other ones.
\end{pgfplotsxycodekeylist}

\begin{stylekey}{/pgfplots/skip coords between index=\marg{begin}\marg{end}}
	A style which appends an |x filter| which discards selected coordinates. The selection is done by index where indexing starts with~$0$, see |\coordindex|. Every coordinate with index $\meta{begin} \le i < \meta{end}$ will be skipped.
\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[
	samples=20,
	skip coords between index={5}{11},
	skip coords between index={15}{18}]

\addplot {x^2};
\end{axis}
\end{tikzpicture}
\end{codeexample}
\end{stylekey}

\begin{pgfplotskey}{each nth point=\marg{integer}}
	A style which appends an |x filter| which discards all but each $n$th input coordinate.
\index{Downsampling}
\end{pgfplotskey}

\begin{pgfplotsxykey}{restrict \x\space to domain=\meta{min}|:|\meta{max}}
\label{key:restrict:x:to:domain}
	Appends $x$ (or $y$ or $z$) coordinate filters which set the respective coordinate to |-inf| if it is below \meta{min} and to |+inf| if it is above \meta{max}.

	Furthermore, it sets the |unbounded coords=jump| key which leads to interrupted plots.
\begin{codeexample}[]
\begin{tikzpicture}
\begin{axis}[
	restrict y to domain=-10:10,
	samples=1000,
	% some fine tuning for the display:
	width=10cm, height=210pt,
	xmin=-4.7124, xmax=4.7124,
	xtick={-4.7124,-1.5708,...,10},
	xticklabels={$-\frac32 \pi$,$-\pi/2$,$\pi/2$,$\frac32 \pi$},
	axis x line=center,
	axis y line=center]

\addplot[blue] gnuplot[id=tangens,domain=-1.5*pi:1.5*pi] {tan(x)};
\legend{$\tan(x)$}
\end{axis}
\end{tikzpicture}
\end{codeexample}
\end{pgfplotsxykey}

\begin{pgfplotskey}{filter discard warning=\mchoice{true,false} (initially true)}
	Issues a notification in your logfile whenever coordinate filters discard coordinates.
\end{pgfplotskey}

\begin{pgfplotskey}{execute at begin plot=\marg{commands}}
This axis option allows to invoke \marg{commands} at the beginning of each |\addplot| command. The argument \marg{commands} can be any \TeX\ content.

You may use this in conjunction with |x filter=...| to reset any counters or whatever. An example would be to change every $4$th coordinate.
\end{pgfplotskey}

\begin{pgfplotskey}{execute at end plot=\marg{commands}}
This axis option allows to invoke \marg{commands} after each |\addplot| command. The argument \marg{commands} can be any \TeX\ content.
\end{pgfplotskey}

\begin{pgfplotskey}{forget plot=\marg{true,false} (initially false)}
\label{pgfplots:forgetplot}
	Allows to include plots which are not remembered for legend entries, which do not increase the number of plots and which are not considered for cycle lists.

	A forgotten plot can be some sort of decoration which has a separate style and does not influence the axis state, although it is processed as any other plot.
	Provide this option to |\addplot| as in the following example.
\begin{codeexample}[]
\begin{tikzpicture}
	\begin{loglogaxis}[
		table/x=Basis,
		table/y={L2/r},
		xlabel=Degrees of Freedom,
		ylabel=relative Error,
		title=New Experiments (old in gray),
		legend entries={$e_1$,$e_2$,$e_3$}
	]
	\addplot[black!15,forget plot] 
		table {plotdata/oldexperiment1.dat};
	\addplot[black!15,forget plot] 
		table {plotdata/oldexperiment2.dat};
	\addplot[black!15,forget plot] 
		table {plotdata/oldexperiment3.dat};
	\addplot table {plotdata/newexperiment1.dat};
	\addplot table {plotdata/newexperiment2.dat};
	\addplot table {plotdata/newexperiment3.dat};
	\end{loglogaxis}
\end{tikzpicture}
\end{codeexample}
	Since forgotten plots won't increase the plot index, they will use the same |cycle list| entry as following plots. This can be used to ``interrupt'' plots as is described in section~\ref{pgfplots:interrupt}.
\index{Interrupted Plots}

	The style |every forget plot| can be used to configure styles for each such plot. Please note that |every plot no |\meta{index} styles are not applicable here.

	A forgotten plot will be stacked normally if |stack plots| is enabled!
\end{pgfplotskey}

\begin{pgfplotscodekey}{before end axis}
Allows to insert \marg{commands} just before the axis is ended. This option takes effect inside of the clipped area.
\begin{codeexample}[]
\pgfplotsset{every axis/.append style={
	before end axis/.code={
		\fill[red] (axis cs:1,10) circle(5pt);
		\node at (axis cs:-4,10) 
			{\large This text has been inserted 
			 using \texttt{before end axis}.};
	}}}
\begin{tikzpicture}
	\begin{axis}
	\addplot {x^2};
	\end{axis}
\end{tikzpicture}
\end{codeexample}
\end{pgfplotscodekey}

\begin{pgfplotscodekey}{after end axis}
Allows to insert \marg{commands} right after the end of the clipped drawing commands. While |befor end axis| has the same effect as if \marg{commands} had been placed inside of your axis, |after end axis| allows to access axis coordinates without being clipped.
\begin{codeexample}[]
\pgfplotsset{every axis/.append style={
	after end axis/.code={
		\fill[red] (axis cs:1,10) circle(5pt);
		\node at (axis cs:-4,10) 
			{\large This text has been inserted using \texttt{after end axis}.};
	}}}
\begin{tikzpicture}
	\begin{axis}
	\addplot {x^2};
	\end{axis}
\end{tikzpicture}
\end{codeexample}
\end{pgfplotscodekey}

\begin{pgfplotskey}{clip marker paths=\mchoice{true,false} (initially false)}
	The initial choice |clip marker paths=false| causes markers to be drawn \emph{after} the clipped region. Only their positions will be clipped. As a consequence, markers will be drawn completely, or not at all. The value |clip marker paths=true| is here for backwards compatibility: it does not introduce special marker treatment, so markers may be drawn partially if they are close to the clipping boundary\footnote{Please note that clipped marker paths may be slightly faster during \TeX\ compilation.}.
\end{pgfplotskey}

\begin{pgfplotskey}{clip=\mchoice{true,false} (initially true)}
	Whether any paths inside an axis shall be clipped.
\end{pgfplotskey}

\begin{pgfplotskey}{axis on top=\mchoice{true,false} (initially false)}
	If set to |true|, axis lines, ticks, tick labels and grid lines will be drawn on top of plot graphics.
\begin{codeexample}[]
\begin{tikzpicture}
    \begin{axis}[
		axis on top=true,
		axis x line=middle,
		axis y line=middle]
    \addplot+[fill] {x^3} \closedcycle;
    \end{axis}
\end{tikzpicture}
\end{codeexample}

\begin{codeexample}[]
\begin{tikzpicture}
    \begin{axis}[
		axis on top=false,
		axis x line=middle,
		axis y line=middle]
    \addplot+[fill] {x^3} \closedcycle;
    \end{axis}
\end{tikzpicture}
\end{codeexample}
Please note that this feature does not affect plot marks. I think it looks unfamiliar if plot marks are crossed by axis descriptions.
\end{pgfplotskey}

\begin{key}{/pgf/fpu=\marg{true,false} (initially true)}
\index{Precision}
	This key activates or deactivates the floating point unit. If it is disabled (|false|), the core \PGF\ math engine written by Mark Wibrow and Till Tantau will be used for |plot expression|.
	However, this engine has been written to produce graphics and is not suitable for scientific computing. It is limited to fixed point numbers in the range $\pm 16384.00000$.

	If the |fpu| is enabled (|true|, the initial configuration) the high-precision floating point library of \PGF\ written by Christian Feuers\"anger will be used. It offers the full range of IEEE double precision computing in \TeX. This FPU is also part of \PGFPlotstable, and it is activated by default for |create col/expr| and all other predefined mathematical methods.

	Use
\begin{codeexample}[code only]
\pgfkeys{/pgf/fpu=false}
\end{codeexample}
	\noindent in order to de-activate the extended precision. If you prefer using the |fp| (fixed point) package, possibly combined with Mark Wibrows corresponding \PGF\ library, the |fpu| will be deactivated automatically. Please note, however, that |fp| has a smaller data range (about $\pm 10^{17}$) and may be slower.
\end{key}

\subsection{Miscellaneous Commands}
\begin{command}{\autoplotspeclist}
This command should no longer be used, although it will be kept as technical implementation detail. Please use the `|cycle list|' option, section~\ref{sec:cycle:list}.
\end{command}

\begin{command}{\pgfmathlogtologten\meta{number}}
Assigns the result of $\meta{number}/\log(10)$ to |\pgfmathresult|.
\end{command}

\begin{command}{\logten}
Expands to the constant $\log(10)$. Useful for logplots because $\log(10^i) = i\log(10)$. This command is only available inside of an \Tikz-picture.
\end{command}

\begin{command}{\pgfmathprintnumber\marg{number}}
Generates pretty--printed output\footnote{This method was previously \texttt{\textbackslash prettyprintnumber}. It's functionality has been included into \PGF\ and the old command is now deprecated.} for \marg{number}. This method is used for every tick label.

The number is printed using the current number printing options, see section~\ref{sec:number:printing} for the different number styles, rounding precision and rounding methods.
\end{command}

\begin{command}{\plotnum}
	Inside of |\addplot| or any associated style, option or command, |\plotnum| expands to the current plot's number, starting with~$0$.
\end{command}

\begin{command}{\numplots}
	Inside of any of the axis environments, associated style, option or command, |\numplots| expands to the total number of  plots.
\end{command}

\begin{command}{\coordindex}
	Inside of an |\addplot| command, this macro expands to the number of the actual coordinate (starting with~$0$).

	It is useful together with |x filter| or |y filter| to (de-)select coordinates.
\end{command}

\begin{command}{\pgfplotstableread\marg{file}}
	Please refer to the manual of \PGFPlotstable, |pgfplotstable.pdf|, which is part of the \PGFPlots-bundle.
\end{command}
\begin{command}{\pgfplotstabletypeset\marg{\textbackslash macro}}
	Please refer to the manual of \PGFPlotstable, |pgfplotstable.pdf|, which is part of the \PGFPlots-bundle.
\end{command}
