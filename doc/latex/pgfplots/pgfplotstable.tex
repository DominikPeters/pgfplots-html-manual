%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Package pgfplots.sty documentation. 
%
% Copyright 2007/2008 by Christian Feuersaenger.
%
% This program is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program.  If not, see <http://www.gnu.org/licenses/>.
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\input{pgfplots.preamble.tex}

\usepackage{array}
\usepackage{colortbl}
\usepackage{booktabs}
\usepackage{eurosym}

\pgfqkeys{/codeexample}{%
	every codeexample/.style={
		width=4cm,
		/pgfplots/every axis/.append style={legend style={fill=graphicbackground}}
	},
	narrow/.style={width=7cm},
	tabsize=4,
}

%\pgfplotstableset{debug=true}

\title{%
	Manual for Package \PGFPlotstable\\
	{\small Component of \PGFPlots, Version \pgfplotsversion}\\
	{\small\href{http://sourceforge.net/projects/pgfplots}{http://sourceforge.net/projects/pgfplots}}}

\begin{document}
\maketitle
\begin{abstract}%
	This package reads tab-separated numerical tables from input and generates code for pretty-printed \LaTeX-tabulars. It rounds to the desired precision and prints it in different number formatting styles.
\end{abstract}
\tableofcontents
\section{Introduction}
\PGFPlotstable\ is a lightweight sub-package of \PGFPlots\ which employs its table input methods and the number formatting techniques to convert tab-separated tables into tabulars.

Its input is a text file containing space separated rows, possibly starting with column names. Its output is a \LaTeX\ tabular\footnote{Please see the remarks in section~\ref{sec:pgfplotstable:context} for plain \TeX\ and Con\TeX t.} which contains selected columns of the text table, rounded to the desired precision, printed in the desired number format (fixed point, integer, scientific etc.).

It is used with
% NO GALLERY
\begin{codeexample}[code only]
\usepackage{pgfplotstable}
% recommended:
%\usepackage{booktabs}
%\usepackage{array}
%\usepackage{colortbl}
\end{codeexample}
\noindent and requires \PGFPlots\ and \PGF\ $ \ge 2.00$ installed.

\begin{command}{\pgfplotstableset\marg{key-value-options}}
	The user interface of this package is based on key-value-options. They determine what to display, how to format and what to compute.
	
	Key-value pairs can be set in two ways:
	\begin{enumerate}
		\item As default settings for the complete document (or maybe a part of the document), using |\pgfplotstableset|\marg{options}. For example, the document's preamble may contain
% NO GALLERY
\begin{codeexample}[code only]
\pgfplotstableset{fixed zerofill,precision=3}
\end{codeexample}
			to configure a precision of $3$ digits after the period, including zeros to get exactly $3$ digits for all fixed point numbers.
		\item As option which affects just a single table. This is provided as optional argument to the respective table typesetting command, for example |\pgfplotstabletypeset|\oarg{options}\marg{file}.
	\end{enumerate}
	Both ways are shown in the examples below.

	Knowledge of |pgfkeys| is useful for a deeper insight into this package, as |.style|, |.append style| etc. are specific to |pgfkeys|. Please refer to the \PGF\ manual,~\cite[section pgfkeys]{tikz} if you want a deeper insight into  |pgfkeys|. Otherwise, simply skip over to the examples provided in this document.

	You will find key prefixes |/pgfplots/table/| and |/pgf/number format/|. These prefixes can be skipped if they are used in \PGFPlotstable; they belong to the ``default key path'' of |pgfkeys|.
\end{command}

\section{Loading and Displaying data}
\subsection{Text Table Input Format}
\PGFPlotstable\ works with plain text file tables in which entries (``cells'') are separated by a separation character. The initial separation character is ``white space'' which means ``at least one space or tab'' (see option |col sep| below). Those tables can have a header line which contains column names and most other columns typically contain numerical data.

\noindent The following listing shows |pgfplotstable.example1.dat| and is used often throughout this documentation.
\begin{codeexample}[code only]
# Convergence results
# fictional source, generated 2008
level    dof      error1            error2   info     grad(log(dof),log(error2)) quot(error1)      
1        4        2.50000000e-01    7.57858283e-01    48       0                   0      
2        16       6.25000000e-02    5.00000000e-01    25       -3.00000000e-01   4        
3        64       1.56250000e-02    2.87174589e-01    41       -3.99999999e-01   4        
4        256      3.90625000e-03    1.43587294e-01    8        -5.00000003e-01   4        
5        1024     9.76562500e-04    4.41941738e-02    22       -8.49999999e-01   4        
6        4096     2.44140625e-04    1.69802322e-02    46       -6.90000001e-01   4        
7        16384    6.10351562e-05    8.20091159e-03    40       -5.24999999e-01   4        
8        65536    1.52587891e-05    3.90625000e-03    48       -5.35000000e-01   3.99999999e+00    
9        262144   3.81469727e-06    1.95312500e-03    33       -5.00000000e-01   4.00000001e+00    
10       1048576  9.53674316e-07    9.76562500e-04    2        -5.00000000e-01   4.00000001e+00    
\end{codeexample}
Lines starting with `|%|' or `|#|' are considered to be comment lines and are ignored.

There is future support for a second header line which must start with `|$flags |' (the space is obligatory, even if the column separator is \emph{not} space!). Currently, such a line is ignored. It may be used to provide number formatting options like precision and number format.

\begin{command}{\pgfplotstabletypeset\oarg{optional arguments}\marg{file name or \textbackslash macro}}
	Loads (or acquires) a table and typesets it using the current configuration of number formats and table options.

	In case the first argument is a file name, the table will be loaded from disk. Otherwise, it is assumed to be an already loaded table (see |\pgfplotstableread| or |\pgfplotstablenew|).
\begin{codeexample}[]
\pgfplotstabletypeset{pgfplotstable.example1.dat}
\end{codeexample}

	\noindent The configuration can be customized with \meta{optional arguments}. Configuration can be done for the complete table or for particular columns (or rows).

\begin{codeexample}[]
\pgfplotstableset{% global config, for example in the preamble
	columns/dof/.style={int detect,column type=r,column name=\textsc{Dof}},
	columns/error1/.style={
		sci,sci zerofill,sci sep align,precision=1,sci superscript,
		column name=$e_1$,
	},
	columns/error2/.style={
		sci,sci zerofill,sci sep align,precision=2,sci 10e,
		column name=$e_2$,
	},
	columns/{grad(log(dof),log(error2))}/.style={
		string replace={0}{}, % erase '0'
		column name={$\nabla e_2$},
		dec sep align,
	},
	columns/{quot(error1)}/.style={
		string replace={0}{}, % erase '0'
		column name={$\frac{e_1^{(n)}}{e_1^{(n-1)}}$}
	},
	empty cells with={--}, % replace empty cells with '--'
	every head row/.style={before row=\toprule,after row=\midrule},
	every last row/.style={after row=\bottomrule}
}
\pgfplotstabletypeset[ % local config, applies only for this table
	1000 sep={\,},
	columns/info/.style={
		fixed,fixed zerofill,precision=1,showpos,
		column type=r,
	}
]
{pgfplotstable.example1.dat}
\end{codeexample}
\noindent All of these options are explained in the following sections.

Technical note: every opened file will be protocolled into your log file.
\end{command}

\begin{command}{\pgfplotstabletypesetfile\oarg{optional arguments}\marg{file name}}
	Loads the table \marg{file name} and typesets it. As of \PGFPlotstable\ 1.2, this command is an alias to |\pgfplotstabletypeset|, that means the first argument can be either a file name or an already loaded table.
\end{command}


\begin{command}{\pgfplotstableread\marg{file name}\marg{\textbackslash macro}}
	Loads the table \marg{file name} into a \TeX-macro \meta{\textbackslash macro}. This macro can than be used several times.
\begin{codeexample}[]
\pgfplotstableread{pgfplotstable.example1.dat}\table
\pgfplotstabletypeset[columns={dof,error1}]\table
\hspace{2cm}
\pgfplotstabletypeset[columns={dof,error2}]\table
\end{codeexample}

Technical note: every opened file will be protocolled into your log file.
\end{command}

\begin{command}{\pgfplotstablegetrowsof\marg{file name or \textbackslash loadedtable}}
	Defines |\pgfmathresult| to be the number of rows in a table. The argument may be either a file name or an already loaded table (the \meta{\textbackslash macro} of |\pgfplotstableread|).
\end{command}

\begin{key}{/pgfplots/table/col sep=\mchoice{space,comma,semicolon,colon,braces} (initially space)}
	Specifies the column separation character for table reading. The initial choice, |space| means ``at least one white space''. White spaces are tab stops or spaces (newlines always delimit lines).

	For example, the file |pgfplotstable.example1.csv| uses commas as separation characters.
\begin{codeexample}[code only]
# Convergence results
# fictional source  generated 2008
level,dof,error1,error2,info,{grad(log(dof),log(error2))},quot(error1)
1,9,2.50000000e-01,7.57858283e-01,48,0,0
2,25,6.25000000e-02,5.00000000e-01,25,-1.35691545e+00,4
3,81,1.56250000e-02,2.87174589e-01,41,-1.17924958e+00,4
4,289,3.90625000e-03,1.43587294e-01,8,-1.08987331e+00,4
5,1089,9.76562500e-04,4.41941738e-02,22,-1.04500712e+00,4
6,4225,2.44140625e-04,1.69802322e-02,46,-1.02252239e+00,4
7,16641,6.10351562e-05,8.20091159e-03,40,-1.01126607e+00,4
8,66049,1.52587891e-05,3.90625000e-03,48,-1.00563427e+00,3.99999999e+00
9,263169,3.81469727e-06,1.95312500e-03,33,-1.00281745e+00,4.00000001e+00
10,1050625,9.53674316e-07,9.76562500e-04,2,-1.00140880e+00,4.00000001e+00
\end{codeexample}
	Thus, we need to specify |col sep=comma| when we read it.
\begin{codeexample}[]
\pgfplotstabletypeset[col sep=comma]{pgfplotstable.example1.csv}
\end{codeexample}
	You may call |\pgfplotstableset{col sep=comma}| once in your preamble if all your tables use commas as column separator.

	Please note that if cell entries (for example column names) contain the separation character, you need to enclose the column entry in \emph{braces}: |{grad(log(dof),log(error2)}|. If you want to use unmatched braces, you need to write a backslash before the brace. For example the name `|column{withbrace|' needs to be written as `|column\{withbrace|'. 
	
	Furthermore, if you need empty cells in case |col sep=space|, you have to provide |{}| to delimit such a cell since |col sep=space| uses \emph{at least} one white space (consuming all following ones).

	The value |col sep=braces| is special since it actually uses two separation characters. Every single cell entry is delimited by an opening and a closing brace, \marg{entry}, for this choice. Furthermore, any white spaces (spaces and tabs) between cell entries are \emph{skipped} in case |braces| until the next \marg{entry} is found.
\end{key}

\begin{key}{/pgfplots/table/header=\marg{boolean} (initially true)}
	Configures if column names shall be identified during input operations.

	The `header' is the first non-comment line, but only if this line contains non-numerical entries. If the first non-comment line contains at least one non-numerical entry (for example `|a name|'), each entry in this line is supposed to be a column name.

	If the first non-comment line contains only numerical data, it is used as data row. In this case, column indices will be assigned as column ``names''.

	Use |header=false| to force this last case, i.e. even if the first line contains strings, they won't be recognised as column names.
\end{key}

\subsection{Selecting Columns}
\begin{key}{/pgfplots/table/columns=\marg{comma-separated-list}}
	Selects particular columns the table. If this option is empty (has not been provided), all available columns will be selected.

	Inside of \marg{comma-separated-list}, column names as they appear in the table's header are expected. If there is no header, simply use column indices. If there are column names, the special syntax |[index]|\meta{integer} can be used to select columns by index. The first column has index~$0$.
\begin{codeexample}[]
\pgfplotstabletypeset[columns={dof,level,[index]4}]{pgfplotstable.example1.dat}
\end{codeexample}
\end{key}

\begin{pgfplotstablealiaskey}
	Assigns the new name \meta{new col name} for the column denoted by \meta{real col name}. Afterwards, accessing \meta{new col name} will use the data associated with column \meta{real col name}.

	You can use |columns/|\meta{new col name}|/.style| to assign styles for the alias, not for the original column name.

	If there exists both an alias and a column of the same name, the column name will be preferred. Furthermore, if there exists a |create on use| statement with the same name, this one will also be preferred.

	In case \meta{new col name} contains characters which are required for key settings, you need to use braces around it: ``|alias/{name=wi/th,special}/.initial={othername}|''.
\end{pgfplotstablealiaskey}

\begin{pgfplotstablecolumnkey}
	Sets all options in \marg{key-value-list} exclusively for \marg{column name}.

\begin{codeexample}[]
\pgfplotstabletypeset[
	columns/error1/.style={
		column name=$L_2$,
		sci,sci zerofill,sci subscript,
		precision=3},
	columns/error2/.style={
		column name=$A$,
		sci,sci zerofill,sci subscript,
		precision=2},
	columns/dof/.style={
		int detect,
		column name=\textsc{Dof}
	}
]
	{pgfplotstable.example1.dat}
\end{codeexample}
	If your column name contains commas `|,|', slashes `|/|' or equal signs `|=|', you need to enclose the column name in braces.
\begin{codeexample}[narrow]
\pgfplotstabletypeset[
	columns={dof,error1,{grad(log(dof),log(error2))}},
	columns/error1/.style={
		column name=$L_2$,
		sci,sci zerofill,sci subscript,
		precision=3},
	columns/dof/.style={
		int detect,
		column name=\textsc{Dof}},
	columns/{grad(log(dof),log(error2))}/.style={
		column name=slopes $L_2$,
		fixed,fixed zerofill,
		precision=1}
]
	{pgfplotstable.example1.dat}
\end{codeexample}
	If your tables don't have column names, you can simply use integer indices instead of \marg{column name} to refer to columns. If you have column names, you can't set column styles using indices.
\end{pgfplotstablecolumnkey}

\begin{pgfplotstabledisplaycolumnkey}
	Applies all options in \marg{key-value-list} exclusively to the column which will appear at position \meta{index} in the output table.

	In contrast to the |table/columns/|\meta{name} styles, this option refers to the output table instead of the input table. Since the output table has no unique column name, you can only access columns by index.

	Indexing starts with~$\meta{index}=0$.

	Display column styles override input column styles.
\end{pgfplotstabledisplaycolumnkey}

\begin{stylekey}{/pgfplots/table/every col no \meta{index}}
	A style which is identical with |display columns/|\meta{index}: it applies exclusively to the column at position \meta{index} in the output table.

	See |display columns/|\meta{index} for details.
\end{stylekey}

\begin{key}{/pgfplots/table/column type=\marg{tabular column type} (initially c)}
	Contains the column type for |tabular|. 
	
	If all column types are empty, the complete argument is skipped (assuming that no |tabular| environment is generated).

	Use |\pgfplotstableset{column type/.add=|\marg{before}\marg{after}|}| to \emph{modify} a value instead of overwriting it. The |.add| key handler works for other options as well.
\begin{codeexample}[narrow]
\pgfplotstabletypeset[
	columns={dof,error1,info},
	column type/.add={|}{}% results in '|c'
]
	{pgfplotstable.example1.dat}
\end{codeexample}
\end{key}


\begin{codekey}{/pgfplots/table/assign column name}
	Allows to \emph{modify} the value of |column name|.
	
	Argument |#1| is the current column name, that means after
	evaluation of |column name|. After |assign column| name, a new (possibly modified) value for |column name| should be set.
	
	That means you can use |column name| to assign the name as such
	and |assign column name| to generate final \TeX\ code (for example to insert |\multicolumn{1}{c}{#1}|).

	Default is empty which means no change.
\end{codekey}

\begin{stylekey}{/pgfplots/table/multicolumn names=\marg{tabular column type} (initially c)}
	A style which typesets each column name using a |\multicolumn{1}|\marg{tabular column type}\marg{the column name} statement.
\end{stylekey}

\begin{stylekey}{/pgfplots/table/dec sep align=\marg{header column type} (initially c)}
	A style which aligns numerical columns at the decimal separator.

	The first argument determines the alignment of the header column. 

	The style |dec sep align| actually introduces two new |tabular| columns\footnote{Unfortunately, \texttt{dec sep align} is currently not very flexible when it comes to column type modifications. In particular, it is not possible to use colored columns or cells in conjunction with \texttt{dec sep align}. The \texttt{\textbackslash rowcolor} command works properly; the color hangover introduced by \texttt{colortbl} is adjusted automatically.}, namely |r@{}l|. It introduces multicolumns for column names accordingly and handles numbers which do not have a decimal separator. 
	
	Please note that you need |\usepackage{array}| for this style.
\begin{codeexample}[]
% requires \usepackage{array}
\pgfplotstabletypeset[
	columns={dof,error1,error2,info,{grad(log(dof),log(error2))}},
	columns/error1/.style={dec sep align},
	columns/error2/.style={sci,sci subscript,sci zerofill,dec sep align},
	columns/info/.style={fixed,dec sep align},
	columns/{grad(log(dof),log(error2))}/.style={fixed,dec sep align}
]
	{pgfplotstable.example1.dat}
\end{codeexample}

	Or with comma as decimal separator:
\begin{codeexample}[]
% requires \usepackage{array}
\pgfplotstabletypeset[
	use comma,
	columns={dof,error1,error2,info,{grad(log(dof),log(error2))}},
	columns/error1/.style={dec sep align},
	columns/error2/.style={sci,sci subscript,sci zerofill,dec sep align},
	columns/info/.style={fixed,dec sep align},
	columns/{grad(log(dof),log(error2))}/.style={fixed,dec sep align}
]
	{pgfplotstable.example1.dat}
\end{codeexample}
	It may be advisable to use the |zerofill| variants to force at least one digit after the decimal separator.

	Please note that this style overwrites |column type|, |assign cell content| and some number formatting settings.
\end{stylekey}

\begin{stylekey}{/pgfplots/table/sci sep align=\marg{header column type} (initially c)}
	A style which aligns numerical columns at the exponent in scientific representation.

	The first argument determines the alignment of the header column. 

	It works similiarly to |dec sep align|, namely by introducing two artificial columns |r@{}l| for alignment.
	
	Please note that you need |\usepackage{array}| for this style.

	Please note that this style overwrites |column type|, |assign cell content| and some number formatting settings.
\end{stylekey}

\begin{stylekey}{/pgfplots/table/dcolumn=\marg{tabular column type}\marg{type for column name} (initially \{D\{.\}\{.\}\{2\}\}\{c\})}
	A style which can be used together with the |dcolumn| package of David Carlisle. It also enables alignment at the decimal separator. However, the decimal separator needs to be exactly one character which is incompatible with `|{,}|' (the default setting for |use comma|).
\end{stylekey}

\begin{stylekey}{/pgfplots/table/every first column}
A style which is installed for every first column only.
\begin{codeexample}[narrow]
\pgfplotstabletypeset[
 every head row/.style={before row=\hline,after row=\hline\hline},
 every last row/.style={after row=\hline},
 every first column/.style={
  column type/.add={|}{}
 },
 every last column/.style={
  column type/.add={}{|}
 }]
	{pgfplotstable.example1.dat}
\end{codeexample}
\end{stylekey}

\begin{stylekey}{/pgfplots/table/every last column}
A style which is installed for every last column only.
\end{stylekey}

\begin{stylekey}{/pgfplots/table/every even column}
A style which is installed for every column with even column index (starting with~$0$).
{
\pgfplotstableset{
	columns={dof,error1,{grad(log(dof),log(error2))},info},
	columns/error1/.style={
		column name=$L_2$,
		sci,sci zerofill,sci subscript,
		precision=3},
	columns/dof/.style={
		int detect,
		column name=\textsc{Dof}},
	columns/{grad(log(dof),log(error2))}/.style={
		column name=slopes $L_2$,
		fixed,fixed zerofill,
		precision=1}}

\begin{codeexample}[code only]
\pgfplotstableset{
	columns={dof,error1,{grad(log(dof),log(error2))},info},
	columns/error1/.style={
		column name=$L_2$,
		sci,sci zerofill,sci subscript,
		precision=3},
	columns/dof/.style={
		int detect,
		column name=\textsc{Dof}},
	columns/{grad(log(dof),log(error2))}/.style={
		column name=slopes $L_2$,
		fixed,fixed zerofill,
		precision=1}}
\end{codeexample}

\begin{codeexample}[narrow,graphic=white]
% requires \usepackage{colortbl}
\pgfplotstabletypeset[
 every even column/.style={
  column type/.add={>{\columncolor[gray]{.8}}}{}
}]
	{pgfplotstable.example1.dat}
\end{codeexample}
}
\end{stylekey}

\begin{stylekey}{/pgfplots/table/every odd column}
A style which is installed for every column with odd column index (starting with~$0$).
\end{stylekey}

\begin{command}{\pgfplotstablecol}
	During the evaluation of row or column options, this command expands to the current columns' index.
\end{command}
\label{pgfplotstable:page:tablerow}
\begin{command}{\pgfplotstablerow}
	During the evaluation of row or column options, this command expands to the current rows' index.
\end{command}
\begin{command}{\pgfplotstablecols}
	During the evaluation of row or column options, this command expands to the total number of columns in the output table.
\end{command}
\begin{command}{\pgfplotstablerows}
	During evaluation of \emph{columns}, this command expands to the total number of \emph{input} rows. You can use it inside of |row predicate|.

	During evaluation of \emph{rows}, this command expands to the total number of \emph{output} rows.
\end{command}


\subsection{Configuring Row Appearance}
The following styles allow to configure the final table code \emph{after any cell contents have been assigned}.

\begin{key}{/pgfplots/table/before row=\marg{\TeX\ code}}	
	Contains \TeX\ code which will be installed before the first cell in a row.
\end{key}

\begin{key}{/pgfplots/table/after row=\marg{\TeX\ code}}	
	Contains \TeX\ code which will be installed after the last cell in a row (i.e. after |\\|).
\end{key}

\begin{stylekey}{/pgfplots/table/every even row}
	A style which is installed for each row with even row index. The first row is supposed to be a ``head'' row and does not count. Indexing starts with~$0$.
{
\pgfplotstableset{
	columns={dof,error1,{grad(log(dof),log(error2))}},
	columns/error1/.style={
		column name=$L_2$,
		sci,sci zerofill,sci subscript,
		precision=3},
	columns/dof/.style={
		int detect,
		column name=\textsc{Dof}},
	columns/{grad(log(dof),log(error2))}/.style={
		column name=slopes $L_2$,
		fixed,fixed zerofill,
		precision=1}}

\begin{codeexample}[code only]
\pgfplotstableset{
	columns={dof,error1,{grad(log(dof),log(error2))}},
	columns/error1/.style={
		column name=$L_2$,
		sci,sci zerofill,sci subscript,
		precision=3},
	columns/dof/.style={
		int detect,
		column name=\textsc{Dof}},
	columns/{grad(log(dof),log(error2))}/.style={
		column name=slopes $L_2$,
		fixed,fixed zerofill,
		precision=1}}
\end{codeexample}

\begin{codeexample}[narrow,graphic=white]
% requires \usepackage{booktabs}
\pgfplotstabletypeset[
	every head row/.style={
		before row=\toprule,after row=\midrule},
	every last row/.style={
		after row=\bottomrule},
]
	{pgfplotstable.example1.dat}
\end{codeexample}

\begin{codeexample}[narrow,graphic=white]
% requires \usepackage{booktabs,colortbl}
\pgfplotstabletypeset[
	every even row/.style={
		before row={\rowcolor[gray]{0.9}}},
	every head row/.style={
		before row=\toprule,after row=\midrule},
	every last row/.style={
		after row=\bottomrule},
]
	{pgfplotstable.example1.dat}
\end{codeexample}

}
\end{stylekey}

\begin{stylekey}{/pgfplots/table/every odd row}	
	A style which is installed for each row with odd row index. The first row is supposed to be a ``head'' row and does not count. Indexing starts with~$0$.
\end{stylekey}

\begin{stylekey}{/pgfplots/table/every head row}	
	A style which is installed for each first row in the tabular. This can be used to adjust options for column names or to add extra lines/colours.
\end{stylekey}

\begin{stylekey}{/pgfplots/table/every first row}	
	A style which is installed for each first \emph{data} row, i.e. after the head row.
\end{stylekey}

\begin{stylekey}{/pgfplots/table/every last row}	
	A style which is installed for each last \emph{data} row.
\end{stylekey}

\begin{stylekey}{/pgfplots/table/every row no \meta{index}}	
	A style which is installed for the row with index \meta{index}.
\end{stylekey}

\subsection{Customizing and Getting the Tabular Code}
\begin{stylekey}{/pgfplots/table/every table=\marg{file name}}
	A style which is installed at the beginning of every |\pgfplotstabletypeset| command.

	The table file name is given as first argument.
\end{stylekey}

\begin{key}{/pgfplots/table/font=\marg{font name} (initially empty)}
	Assigns a font used for the complete table.
\end{key}

\begin{key}{/pgfplots/table/begin table=\marg{code} (initially \textbackslash begin\{tabular\})}
	Contains \marg{code} which is generated as table start.
\end{key}

\begin{codekey}{/pgfplots/table/typeset cell}
	A code key which assigns |/pgfplots/table/@cell content| to the final output of the current cell.

	The first argument, |#1|, is the final cell's value. After this macro, the value of |@cell content| will be written to the output.

	The default implementation is
\begin{codeexample}[code only]
\ifnum\pgfplotstablecol=\pgfplotstablecols
	\pgfkeyssetvalue{/pgfplots/table/cell content}{#1\\}%
\else
	\pgfkeyssetvalue{/pgfplots/table/cell content}{#1&}%
\fi
\end{codeexample}
	\paragraph{Attention:} The value of |\pgfplotstablecol| is now in the range $1,\dotsc,n$ where $n=$ |\pgfplotstablecols|. This simplifies checks whether we have the last column.
\end{codekey}

\begin{key}{/pgfplots/table/end table=\marg{code} (initially \textbackslash end\{tabular\})}
	Contains \marg{code} which is generated as table end.
\end{key}

\begin{key}{/pgfplots/table/outfile=\marg{file name} (initially empty)}
\label{page:outfile}
	Writes the generated tabular code into \marg{file name}. It can then be used with |\input|\marg{file name}, \PGFPlotstable\ is no longer required since it contains a completely normal |tabular|.
\begin{codeexample}[]
\pgfplotstabletypeset[
	columns={dof,error1},
	outfile=pgfplotstable.example1.out.tex]
	{pgfplotstable.example1.dat}
\end{codeexample}
and |pgfplotstable.example1.out.tex| contains
%\lstdefineformat{inp}{\\\\=\string\newline}%
\lstinputlisting[basicstyle=\ttfamily\footnotesize]{pgfplotstable.example1.out.tex}

The command |\pgfutilensuremath| checks whether math mode is active and switches to math mode if necessary\footnote{Please note that \lstinline{\\pgfutilensuremath} needs to be replaced by \lstinline{\\ensuremath} if you want to use the output file independent of \PGF. That can be done by \lstinline{\\let\\pgfutilensuremath=\\ensuremath} which enables the \LaTeX-command \lstinline{\\ensuremath}.}.
\end{key}

\begin{key}{/pgfplots/table/include outfiles=\marg{boolean} (initially false)}
	If enabled, any already existing outfile will be |\input| instead of overwritten.
\begin{codeexample}[code only]
\pgfplotstableset{include outfiles} % for example in the document's preamble
\end{codeexample}
	This allows to place any corrections manually into generated output files.
\end{key}
\begin{key}{/pgfplots/table/force remake=\marg{boolean} (initially false)}
	If enabled, the effect of |include outfiles| is disabled. As all key settings only last until the next brace (or |\end|\meta{}), this key can be used to re-generate some output files while others are still included.
\end{key}

\begin{key}{/pgfplots/table/write to macro=\marg{\textbackslash macroname}}
	If the value of |write to macro| is not empty, the completely generated (tabular) code will be written into the macro \marg{\textbackslash macroname}.
\end{key}

\begin{key}{/pgfplots/table/skip coltypes=\mchoice{true,false} (initially false)}
	Allows to skip the \marg{coltypes} in |\begin{tabular}|\marg{coltypes}. This allows simplifications for other table types which don't have \LaTeX's table format.
\end{key}

\begin{key}{/pgfplots/table/typeset=\mchoice{true,false} (initially true)}
	A boolean which disables the final typesetting stage. Use |typeset=false| in conjunction with |write to macro| if only the generated code is of interest and \TeX\ should not attempt to produce any content in the output |pdf|.	
\end{key}

\begin{key}{/pgfplots/table/debug=\marg{boolean} (initially false)}
	If enabled, will write every final tabular code to your log file.
\end{key}

\begin{key}{/pgfplots/table/TeX comment=\marg{comment sign} (initially \%)}
	The comment sign which is inserted into outfiles to suppress trailing white spaces.
\end{key}

\noindent As last example, we use \PGFPlotstable\ to write an |.html| (without number formatting, however):
% \usepackage{listings}
\begin{codeexample}[width=8cm]
\pgfplotstabletypeset[
	begin table={<table>}, end table={</table>},
	typeset cell/.style={
	  /pgfplots/table/@cell content={<td>#1</td>}
	},
	before row=<tr>,after row=</tr>,
	skip coltypes, typeset=false, string type,
	TeX comment=,
	columns={level,dof},
	outfile=pgfplotstable.example1.out.html,
]{pgfplotstable.example1.dat}
\lstinputlisting
	[basicstyle=\ttfamily\footnotesize]
	{pgfplotstable.example1.out.html}
\end{codeexample}

\subsection{Defining Column Types for \texttt{tabular}}
Besides input of text files, it is sometimes desireable to define column types for existing \texttt{tabular} environments.

\begin{command}{\newcolumntype\marg{letter}\oarg{number of arguments}$>$\marg{before column}\meta{column type}$<$\marg{after column}}
The command |\newcolumntype| is part of the |array| package and it defines a new column type \marg{letter} for use in \LaTeX\ tabular environments.
\begin{codeexample}[code only]
\usepackage{array}
\end{codeexample}

\begin{codeexample}[]
\newcolumntype{d}{>{-}c<{+}}
\begin{tabular}{dl}
a & b \\
c & d \\
\end{tabular}
\end{codeexample}

Now, the environment |pgfplotstablecoltype| can be used in \marg{before column} and \marg{after column} to define numerical columns:
% \usepackage{array}
\begin{codeexample}[]
% requires \usepackage{array}
\newcolumntype{L}[1]
	{>{\begin{pgfplotstablecoltype}[#1]}r<{\end{pgfplotstablecoltype}}}

\begin{tabular}{L{int detect}L{sci,sci subscript,sci zerofill}}
9      & 2.50000000e-01\\
25     & 6.25000000e-02\\
81     & 1.56250000e-02\\
289    & 3.90625000e-03\\
1089   & 9.76562500e-04\\
4225   & 2.44140625e-04\\
16641  & 6.10351562e-05\\
66049  & 1.52587891e-05\\
263169 & 3.81469727e-06\\
1050625& 9.53674316e-07\\
\end{tabular}
\end{codeexample}
\noindent The environment |pgfplotstablecoltype| accepts an optional argument which may contain any number formatting options. It is an error if numerical columns contain non-numerical data, so it may be necessary to use |\multicolumn| for column names.

\begin{codeexample}[]
% requires \usepackage{array}
\newcolumntype{L}[1]
	{>{\begin{pgfplotstablecoltype}[#1]}r<{\end{pgfplotstablecoltype}}}

\begin{tabular}{L{int detect}L{sci,sci subscript,sci zerofill}}
\multicolumn{1}{r}{Dof} & \multicolumn{1}{r}{Error}\\
9      & 2.50000000e-01\\
25     & 6.25000000e-02\\
81     & 1.56250000e-02\\
289    & 3.90625000e-03\\
1089   & 9.76562500e-04\\
4225   & 2.44140625e-04\\
16641  & 6.10351562e-05\\
66049  & 1.52587891e-05\\
263169 & 3.81469727e-06\\
1050625& 9.53674316e-07\\
\end{tabular}
\end{codeexample}
\end{command}

\subsection{Number Formatting Options}
\label{sec:number:printing}%
The following extract of \cite{tikz} explains how to configure number formats. The common option prefix |/pgf/number format| can be omitted; it will be recognised automatically.
\begin{command}{\pgfmathprintnumber\marg{x}}
Generates pretty-printed output for the (real) number \marg{x}. The input number \marg{x} is parsed using |\pgfmathfloatparsenumber| which allows arbitrary precision.

Numbers are typeset in math mode using the current set of number printing options, see below. Optional arguments can also be provided using |\pgfmathprintnumber[|\meta{options}|]|\marg{x}.
\end{command}

\begin{command}{\pgfmathprintnumberto\marg{x}\marg{\textbackslash macro}}
	Returns the resulting number into \marg{\textbackslash macro} instead of typesetting it directly.	
\end{command}

\begin{key}{/pgf/number format/fixed}
Configures |\pgfmathprintnumber| to round the number to a fixed number of digits after the period, discarding any trailing zeros.

\begin{codeexample}[]
\pgfkeys{/pgf/number format/.cd,fixed,precision=2}
\pgfmathprintnumber{4.568}\hspace{1em}
\pgfmathprintnumber{5e-04}\hspace{1em}
\pgfmathprintnumber{0.1}\hspace{1em}
\pgfmathprintnumber{24415.98123}\hspace{1em}
\pgfmathprintnumber{123456.12345}
\end{codeexample}

See section~\ref{sec:number:styles} for how to change the appearance.
\end{key}

\begin{key}{/pgf/number format/fixed zerofill=\marg{boolean}  (default true)}
Enables or disables zero filling for any number drawn in fixed point format.

\begin{codeexample}[]
\pgfkeys{/pgf/number format/.cd,fixed,fixed zerofill,precision=2}
\pgfmathprintnumber{4.568}\hspace{1em}
\pgfmathprintnumber{5e-04}\hspace{1em}
\pgfmathprintnumber{0.1}\hspace{1em}
\pgfmathprintnumber{24415.98123}\hspace{1em}
\pgfmathprintnumber{123456.12345}
\end{codeexample}
This key affects numbers drawn with |fixed| or |std| styles (the latter only if no scientific format is choosen).
\begin{codeexample}[]
\pgfkeys{/pgf/number format/.cd,std,fixed zerofill,precision=2}
\pgfmathprintnumber{4.568}\hspace{1em}
\pgfmathprintnumber{5e-05}\hspace{1em}
\pgfmathprintnumber{1}\hspace{1em}
\pgfmathprintnumber{123456.12345}
\end{codeexample}

See section~\ref{sec:number:styles} for how to change the appearance.
\end{key}

\begin{key}{/pgf/number format/sci}
Configures |\pgfmathprintnumber| to display numbers in scientific format, that means sign, mantisse and exponent (basis~$10$). The mantisse is rounded to the desired precision.

\begin{codeexample}[]
\pgfkeys{/pgf/number format/.cd,sci,precision=2}
\pgfmathprintnumber{4.568}\hspace{1em}
\pgfmathprintnumber{5e-04}\hspace{1em}
\pgfmathprintnumber{0.1}\hspace{1em}
\pgfmathprintnumber{24415.98123}\hspace{1em}
\pgfmathprintnumber{123456.12345}
\end{codeexample}

See section~\ref{sec:number:styles} for how to change the exponential display style.
\end{key}

\begin{key}{/pgf/number format/sci zerofill=\marg{boolean}  (default true)}
Enables or disables zero filling for any number drawn in scientific format.

\begin{codeexample}[]
\pgfkeys{/pgf/number format/.cd,sci,sci zerofill,precision=2}
\pgfmathprintnumber{4.568}\hspace{1em}
\pgfmathprintnumber{5e-04}\hspace{1em}
\pgfmathprintnumber{0.1}\hspace{1em}
\pgfmathprintnumber{24415.98123}\hspace{1em}
\pgfmathprintnumber{123456.12345}
\end{codeexample}
As with |fixed zerofill|, this option does only affect numbers drawn in |sci| format (or |std| if the scientific format is chosen).

See section~\ref{sec:number:styles} for how to change the exponential display style.
\end{key}

\begin{stylekey}{/pgf/number format/zerofill=\marg{boolean} (default true)}
	Sets both, |fixed zerofill| and |sci zerofill| at once.
\end{stylekey}

\begin{key}{/pgf/number format/std}
Configures |\pgfmathprintnumber| to a standard algorithm. It chooses either \texttt{fixed} or \texttt{sci}, depending on the order of magnitude. Let $n=s \cdot m \cdot 10^e$ be the input number and $p$ the current precision. If $-p/2 \le e \le 4$, the number is displayed using the fixed format. Otherwise, it is displayed using the scientific format. 

\begin{codeexample}[]
\pgfkeys{/pgf/number format/.cd,std,precision=2}
\pgfmathprintnumber{4.568}\hspace{1em}
\pgfmathprintnumber{5e-04}\hspace{1em}
\pgfmathprintnumber{0.1}\hspace{1em}
\pgfmathprintnumber{24415.98123}\hspace{1em}
\pgfmathprintnumber{123456.12345}
\end{codeexample}
\end{key}

\begin{key}{/pgf/number format/int detect}
Configures |\pgfmathprintnumber| to detect integers automatically. If the input number is an integer, no period is displayed at all. If not, the scientific format is chosen.

\begin{codeexample}[]
\pgfkeys{/pgf/number format/.cd,int detect,precision=2}
\pgfmathprintnumber{15}\hspace{1em}
\pgfmathprintnumber{20}\hspace{1em}
\pgfmathprintnumber{20.4}\hspace{1em}
\pgfmathprintnumber{0.01}\hspace{1em}
\pgfmathprintnumber{0}
\end{codeexample}
\end{key}

\begin{key}{/pgf/number format/int trunc}
Truncates every number to integers (discards any digit after the period).

\begin{codeexample}[]
\pgfkeys{/pgf/number format/.cd,int trunc}
\pgfmathprintnumber{4.568}\hspace{1em}
\pgfmathprintnumber{5e-04}\hspace{1em}
\pgfmathprintnumber{0.1}\hspace{1em}
\pgfmathprintnumber{24415.98123}\hspace{1em}
\pgfmathprintnumber{123456.12345}
\end{codeexample}
\end{key}

\begin{key}{/pgf/number format/precision=\marg{number}}
Sets the desired rounding precision for any display operation. For scientific format, this affects the mantisse.
\end{key}

\subsubsection{Changing Number Format Display Styles}%
\label{sec:number:styles}%
You can change the way how numbers are displayed. For example, if you use the `\texttt{fixed}' style, the input number is rounded to the desired precision and the current fixed point display style is used to typeset the number. The same is applied to any other format: first, rounding routines are used to get the correct digits, afterwards a display style generates proper \TeX-code.

\begin{key}{/pgf/number format/set decimal separator=\marg{text}}
Assigns \marg{text} as decimal separator for any fixed point numbers (including the mantisse in sci format).
\end{key}
\begin{key}{/pgf/number format/dec sep=\marg{text}}
	Just another name for |set decimal separator|.
\end{key}


\begin{key}{/pgf/number format/set thousands separator=\marg{text}}
Assigns \marg{text} as thousands separator for any fixed point numbers (including the mantisse in sci format).

\begin{codeexample}[]
\pgfkeys{/pgf/number format/.cd,
	fixed,
	fixed zerofill,
	precision=2,
	set thousands separator={}}
\pgfmathprintnumber{1234.56}
\end{codeexample}
\begin{codeexample}[]
\pgfkeys{/pgf/number format/.cd,
	fixed,
	fixed zerofill,
	precision=2,
	set thousands separator={}}
\pgfmathprintnumber{1234567890}
\end{codeexample}

\begin{codeexample}[]
\pgfkeys{/pgf/number format/.cd,
	fixed,
	fixed zerofill,
	precision=2,
	set thousands separator={.}}
\pgfmathprintnumber{1234567890}
\end{codeexample}
\begin{codeexample}[]
\pgfkeys{/pgf/number format/.cd,
	fixed,
	fixed zerofill,
	precision=2,
	set thousands separator={,}}
\pgfmathprintnumber{1234567890}
\end{codeexample}
\begin{codeexample}[]
\pgfkeys{/pgf/number format/.cd,
	fixed,
	fixed zerofill,
	precision=2,
	set thousands separator={{{{,}}}}}
\pgfmathprintnumber{1234567890}
\end{codeexample}
The last example employs commas and disables the default comma-spacing. 
\end{key}
\begin{key}{/pgf/number format/1000 sep=\marg{text}}
	Just another name for |set thousands separator|.
\end{key}

\begin{key}{/pgf/number format/min exponent for 1000 sep=\marg{number} (initially 0)}
	Defines the smalles exponent in scientific notation which is required to draw thousand separators. The exponent is the number of digits minus one, so $\meta{number}=4$ will use thousand separators starting with $1e4 = 10000$.
\begin{codeexample}[]
\pgfkeys{/pgf/number format/.cd,
	int detect,
	1000 sep={\,},
	min exponent for 1000 sep=0}
\pgfmathprintnumber{5000}; \pgfmathprintnumber{1000000}
\end{codeexample}

\begin{codeexample}[]
\pgfkeys{/pgf/number format/.cd,
	int detect,
	1000 sep={\,},
	min exponent for 1000 sep=4}
\pgfmathprintnumber{1000}; \pgfmathprintnumber{5000}
\end{codeexample}
\begin{codeexample}[]
\pgfkeys{/pgf/number format/.cd,
	int detect,
	1000 sep={\,},
	min exponent for 1000 sep=4}
\pgfmathprintnumber{10000}; \pgfmathprintnumber{1000000}
\end{codeexample}
\noindent A value of |0| disables this feature (negative values are ignored).
\end{key}


\begin{key}{/pgf/number format/use period}
A predefined style which installs periods `\texttt{.}' as decimal separators and commas `\texttt{,}' as thousands separators. This style is the default.

\begin{codeexample}[]
\pgfkeys{/pgf/number format/.cd,fixed,precision=2,use period}
\pgfmathprintnumber{12.3456}
\end{codeexample}
\begin{codeexample}[]
\pgfkeys{/pgf/number format/.cd,fixed,precision=2,use period}
\pgfmathprintnumber{1234.56}
\end{codeexample}
\end{key}

\begin{key}{/pgf/number format/use comma}
A predefined style which installs commas `\texttt{,}' as decimal separators and periods `\texttt{.}' as thousands separators.

\begin{codeexample}[]
\pgfkeys{/pgf/number format/.cd,fixed,precision=2,use comma}
\pgfmathprintnumber{12.3456}
\end{codeexample}
\begin{codeexample}[]
\pgfkeys{/pgf/number format/.cd,fixed,precision=2,use comma}
\pgfmathprintnumber{1234.56}
\end{codeexample}
\end{key}

\begin{key}{/pgf/number format/skip 0.=\marg{boolean} (initially false)}
	Configures whether numbers like $0.1$ shall be typeset as $.1$ or not.
\begin{codeexample}[]
\pgfkeys{/pgf/number format/.cd,
	fixed,
	fixed zerofill,precision=2,
	skip 0.}
\pgfmathprintnumber{0.56}
\end{codeexample}
\begin{codeexample}[]
\pgfkeys{/pgf/number format/.cd,
	fixed,
	fixed zerofill,precision=2,
	skip 0.=false}
\pgfmathprintnumber{0.56}
\end{codeexample}
\end{key}

\begin{key}{/pgf/number format/showpos=\marg{boolean} (initially false)}
	Enables or disables display of plus signs for non-negative numbers.
\begin{codeexample}[]
\pgfkeys{/pgf/number format/showpos}
\pgfmathprintnumber{12.345}
\end{codeexample}

\begin{codeexample}[]
\pgfkeys{/pgf/number format/showpos=false}
\pgfmathprintnumber{12.345}
\end{codeexample}

\begin{codeexample}[]
\pgfkeys{/pgf/number format/.cd,showpos,sci}
\pgfmathprintnumber{12.345}
\end{codeexample}
\end{key}

\begin{stylekey}{/pgf/number format/print sign=\marg{boolean}}
	A style which is simply an alias for |showpos=|\marg{boolean}.
\end{stylekey}

\begin{key}{/pgf/number format/sci 10e}
Uses $m \cdot 10^e$ for any number displayed in scientific format.

\begin{codeexample}[]
\pgfkeys{/pgf/number format/.cd,sci,sci 10e}
\pgfmathprintnumber{12.345}
\end{codeexample}
\end{key}

\begin{key}{/pgf/number format/sci 10\textasciicircum e}
The same as `|sci 10e|'.
\end{key}

\begin{key}{/pgf/number format/sci e}
Uses the `$1e{+}0$' format which is generated by common scientific tools for any number displayed in scientific format.

\begin{codeexample}[]
\pgfkeys{/pgf/number format/.cd,sci,sci e}
\pgfmathprintnumber{12.345}
\end{codeexample}
\end{key}

\begin{key}{/pgf/number format/sci E}
The same with an uppercase `\texttt{E}'.

\begin{codeexample}[]
\pgfkeys{/pgf/number format/.cd,sci,sci E}
\pgfmathprintnumber{12.345}
\end{codeexample}
\end{key}

\begin{key}{/pgf/number format/sci subscript}
Typesets the exponent as subscript for any number displayed in scientific format. This style requires very few space.

\begin{codeexample}[]
\pgfkeys{/pgf/number format/.cd,sci,sci subscript}
\pgfmathprintnumber{12.345}
\end{codeexample}
\end{key}

\begin{key}{/pgf/number format/sci superscript}
Typesets the exponent as superscript for any number displayed in scientific format. This style requires very few space.

\begin{codeexample}[]
\pgfkeys{/pgf/number format/.cd,sci,sci superscript}
\pgfmathprintnumber{12.345}
\end{codeexample}
\end{key}

\begin{key}{/pgf/number format/@dec sep mark=\marg{text}}
	Will be placed right before the place where a decimal separator belongs to. However, \marg{text} will be inserted even if there is no decimal separator. It is intented as place-holder for auxiliary routines to find alignment positions.

	This key should never be used to change the decimal separator! Use |dec sep| instead. 
\end{key}

\begin{key}{/pgf/number format/@sci exponent mark=\marg{text}}
	Will be placed right before exponents in scientific notation. It is intented as place-holder for auxiliary routines to find alignment positions.

	This key should never be used to change the exponent!
\end{key}

\begin{key}{/pgf/number format/assume math mode=\marg{boolean} (default true)}
	Set this to |true| if you don't want any checks for math mode.
	
	The initial setting installs a |\pgfutilensuremath| around each final number to change to math mode if necessary. Use |assume math mode=true| if you know that math mode is active and you don't want |\pgfutilensuremath|.
\end{key}




\section{Fine Tuning of Loaded Data}
The conversion from an unprocessed input table to a final typesetted |tabular| code uses four stages for every cell,
\begin{enumerate}
	\item Loading the table,
	\item Preprocessing,
	\item Typesetting,
	\item Postprocessing.
\end{enumerate}
The main idea is to select one typesetting algorithm (for example ``format my numbers with the configured number style''). This algorithm usually doesn't need to be changed. Fine tuning can then be done using zero, one or more preprocessors and postprocessors. Preprocessing can mean to select only particular rows or to apply some sort of operation before the typesetting algorithm sees the content. Postprocessing means to apply fine-tuning to the resulting \TeX\ output -- for example to deal with empty cells or to insert unit suffixes or modify fonts for single cells.

\subsection{Loading the table}
This first step to typeset a table involves the obvious input operations. Furthermore, the ``new column creation'' operations explained in section~\ref{pgfplotstable:createcol} are processed at this time. The table data is read (or acquired) as already explained earlier in this manual. Then, if columns are missing, column alias and |create on use| specifications will be processed as part of the loading procedure. See section~\ref{pgfplotstable:createcol} for details about column creation.

\subsection{Typesetting Cell Content}
Typesetting cells means to take their value and ``do something''. In many cases, this involves number formatting routines. For example, the ``raw'' input data |12.56| might become |1.235| |\cdot| |10^1|. The result of this stage is no longer useful for content-based computations. The typesetting step follows the preprocessing step.

\begin{codekey}{/pgfplots/table/assign cell content}
	Allows to redefine the algorithm which assigns cell contents. The argument |#1| is the (unformatted) contents of the input table. 
	
	The resulting output needs to be written to |/pgfplots/table/@cell content|.

	Please note that you may need special attention for |#1=|\marg{}, i.e. the empty string. This may happen if a column has less rows than the first column. \PGFPlotstable\ will balance columns automatically in this case, inserting enough empty cells to match the number of rows of the first column.

	Please note further that if any column has more entries than the first column, these entries will be skipped and a warning message will be issued into the log file.

	This key is evaluated inside of a local \TeX\ group, so any local macro assignments will be cleared afterwards.
\end{codekey}

\begin{key}{/pgfplots/table/assign cell content as number}
	This here is the default implementation of |assign cell contents|. 
	
	It invokes |\pgfmathprintnumberto| and writes the result into |@cell content|.
\end{key}

\begin{stylekey}{/pgfplots/table/string type}
	A style which redefines |assign cell contents| to simply return the ``raw'' input data, that means as text column. This assumes input tables with valid \LaTeX\ content (verbatim printing is not supported).
\end{stylekey}

\begin{stylekey}{/pgfplots/table/date type=\marg{date format}}% (initially \year-\month-\day)}
	A style which expects ISO dates of the form |YYYY-MM-DD| in each cell and produces pretty-printed strings on output. The output format is given as \marg{date format}. Inside of \marg{date format}, several macros which are explained below can be used.
% \usepackage{pgfcalendar}
\begin{codeexample}[]
% Requires 
% \usepackage{pgfcalendar}
\pgfplotstableset{columns={date,account1}}

\pgfplotstabletypeset[
	columns/date/.style={string type}
]{plotdata/accounts.dat}
\hspace{1cm}
\pgfplotstabletypeset[
	columns/date/.style={date type={\monthname\ \year}}
]{plotdata/accounts.dat}
\end{codeexample}
	This style \textbf{requires} to load the \PGF\  \textbf{calendar package}:
\begin{codeexample}[code only]
\usepackage{pgfcalendar}
\end{codeexample}
\end{stylekey}

\begin{command}{\year}
	Inside of \marg{date format}, this macro expands to the year as number (like |2008|).
\end{command}
\begin{command}{\month}
	Inside of \marg{date format}, this macro expands to the month as number, starting with~$1$ (like |1|).
\end{command}
\begin{command}{\monthname}
	Inside of \marg{date format}, this macro expands to the month's name as set in the current language (like |January|).
	 See below for how to change the language.
\end{command}
\begin{command}{\monthshortname}
	Inside of \marg{date format}, this macro expands to the month's short name as set in the current language (like |Jan|). 
	See below for how to change the language.
\end{command}
\begin{command}{\day}
	Inside of \marg{date format}, this macro expands to the day as number (like |31|).
\end{command}
\begin{command}{\weekday}
	Inside of \marg{date format}, this macro expands to the weekday number ($0$ for Monday, $1$ for Tuesday etc.).
\end{command}
\begin{command}{\weekdayname}
	Inside of \marg{date format}, this macro expands to the weekday's name in the current language (like |Wednesday|).
	 See below for how to change the language.
\end{command}
\begin{command}{\weekdayshortname}
	Inside of \marg{date format}, this macro expands to the weekday's short name in the current language (like |Wed|).
	 See below for how to change the language.
\end{command}
\subsubsection*{Changing the language for dates}
The date feature is implemented using the \PGF\ calendar module. This module employs the package |translator| (if it is loaded). I don't have more detail yet, sorry. Please refer to \cite{tikz} for more details.

\subsection{Preprocessing Cell Content}
The preprocessing step allows to change cell contents \emph{before} any typesetting routine (like number formatting) has been applied. The data is available in numerical format and math operations can be applied. Furthermore, cells can be erased depending on their numerical value. The preprocess step follows the data acquisition step (``loading step''). This means in particular that you can create (or copy) columns and apply operations on them.

\begin{codekey}{/pgfplots/table/preproc cell content}
	Allows to \emph{modify} the contents of cells \emph{before} |assign cell contents| is called.

	The semantics is as follows: before the preprocessor, |@cell content| contains the raw input data (or, maybe, the result of another preprocessor call). After the preprocessor, |@cell content| is filled with a -- possibly modified -- value. The resulting value is then used as input to |assign cell contents|.

	In the default settings, |assign cell contents| expects numerical input. So, the preprocessor is expected to produce numerical output.

	It is possible to provide multiple preprocessor directives using |.append code| or |.append style| key handlers.

	In case you don't want (or need) stackable preprocessors, you can also use `|#1|' to get the raw input datum as it is found in the file.
\end{codekey}

\begin{stylekey}{/pgfplots/table/string replace=\marg{pattern}\marg{replacement}}
	Appends code to the current |preproc cell content| value which replace every occurence of \marg{pattern} with \marg{replacement}. No expansion is performed during this step; \marg{pattern} must match literally.
\begin{codeexample}[]
\pgfplotstabletypeset[columns={level,dof}]
	{pgfplotstable.example1.dat}


\pgfplotstabletypeset[
	columns={level,dof},
	columns/level/.style={string replace={A}{B}}, % does nothing because there is no 'A'
	columns/dof/.style={string replace={256}{-42}}]  % replace '256' with '-42'
	{pgfplotstable.example1.dat}
\end{codeexample}
\end{stylekey}

\begin{stylekey}{/pgfplots/table/clear infinite}
	Appends code to the current |preproc cell content| value which replaces every infinite number with the empty string. This clears any cells with $\pm \infty$ and NaN.
\end{stylekey}

\begin{stylekey}{/pgfplots/table/multiply with=\marg{real number}}
	Appends code to the current |preproc cell content| value which multiplies every cell with \marg{real number}. Arithmetics are carried out in floating point.	
\end{stylekey}

\begin{stylekey}{/pgfplots/table/divide by=\marg{real number}}
	Appends code to the current |preproc cell content| value which divides every cell by \marg{real number}. Arithmetics are carried out in floating point.	
\end{stylekey}

\begin{stylekey}{/pgfplots/table/sqrt}
	Appends code to the current |preproc cell content| value which applies $\sqrt{x}$ to every non-empty cell. Arithmetics are carried out in floating point.	

	The following example copies the column |error1| and applies |sqrt| to the copy.
\begin{codeexample}[]
\pgfplotstableset{
	columns={error1,sqrterror1},
	create on use/sqrterror1/.style={create col/copy=error1},
	columns/error1/.style={column name=$\epsilon$},
	columns/sqrterror1/.style={sqrt,column name=$\sqrt \epsilon$},
	sci,sci 10e,precision=3,sci zerofill
}
\pgfplotstabletypeset{pgfplotstable.example1.dat}
\end{codeexample}
	Please take a look at section~\ref{pgfplotstable:createcol} for details about |create on use|.
\end{stylekey}

\begin{stylekey}{/pgfplots/table/multiply -1}
	Appends code to current |preproc cell content| value which multiplies every cell with $-1$. This style does the same job as |multiply with=-1|, it is just faster because only the sign changes.
\begin{codeexample}[]
\pgfplotstableset{
	columns={dof,error2,slopes2},
	columns/error2/.style={sci,sci zerofill},
	columns/slopes2/.style={dec sep align,empty cells with={\ensuremath{-}}},
	create on use/slopes2/.style=
		{create col/gradient loglog={dof}{error2}}}

\pgfplotstabletypeset{pgfplotstable.example1.dat}

\pgfplotstabletypeset[columns/slopes2/.append style={multiply -1}]
	{pgfplotstable.example1.dat}
\end{codeexample}
\end{stylekey}

\begin{codekey}{/pgfplots/table/row predicate}
	A boolean predicate which allows to select particular rows of the input table. The argument |#1| contains the current row's index (starting with~$0$, not counting comment lines or column names).

	The return value is assigned to the \TeX-if |\ifpgfplotstableuserow|. If the boolean is not changed, the return value is true.
\begin{codeexample}[narrow]
% requires \usepackage{booktabs}
\pgfplotstabletypeset[
	every head row/.style={
		before row=\toprule,after row=\midrule},
	every last row/.style={
		after row=\bottomrule},
	row predicate/.code={%
		\ifnum#1>4\relax
			\ifnum#1<8\relax
				\pgfplotstableuserowfalse
			\fi
		\fi}
]
	{pgfplotstable.example1.dat}
\end{codeexample}
	Please note that |row predicate| is applied \emph{before} any other option which affects row appearance. It is evaluated before |assign cell contents|. For example, the even/odd row styles refer to those rows for which the predicate returns |true|. In fact, you can use |row predicate| to truncate the complete table before it as actually processed. 
	
	During |row predicate|, the macro |\pgfplotstablerows| contains the total number of \emph{input} rows.
	
	Furthermore, |row predicate| applies only to the typeset routines, not the read methods. If you want to plot only selected table entries with |\addplot table|, use the \PGFPlots\ coordinate filter options.
\end{codekey}

\begin{stylekey}{/pgfplots/table/skip rows between index=\marg{begin}\marg{end}}
	A style which appends an |row predicate| which discards selected rows. The selection is done by index where indexing starts with~$0$. Every row with index $\meta{begin} \le i < \meta{end}$ will be skipped.
\begin{codeexample}[narrow]
% requires \usepackage{booktabs}
\pgfplotstabletypeset[
	every head row/.style={
		before row=\toprule,after row=\midrule},
	every last row/.style={
		after row=\bottomrule},
	skip rows between index={2}{4},
	skip rows between index={7}{9}
]
	{pgfplotstable.example1.dat}
\end{codeexample}
\end{stylekey}

\begin{stylekey}{/pgfplots/table/select equal part entry of=\marg{part no}\marg{part count}}
	A style which overwrites |row predicate| with a subset selection predicate. The idea is to split the current column into \marg{part count} equally sized parts and select only \marg{part no}.

	This can be used to simulate multicolumn tables.
\begin{codeexample}[]
% requires \usepackage{booktabs}
\pgfplotstableset{
	every head row/.style={before row=\toprule,after row=\midrule},
	every last row/.style={after row=\bottomrule}}

\pgfplotstabletypeset[string type]{pgfplotstable.example2.dat}

\pgfplotstabletypeset[
	display columns/0/.style={select equal part entry of={0}{2},string type},
	display columns/1/.style={select equal part entry of={0}{2},string type},
	display columns/2/.style={select equal part entry of={1}{2},string type},
	display columns/3/.style={select equal part entry of={1}{2},string type},
	columns={A,B,A,B}
]
	{pgfplotstable.example2.dat}
\end{codeexample}
	The example above shows the original file as-is on the left side. The right side shows columns A,B,A,B~-- but only half of the elements are shown, selected by indices \#0 or \#1 of \#2. The parts are equally large, up to a remainder. 
	
	If the available number of rows is not dividable by \marg{part count}, the remaining entries are distributed equally among the first parts.
\end{stylekey}


\subsection{Postprocessing Cell Content}
The postprocessing step is applied after the typesetting stage, that means it can't access the original input data. However, it can apply final formatting instructions which are not content based.

\begin{codekey}{/pgfplots/table/postproc cell content}
	Allows to \emph{modify} assigned cell content \emph{after} it has been assigned, possibly content-dependend. Ideas could be to draw negative numbers in red, typeset single entries in bold face or insert replacement text.

	This key is evaluated \emph{after} |assign cell content|. Its semantics is to modify an existing |@cell content| value.

	There may be more than one |postproc cell content| command, if you use |.append code| or |.append style| to define them:
\begin{codeexample}[]
% requires \usepackage{eurosym}
\pgfplotstabletypeset[
	column type=r,
	columns={dof,info},
	columns/info/.style={
		postproc cell content/.append style={
			/pgfplots/table/@cell content/.add={$\bf}{$}},
		postproc cell content/.append style={
			/pgfplots/table/@cell content/.add={}{\EUR{}}}
	}]
	{pgfplotstable.example1.dat}
\end{codeexample}
	The code above modifies |@cell content| successively. First, ``|$\bf ... $|'' is inserted, then ``|...\EUR|''. It should be noted that |pgfkeys| handles |.style| and |.code| in (quasi) the same way -- both are simple code keys and can be used as such. You can combine both with |.append style| and |.append code|. Please refer to~\cite[section about pgfkeys]{tikz} for details.

	As in |assign cell contents|, the code can evaluate helper macros like |\pgfplotstablerow| to change only particular entries. Furthermore, the argument ``|#1|'' expands to the \emph{unformatted} input argument which was found in the input table. This allows complete context based formatting options. Please remember that empty strings may appear due to column balancing -- introduce special treatment if necessary.

	There is one special case which occurs if |@cell content| itsself contains the cell separation character `|&|'. In this case, |postproc cell contents| is invoked \emph{separately} for each part before and after the ampersand and the ampersand is inserted afterwards. This allows compatibility with special styles which create artificial columns in the output (which is allowed, see |dec sep align|). To allow separate treatment of each part, you can use the macro |\pgfplotstablepartno|. It is defined only during the evaluation of |postproc cell content| and it evaluates to the current part index (starting with~$0$). If there is no ampersand in your text, the value will always be~$0$.

	This key is evaluated inside of a local \TeX\ group, so any local macro assignments will be cleared afterwards.

	The following example can be used to insert a dash, $-$, in a slope column:
\begin{codeexample}[]
\pgfplotstableset{
	create on use/slopes1/.style=
		{create col/gradient loglog={dof}{error1}}}

\pgfplotstabletypeset[
	columns={dof,error1,slopes1},
	columns/error1/.style={sci,sci zerofill},
	columns/slopes1/.style={
		postproc cell content/.append code={%
			\ifnum\pgfplotstablerow=0
				\pgfkeyssetvalue{/pgfplots/table/@cell content}{\ensuremath{-}}%
			\fi
		}%
	}]
	{pgfplotstable.example1.dat}
\end{codeexample}
Since this may be useful in a more general context, it is available as |empty cells with| style.
\end{codekey}

\begin{stylekey}{/pgfplots/table/empty cells with=\marg{replacement}}
	Appends code to |postproc cell content| which replaces any empty cell with \marg{replacement}.

	If |dec sep align| is active, the replacement will be inserted only for the part before the decimal separator.
\end{stylekey}

\begin{stylekey}{/pgfplots/table/set content=\marg{content}}
	A style which redefines |postproc cell contents| to always return the value \marg{content}.
\end{stylekey}


\section{Generating Data in New Tables or Columns}
\label{pgfplotstable:createcol}
It is possible to create new tables from scratch or to change tables after they have been loaded from disk.

\subsection{Creating New Tables From Scratch}
\begin{command}{\pgfplotstablenew\oarg{options}\marg{row count}\marg{\textbackslash table}}
	Creates a new table from scratch. 

	The new table will contain all columns listed in the |columns| key
	which needs to be provided in \oarg{options}\footnote{Currently, you need to provide at least one column here: the implementation gets confused for completely empty tables. If you do not provide any column name, a dummy column will be created.}.

	Furthermore, there must be |create on use| statements (see the next subsection) for every
	column which shall be generated. Columns are generated
	independently, in the order of appearance in |columns|.

	The table will contain exactly \marg{row count} rows. If \marg{row count} is an |\pgfplotstablegetrowsof| statement, that statement will be executed and the resulting number of rows be  used. Otherwise, \marg{row count} will be evaluated as number.
\begin{codeexample}[]
% this key setting could be provided in the document's preamble:
\pgfplotstableset{
	% define how the 'new' column shall be filled:
	create on use/new/.style={create col/set list={4,5,6,7,...,10}}}
% create a new table with 11 rows and column 'new':
\pgfplotstablenew[columns={new}]{11}\table
% show it:
\pgfplotstabletypeset[empty cells with={---}]\table
\end{codeexample}

\begin{codeexample}[]
% create a new table with 11 rows and column 'new':
\pgfplotstablenew[
	% define how the 'new' column shall be filled:
	create on use/new/.style={create col/expr={factorial(15+\pgfplotstablerow)}},
	columns={new}]
	{11}
	\table
% show it:
\pgfplotstabletypeset\table
\end{codeexample}
\end{command}

\subsection{Creating New Columns From Existing Ones}
\begin{command}{\pgfplotstablecreatecol\oarg{options}\marg{new col name}\marg{\textbackslash table}}
Creates a new column named \marg{new col name} and appends it to an already existing table \marg{\textbackslash table}.

End users probably don't need to use |\pgfplotstablecreatecol| directly at all -- there is the high--level framework |create on use| which invokes it internally and can be used with simple key--value assignments (see below). However, this documentation explains how to use values of existing columns to fill new cells.

This command offers a flexible framework to generate new columns. It has been designed to create new columns using the already existing values -- for example using logical or numerical methods to combine existing values. It provides fast access to a row's value, the previous row's value and the next row's value.

The following documentation is for all who want to \emph{write} specialised columns. It is not particularly difficult; it is just technical and it requires some knowledge of |pgfkeys|. If you don't like it, you can resort to predefined column generation styles - and enable those styles in \marg{options}.

The column entries will be created using the command key |create col/assign|. It will be invoked for every row of the table.
It is supposed to assign contents to |create col/next content|.
During the evaluation, the macro |\thisrow|\marg{col name} 
expands to the current row's value of the column identified by \marg{col name}.
Furthermore, |\nextrow|\marg{col name} expands to the \emph{next} row's
value of the designated column and |\prevrow|\marg{col name} expands to the value of the \emph{previous} row.

So, the idea is to simply redefine the command key |create col/assign| in such a way that it fills new cells as desired.

Two special |assign| routines are available for the first and last row: The contents for the \emph{last} row is computed with |create col/assign last|. Its semantics is the same. The contents for the \emph{first} row is computed with |create col/assign first| to simplify special cases here. These first and last commands are optional, their default is to invoke the normal |assign| routine.

The evaluation of the |assign| keys is done in local \TeX\ groups (i.e. any local definitions will be cleared afterwards).

The following macros are useful during cell assignments:
\begin{enumerate}
	\item |\prevrow|\marg{col name} / |\getprevrow|\marg{col name}\marg{\textbackslash macro}

	These two routines return the value stored in the \emph{previous} row of the designated column \marg{col name}. The |get| routine stores it into \meta{\textbackslash macro}.

	\item |\thisrow|\marg{col name} / |\getthisrow|\marg{col name}\marg{\textbackslash macro}

	These two routines return the \emph{current} row's value stored in the designated column. The |get| routine stores it into \meta{\textbackslash macro}.

	\item |\nextrow|\marg{col name} / |\getnextrow|\marg{col name}\marg{\textbackslash macro}

	These two routines return the \emph{next} row's value.

	\item |\pgfplotstablerow| and |\pgfplotstablerows| which contain the current row's index and the total number of rows, respectively. See page~\pageref{pgfplotstable:page:tablerow} for details.
	\item |\pgfmathaccuma| and |\pgfmathaccumb| can be used to transport intermediate results.
	Both maintain their value from one column assignment to the next. All other local variables will be deleted after leaving the assignment routines. The initial value is the empty string for both of them unless they are already initialised by column creation styles.
	\item commands which are valid throughout every part of this package, for example |\pgfplotstablerow| to get the current row index or |\pgfplotstablerows| to get the total number of rows.
\end{enumerate}
The \marg{col name} is expected to be a \emph{physical} column name, no alias or column index is allowed (unless column indices and column names are the same).

The following example takes our well-known input table and creates a copy of the |level| column. Furthermore, it produces a lot of output to show the available macros. Finally, it uses |\pgfkeyslet| to assign the contents of the resulting |\entry| to |next content|.
\begin{codeexample}[]
\pgfplotstableread{pgfplotstable.example1.dat}\table
\pgfplotstablecreatecol[
	create col/assign/.code={%
		\getthisrow{level}\entry
		\getnextrow{level}\nextentry
		\edef\entry{thisrow=\entry; nextrow=\nextentry. 
			(\#\pgfplotstablerow/\pgfplotstablerows)}%
		\pgfkeyslet{/pgfplots/table/create col/next content}\entry
	}]
	{new}\table

\pgfplotstabletypeset[
	column type=l,
	columns={level,new},
	columns/new/.style={string type}
]\table
\end{codeexample}

There is one more speciality: you can use |columns=|\marg{column list} to reduce the runtime complexity of this command. This works only if the |columns| key is provided directly into \marg{options}. In this case |\thisrow| and its variants are only defined for those columns listed in the |columns| value.

\paragraph{Limitations.} Currently, you can only access three values of one column at a time: the current row, the previous row and the next row. Access to arbitrary indices is not (yet) supported. Furthermore, this command has been designed to modify an existing table. You can't create a table from scratch with this command.

The default implementation of |assign| is to produce empty strings. The default implementation of |assign last| is to invoke |assign|, so in case you never really use the next row's value, you won't need to touch |assign last|. The same holds for |assign first|.
\end{command}

\begin{pgfplotstablecreateonusekey}
	Allows ``lazy creation'' of the column \meta{col name}. Whenever the column \meta{col name} is queried by name, for example in an |\pgfplotstabletypeset| command, and such a column does not exist already, it is created on-the-fly.

\begin{codeexample}[narrow]
% requires \usepackage{array}
\pgfplotstableset{% could be used in preamble
	create on use/quot1/.style=
		{create col/quotient={error1}}}

\pgfplotstabletypeset[
	columns={error1,quot1},
	columns/error1/.style={sci,sci zerofill},
	columns/quot1/.style={dec sep align}]
{pgfplotstable.example1.dat}
\end{codeexample}
	The example above queries |quot1| which does not yet exist in the input file. Therefor, it is checked whether a |create on use| style for |quot1| exists. This is the case, so it is used to create the missing column. The |create col/quotient| key is discussed below; it computes quotients of successive rows in column |error1|.

	A |create on use| specification is translated into 
	
	|\pgfplotstablecreatecol[|\meta{create options}|]|\marg{col name}\marg{the table},

	or, equivalently, into

	|\pgfplotstablecreatecol[|create on use/\meta{col name}|]|\marg{col name}\marg{the table}.

	This feature allows some lazyness, because you can omit the lengthy table modifications. However, lazyness may cost something: in the example above, the generated column will be \emph{lost} after returning from |\pgfplotstabletypeset|.

	The |create on use| has higher priority than |alias|.

	In case \meta{col name} contains characters which are required for key settings, you need to use braces around it: ``|create on use/{name=wi/th,special}/.style={...}|''.

	More examples for |create on use| are shown below while discussing the available column creation styles.
\end{pgfplotstablecreateonusekey}

\subsection{Predefined Column Generation Methods}
The following keys can be used in both |\pgfplotstablecreatecol| and the easier |create on use| frameworks.

\subsubsection{Acquiring Data Somewhere}
\begin{stylekey}{/pgfplots/table/create col/set=\marg{value}}
	A style for use in column creation context which creates a new column and writes \marg{value} into each new cell. The value is written as string (verbatim).
\begin{codeexample}[]
\pgfplotstableset{
	create on use/my new col/.style={create col/set={--empty--}},
	columns/my new col/.style={string type}
}

\pgfplotstabletypeset[
	columns={level,my new col},
]{pgfplotstable.example1.dat}
\end{codeexample}
\end{stylekey}

\begin{stylekey}{/pgfplots/table/create col/set list=\marg{comma-separated-list}}
	A style for use in column creation context which creates a new column consisting of the entries in \marg{comma-separated-list}. The value is written as string (verbatim).

	The \marg{comma-separated-list} is processed via \Tikz's |\foreach| command, that means you can use |...| expressions to provide number (or character) ranges.
\begin{codeexample}[]
\pgfplotstableset{
	create on use/my new col/.style={
		create col/set list={A,B,C,4,50,55,...,100}},
	columns/my new col/.style={string type}
}

\pgfplotstabletypeset[
	columns={level,my new col},
]{pgfplotstable.example1.dat}
\end{codeexample}
	\noindent The new column will be padded or truncated to the required number of rows. If the list does not contain enough elements, empty cells will be produced.
\end{stylekey}

\begin{stylekey}{/pgfplots/table/create col/copy=\marg{column name}}
	A style for use in column creation context which simply copies the existing column \marg{column name}.
\begin{codeexample}[]
\pgfplotstableset{
	create on use/new/.style={create col/copy={level}}
}

\pgfplotstabletypeset[
	columns={level,new},
	columns/new/.style={column name=Copy of level}
]{pgfplotstable.example1.dat}
\end{codeexample}
\end{stylekey}

\begin{stylekey}{/pgfplots/table/create col/copy column from table=\marg{file name or \textbackslash macro}\marg{column name}}
	A style for use in column creation context which creates a new column consisting of the entries in \marg{column name} of the provided table. The argument may be either a file name or an already loaded table (i.e. a \meta{\textbackslash macro} as returned by |\pgfplotstableread|).

	You can use this style, possibly combined with |\pgfplotstablenew|, to merge one common sort of column from different tables into one large table.
	
	The cell values are written as string (verbatim).

	\noindent The new column will be padded or truncated to the required number of rows. If the list does not contain enough elements, empty cells will be produced.
\end{stylekey}


\subsubsection{Mathematical Operations}

\begin{key}{/pgf/fpu=\marg{true,false}}
\index{Precision}
	Before we start to describe the column generation methods, one word about the math library. The core is always the \PGF\ math engine written by Mark Wibrow and Till Tantau. However, this engine has been written to produce graphics and is not suitable for scientific computing.
	
	I added a high-precision floating point library to \PGF\ which will be part of releases newer than \PGF\ $2.00$. It offers the full range of IEEE double precision computing in \TeX. This FPU is also part of \PGFPlotstable, and it is activated by default for |create col/expr| and all other predefined mathematical methods.

	The FPU won't be active for newly defined numerical styles. If you want to add own routines or styles, you will need to use
\begin{codeexample}[code only]
\pgfkeys{/pgf/fpu=true}
\end{codeexample}
	\noindent in order to activate the extended precision. The standard math parser is limited to fixed point numbers in the range $\pm 16384.00000$.
\end{key}

\begin{stylekey}{/pgfplots/table/create col/expr=\marg{math expression}}
	A style for use in |\pgfplotstablecreatecol| which uses \marg{math expression} to assign contents for the new column.

\begin{codeexample}[]
\pgfplotstableset{
	create on use/new/.style={
		create col/expr={\thisrow{level}*2}}
}

\pgfplotstabletypeset[
	columns={level,new},
	columns/new/.style={column name=$2\cdot $level}
]{pgfplotstable.example1.dat}
\end{codeexample}
	The macros |\thisrow|\marg{col name} and |\nextrow|\marg{col name} can be used to use values of the existing table.

	Please see |\pgfplotstablecreatecol| for more information.

	\paragraph{Accumulated columns:} The |expr| style initialises |\pgfmathaccuma| to |0| before its first column. Whenever it computes a new column value, it redefines |\pgfmathaccuma| to be the result. That means you can use |\pgfmathaccuma| inside of \marg{math expression} to accumulate columns. See |create col/expr accum| for more details.

	\paragraph{About the precision and number range:}\index{Precision}\index{Floating Point Unit} Starting with version 1.2, |expr| uses a floating point unit. The FPU provides the full data range of scientific computing with a relative precision between $10^{-4}$ and $10^{-6}$. The |/pgf/fpu| key provides some more details. 
	
	\paragraph{Accepted operations:} The math parser of \PGF, combined with the FPU, provides the following function and operators:

	|+|, |-|, |*|, |/|, |abs|, |round|, |floor|, |mod|, |<|, |>|, |max|, |min|, |sin|, |cos|, |tan|, |deg| (conversion from radians to degrees), |rad| (conversion from degrees to radians), |atan|, |asin|, |acos|, |cot|, |sec|, |cosec|, |exp|, |ln|, |sqrt|, the constanst |pi| and |e|, |^| (power operation), |factorial|\footnote{Starting with \PGF\ versions newer than $2.00$, you can use the postfix operator \texttt{!} instead of \texttt{factorial}.}, |rand| (random between $-1$ and $1$), |rnd| (random between $0$ and $1$), number format conversions |hex|, |Hex|, |oct|, |bin| and some more. The math parser has been written by Mark Wibrow and Till Tantau~\cite{tikz}, the FPU routines have been developed as part of \PGFPlots. The documentation for both parts can be found in~\cite{tikz}. \textbf{Attention:} Trigonometric functions work with degrees, not with radians!

\end{stylekey}

\begin{stylekey}{/pgfplots/table/create col/expr accum=\marg{math expression}\marg{accum initial}}
	A variant of |create col/expr| which also allows to define the initial value of |\pgfmathaccuma|. The case \marg{accum initial}=|0| is \emph{equivalent} to |expr=|\marg{math expression}.

\begin{codeexample}[]
\pgfplotstableset{
	create on use/new/.style={
		create col/expr={\pgfmathaccuma + \thisrow{level}}},
	create on use/new2/.style={
		create col/expr accum={\pgfmathaccuma - \thisrow{level}}{100}}
}

\pgfplotstabletypeset[
	columns={level,new,new2},
	columns/new/.style={column name=$\sum$level},
	columns/new2/.style={column name=$\prod$level}
]{pgfplotstable.example1.dat}
\end{codeexample}
The example creates two columns: the |new| column is just the sum of each value in the \meta{level} column (it employs the default |\pgfmathaccuma=0|). The |new2| column initialises |\pgfmathaccuma=100| and then successively subtracts the value of \meta{level}.
\end{stylekey}

\begin{stylekey}{/pgfplots/table/create col/quotient=\marg{column name}}
	A style for use in |\pgfplotstablecreatecol| which computes the quotient $c_i := m_{i-1} / m_i$ for every entry $i = 1,\dotsc, (n-1)$ in the column identified with \marg{column name}. The first value $c_0$ is kept empty.

\begin{codeexample}[]
% requires \usepackage{array}
\pgfplotstableset{% configuration, for example, in preamble:
	create on use/quot1/.style={create col/quotient=error1},
	create on use/quot2/.style={create col/quotient=error2},
	columns={error1,error2,quot1,quot2},
	%
	% display styles:
	columns/error1/.style={sci,sci zerofill},
	columns/error2/.style={sci,sci zerofill},
	columns/quot1/.style={dec sep align},
	columns/quot2/.style={dec sep align}
}

\pgfplotstabletypeset{pgfplotstable.example1.dat}
\end{codeexample}
	This style employs methods of the floating point unit, that means it works with a relative precision of about $10^{-7}$ ($7$ significant digits in the mantisse).
\end{stylekey}

\begin{stylekey}{/pgfplots/table/create col/iquotient=\marg{column name}}
	Like |create col/quotient|, but the quotient is inverse.
\end{stylekey}

\begin{stylekey}{/pgfplots/table/create col/dyadic refinement rate=\marg{column name}}
	A style for use in |\pgfplotstablecreatecol| which computes the convergence rate $\alpha$ of the data in column \marg{column name}. The contents of \marg{column name} is assumed to be something like $e_i(h_i) = O(h_i^\alpha)$. Assuming a dyadic refinement relation from one row to the next, $h_i = h_{i-1}/2$, we have $h_{i-1}^\alpha / (h_{i-1}/2)^\alpha = 2^\alpha$, so we get $\alpha$ using 
	\[ c_i := \log_2\left( \frac{e_{i-1}}{e_i} \right). \]
	The first value $c_0$ is kept empty.

\begin{codeexample}[]
% requires \usepackage{array}
\pgfplotstabletypeset[% here, configuration options apply only to this single statement:
	create on use/rate1/.style={create col/dyadic refinement rate={error1}},
	create on use/rate2/.style={create col/dyadic refinement rate={error2}},
	columns={error1,error2,rate1,rate2},
	columns/error1/.style={sci,sci zerofill},
	columns/error2/.style={sci,sci zerofill},
	columns/rate1/.style={dec sep align},
	columns/rate2/.style={dec sep align}]
	{pgfplotstable.example1.dat}
\end{codeexample}
	This style employs methods of the floating point unit, that means it works with a relative precision of about $10^{-6}$ ($6$ significant digits in the mantisse).
\end{stylekey}

\begin{stylekey}{/pgfplots/table/create col/idyadic refinement rate=\marg{column name}}
	As |create col/dyadic refinement rate|, but the quotient is inverse.
\end{stylekey}

\begin{keylist}{
	/pgfplots/table/create col/gradient=\marg{col x}\marg{col y},
	/pgfplots/table/create col/gradient loglog=\marg{col x}\marg{col y},
	/pgfplots/table/create col/gradient semilogx=\marg{col x}\marg{col y},
	/pgfplots/table/create col/gradient semilogy=\marg{col x}\marg{col y}}
	A style for |\pgfplotstablecreatecol| which computes piecewise gradients $(y_{i+1} - y_i) / (x_{i+1} - x_i )$ for each row. The $y$ values are taken out of column \marg{col y} and the $x$ values are taken from \marg{col y}.
	
	The logarithmic variants apply the natural logarithm, $\log(\cdot)$, to its argument before starting to compute differences. More precisely, the |loglog| variant applies the logarithm to both, $x$ and $y$, the |semilogx| variant applies the logarithm only to~$x$ and the |semilogy| variant applies the logarithm only to~$y$.
	
\begin{codeexample}[]
% requires \usepackage{array}
\pgfplotstableset{% configuration, for example in preamble:
	create on use/slopes1/.style={create col/gradient loglog={dof}{error1}},
	create on use/slopes2/.style={create col/gradient loglog={dof}{error2}},
	columns={dof,error1,error2,slopes1,slopes2},
	% display styles:
	columns/dof/.style={int detect},
	columns/error1/.style={sci,sci zerofill},
	columns/error2/.style={sci,sci zerofill},
	columns/slopes1/.style={dec sep align},
	columns/slopes2/.style={dec sep align}
}
\pgfplotstabletypeset{pgfplotstable.example1.dat}
\end{codeexample}

\begin{codeexample}[]
% requires \usepackage{array}
\pgfplotstableset{% configuration, for example in preamble:
	create on use/slopes1/.style={create col/gradient semilogy={level}{error1}},
	columns={level,error1,slopes1},
	% display styles:
	columns/level/.style={int detect},
	columns/error1/.style={sci,sci zerofill,sci subscript},
	columns/slopes1/.style={dec sep align}
}
\pgfplotstabletypeset{pgfplotstable.example1.dat}
\end{codeexample}
	This style employs methods of the floating point unit, that means it works with a relative precision of about $10^{-6}$ ($6$ significant digits in the mantisse).
\end{keylist}

\begin{stylekey}{/pgfplots/table/create col/function graph cut y=\marg{cut value}\marg{common options}\marg{one key-value set for each plot}}
	A specialized style for use in |create on use| statements which computes cuts of (one or more) discrete plots $y(x_1), \dotsc, y(x_N)$ with a fixed \marg{cut value}. The $x_i$ are written into the table's cells.

	In a cost--accuracy plot, this feature allows to extract the cost for fixed accuracy. The dual feature with |cut x| allows to compute the accuracy for fixed cost.
	
	\pgfplotsset{anchor=center,/tikz/baseline}
\begin{codeexample}[]
\pgfplotstablenew[
	create on use/cut/.style={create col/function graph cut y=
		{2.5e-4}% search for fixed L2 = 2.5e-4
		{x=Basis,y=L2,ymode=log,xmode=log}% double log, each function is L2(Basis)
% now, provide each single function f_i(Basis):
{{table=plotdata/newexperiment1.dat},{table=plotdata/newexperiment2.dat}}
	},
	columns={cut}]
	{2} 
	\table
\pgfplotstabletypeset{\table}

\begin{tikzpicture}
\begin{loglogaxis}
	\addplot table[x=Basis,y=L2] {plotdata/newexperiment1.dat};
	\addplot table[x=Basis,y=L2] {plotdata/newexperiment2.dat};
	\draw[blue!30!white] (axis cs:1,2.5e-4) -- (axis cs:1e5,2.5e-4);
	\node[pin=-90:{$x=53.66$}] at (axis cs:53.66,2.5e-4) {};
	\node[pin=45:{$x=601.83$}] at (axis cs:601.83,2.5e-4) {};
\end{loglogaxis}
\end{tikzpicture}
\end{codeexample}
	In the example above, we are searching for $x_1$ and $x_2$ such that $f_1(x_1) = \pgfmathprintnumber{2.5e-4}$ and $f_2(x_2) =\pgfmathprintnumber{2.5e-4}$. On the left is the automatically computed result. On the right is a problem illustration with proper annotation.
	The \marg{cut value} is set to |2.5e-4|. The \marg{common options} contain the problem setup; in our case logarithmic scales and column names. The third argument is a comma-separated-list. Each element $i$ is a set of keys describing how to get $f_i(\cdot)$.

	During both, \marg{common options} and the key sets, the following keys can be used:
	\begin{itemize}
		\item |table|: either a file name or an already loaded table where to get the data points,
		\item |x|: the column name of the $x$ axis,
		\item |y|: the column name of the $y$ axis.
	\end{itemize}
	The keys |xmode| and |ymode| can take either |log| or |linear|. All mentioned keys have the common key path 

	\textcolor{red!75!black}{\texttt{/pgfplots/table/create col/function graph cut/}}.
\end{stylekey}
\begin{stylekey}{/pgfplots/table/create col/function graph cut x=\marg{cut value}\marg{common options}\marg{one key-value set for each plot}}
	As above, just with $x$ and $y$ exchanged.
\end{stylekey}

\section{Miscellaneous}
\subsection{Writing (Modified) Tables To Disk}
\begin{key}{/pgfplots/table/outfile=\marg{file name} (initially empty)}
	Writes the completely processed table as \TeX\ file to \marg{file name}. This key is described in all detail on page~\pageref{page:outfile}.
\end{key}

\begin{command}{\pgfplotstablesave\oarg{options}\marg{\textbackslash macro or input file name}\marg{output file name}}
	This command takes a table and writes it to a new data file (without performing any typesetting).

	If the first argument is a file name, that file is loaded first.

	This command simply invokes |\pgfplotstabletypeset| with cleared output parameters. That means any of the column creation methods apply here as well, including any postprocessing steps (without the final typesetting).

	|\pgfplotstablesave| uses the keys |reset styles| and |disable rowcol styles| to clear any typesetting related options. Furthermore, it sets |string type| to allow verbatim output.
\begin{codeexample}[]
\pgfplotstablesave[
	create on use/postproc1/.style={create col/dyadic refinement rate=error1},
	columns={dof,error1,postproc1}
]
	{pgfplotstable.example1.dat}
	{pgfplotstable.example1.out.dat}
\end{codeexample}
Now, |pgfplotstable.example1.out.dat| is
\lstinputlisting[basicstyle=\ttfamily\footnotesize,tabsize=8]{pgfplotstable.example1.out.dat}

You can use the |col sep| key inside of \meta{options} to define a column separator for the output file. In case you need a different input column separator, use |in col sep| instead of |col sep|.

\paragraph{Remarks}
\begin{itemize}
	\item 
Empty cells will be filled with |{}| if |col sep=space|. Use the |empty cells with| style to change that.
	\item  Use |disable rowcol styles=false| inside of \meta{options} if you need to change column/row based styles.
\end{itemize}
\end{command}

\subsection{Miscellaneous Keys}
\begin{key}{/pgfplots/table/disable rowcol styles=\mchoice{true,false} (initially false)}
	Set this to |true| if |\pgfplotstabletypeset| shall \emph{not} set any styles which apply only to specific columns or only to specific rows.

	This disables the styles
	\begin{itemize}
		\item |columns/|\meta{column name},
		\item |display columns/|\meta{column index},
		\item |every col no |\meta{column index},
		\item |every row no |\meta{row index}.
	\end{itemize}
\end{key}

\begin{key}{/pgfplots/table/reset styles}
	Resets all table typesetting styles which do not explicitly depend on column or row names and indices. The affected styles are
	\begin{itemize}
		\item |every table|,
		\item |every even row|, |every odd row|, |every even column|, |every odd column|,
		\item |every first column|, |every last column|, |every first row|, |every last row|,
		\item |every head row|.
	\end{itemize}
	In case you want to reset all, you should also consider the key |disable rowcol styles|.
\end{key}

\subsection{Plain \TeX\ and Con\TeX t support}
\label{sec:pgfplotstable:context}
The table code generator is initialised to produce \LaTeX\ |tabular| environments. However, it only relies on~`|&|' being the column separator and~`|\\|' the row terminator. The |column type| feature is more or less specific to |tabular|, but you can disable it completely. Replace |begin table| and |end table| with appropriate \TeX- or Con\TeX t commands to change it. If you have useful default styles (or bug reports), let me know.

\printindex

\bibliographystyle{abbrv} %gerapali} %gerabbrv} %gerunsrt.bst} %gerabbrv}% gerplain}
\bibliography{pgfplots}
\end{document}
