%--------------------------------------------
%
% Package numtable
%
% Provides support to read and work with abstact numeric tables of the
% form
%
% COLUMN1	COLUMN2 COLUMN3
% 1 		2		3
% 4			4		552
% 1e124		0.00001	1.2345e-12
% ...
%
% Copyright 2007/2008 by Christian Feuers√§nger.
%
% This program is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program.  If not, see <http://www.gnu.org/licenses/>.
%
%--------------------------------------------

% This file relies on
% - pgfplotsliststructure.code.tex
% - pgfplotsarraystructure.code.tex
% - a (quite!) recent PGF.
%
% and needs some token registers. It does not use more of pgfplots.
%
\newif\ifpgfplotstable@search@header

\pgfkeys{%
	/pgfplots/numeric table/header/.is if=pgfplotstable@search@header,
	/pgfplots/numeric table/header=true,
	/pgfplots/numeric table/x index/.store in=\pgfplots@plot@tbl@xindex,
	/pgfplots/numeric table/x index=0,
	/pgfplots/numeric table/x/.store in=\pgfplots@plot@tbl@x,
	/pgfplots/numeric table/x=,
	/pgfplots/numeric table/y index/.store in=\pgfplots@plot@tbl@yindex,
	/pgfplots/numeric table/y index=1,
	/pgfplots/numeric table/y/.store in=\pgfplots@plot@tbl@y,
	/pgfplots/numeric table/y=,
	/pgfplots/numeric table/x error index/.initial=,
	/pgfplots/numeric table/y error index/.initial=,
	/pgfplots/numeric table/x error/.initial=,
	/pgfplots/numeric table/y error/.initial=,
	% columns={name1,name2}
	% or
	% columns={[index]2,name2,name3,[index]5}
	/pgfplots/numeric table/columns/.initial=,
	/pgfplots/numeric table/column name/.initial=\pgfkeysnovalue,
	/pgfplots/numeric table/column type/.initial={c},
	/pgfplots/numeric table/every table/.style={},
	/pgfplots/numeric table/every even row/.style={},
	/pgfplots/numeric table/every odd row/.style={},
	/pgfplots/numeric table/every last row/.style={},
	/pgfplots/numeric table/every first row/.style={},
	/pgfplots/numeric table/every head row/.style={},
	/pgfplots/numeric table/every first column/.style={},
	/pgfplots/numeric table/every last column/.style={},
	/pgfplots/numeric table/every even column/.style={},
	/pgfplots/numeric table/every odd column/.style={},
	/pgfplots/numeric table/before row/.initial=,
	/pgfplots/numeric table/after row/.initial=,
	/pgfplots/numeric table/begin table/.initial={\begin{tabular}},
	/pgfplots/numeric table/end table/.initial={\end{tabular}},
	/pgfplots/numeric table/outfile/.initial=,
	%
	% will be redefined by |assign cell content| for every cell:
	/pgfplots/numeric table/@cell content/.initial=,
	%
	% #1: the cells content as it has been found in the input table
	% this command key should somehow fill |cell content|.
	/pgfplots/numeric table/assign cell content/.code={%
		\pgfmathprintnumberto{#1}\pgfmathresult%
		\pgfkeyslet{/pgfplots/numeric table/@cell content}\pgfmathresult
	},
	/pgfplots/numeric table/string type/.style={%
		/pgfplots/numeric table/assign cell content/.style={%
			/pgfplots/numeric table/@cell content={##1}%
		}%
	},%
}

% \pgfplotstableread[OPTIONS] {FILE} to \name
%
% This method reads a table from FILE to macro \name.
%
% FILE is something like
% G	Basis	dof	L2	A	Lmax	cgiter	maxlevel	eps
% 5	5	5	8.31160034e-02	0.00000000e+00	1.80007647e-01	2	2	-1
% 17	17	17	2.54685628e-02	0.00000000e+00	3.75580565e-02	5	3	-1
% ...
%
% A number format line is also understood:
% G	Basis	dof	L2	A	Lmax	cgiter	maxlevel	eps
% $flags int	int	int	sci:8	sci:8	sci:8	int	int	std:8
% 5	5	5	8.31160034e-02	0.00000000e+00	1.80007647e-01	2	2	-1
%
% or a three-column-gnuplot file with 2 comment headers like
% #Curve 0, 20 points
% #x y type
% 0.00000 0.00000 i
% 0.52632 0.50235 i
%
% The table data is stored columnwise in lists and can be accessed
% with the other methods of this package.
\def\pgfplotstableread{%
	\pgfutil@ifnextchar[{%
		\pgfplotstableread@impl
	}{%
		\pgfplotstableread@impl[]%
	}%
}

% BACKWARDS COMPATIBILITY
\let\pgfnumtableread=\pgfplotstableread

\def\pgfplotstablegetcolumnlist#1\to#2{%
	\let#2=#1
}

\def\pgfplotstablegetcolumnbyname#1\of#2\to#3{%
	\pgfutil@ifundefined{\string#2@#1}{%
		\pgfplots@error{Sorry, could not retrieve column '#1' from table...}%
	}{%
		\expandafter\let\expandafter#3\csname\string#2@#1\endcsname
	}%
}

\def\pgfplotstablegetcolumnnamebyindex#1\of#2\to#3{%
	\pgfplotslistselect#1\of#2\to#3\relax
}%
\def\pgfplotstablegetcolumnbyindex#1\of#2\to#3{%
	\pgfplotslistselect#1\of#2\to#3\relax
	\expandafter\pgfplotstablegetcolumnbyname#3\of#2\to{#3}%
}

\def\pgfplotstablecopy#1\to#2{%
	\let#2=#1%
	\pgfplotslistforeachungrouped#1\as\pgfplotstable@TMP{%
		\def\pgfplotstable@TMPB{%
			\expandafter\let\csname\string#2@\pgfplotstable@TMP\endcsname}%
		\expandafter\pgfplotstable@TMPB\csname\string#1@\pgfplotstable@TMP\endcsname
	}%
}

% Typesets a table.
%
% \pgfplotstabletypeset[<options>]<\tablestructure>
%
% If you do not select any columns, the complete table is drawn.
%
% There are several options and styles which are available in
% <options>, see the declaration above.
%
% ATTENTION: the default implementation employs
% \begin{tabular}...\end{tabular} and is therefor only usable with
% LaTeX!
%
% You will need to reconfigure the tables.
\def\pgfplotstabletypeset{%
	\pgfutil@ifnextchar[{%	
		\pgfplotstabletypeset@opt
	}{%
		\pgfplotstabletypeset@opt[]%
	}%
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% IMPLEMENTATION
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newif\ifpgfplotstableread@curline@contains@colnames
\newif\ifpgfplotstableread@foundcolnames
\newif\ifpgfplotstableread@skipline
\def\pgfplotstableread@impl[#1]#2{%
	\pgfutil@ifnextchar t{%
		\pgfplotstableread@impl@@{#1}{#2}%
	}{%
		\pgfplotstableread@impl@{#1}{#2}%
	}%
}%

% I don't know why; but I started with 
% >> \pgfplotstableread[]{file} to \macro
% That ' to ' is really ugly. This here is for backwards
% compatibility:
\def\pgfplotstableread@impl@@#1#2to #3{%
	\pgfplotstableread@impl@{#1}{#2}{#3}%
}%

\def\pgfplotstableread@impl@#1#2#3{%
	\begingroup
	\def\pgfplotstable@TMP{#1}%
	\ifx\pgfplotstable@TMP\pgfutil@empty
	\else
		\pgfqkeys{/pgfplots/numeric table}{#1}%
	\fi
%\pgfplots@message{ATTEMPTING TO READ #2}%
	\openin1=#2\relax
	\def\pgfplotstableread@filename{#2}%
	\let\pgfplotstableread@lineno=\c@pgf@counta
	\let\pgfplotstableread@numcols=\c@pgf@countb
	\let\pgfplotstableread@curcol=\c@pgf@countc
	\let\pgfplotstableread@usablelineno=\c@pgf@countd
	\pgfplotstableread@lineno=0
	\pgfplotstableread@usablelineno=0
	\pgfplotstableread@numcols=0
	\pgfplotslistnewempty\pgfplotstable@colnames
	\ifeof1
		\pgfplotstable@error{Could not read table file '#2'.}%
	\fi
	%
	\pgfplotstableread@loop@over@lines
	%
	\ifpgfplotstableread@foundcolnames
	\else
		\pgfplotstableread@create@column@names@with@numbers
	\fi
	% Well, now write the identified data to #3:
	%
	% make all temporaries global:
	\global\let\pgfplotstable@colnames=\pgfplotstable@colnames
	\pgfplotstableread@curcol=0\relax
	\loop
	\ifnum\pgfplotstableread@curcol<\pgfplotstableread@numcols
%\pgfplots@message{ASSIGNING COLUMN NO \the\pgfplotstableread@curcol / \the\pgfplotstableread@numcols}%
		% numtable@TMP := column list content
		\expandafter\global\expandafter\let\expandafter\pgfplotstable@TMP\csname numtable@col@\the\pgfplotstableread@curcol\endcsname
		% global := numtable@TMP
		\expandafter\global\expandafter\let\csname numtable@col@\the\pgfplotstableread@curcol\endcsname=\pgfplotstable@TMP
		\advance\pgfplotstableread@curcol by1\relax
	\repeat
	\closein1
	\endgroup
	% Now, we can access the global variables!
	% copy them to #3.
	\let#3=\pgfplotstable@colnames
	\c@pgf@counta=0\relax% FIXME !!! THIS SHOULD NOT BE DONE INTO \c@pgf@counta!
	\pgfplotslistforeachungrouped\pgfplotstable@colnames\as\pgfplotstable@TMP{%
		\def\pgfplotstable@TMPB{%
			\expandafter\let\csname\string#3@\pgfplotstable@TMP\endcsname}%
		\expandafter\pgfplotstable@TMPB\csname numtable@col@\the\c@pgf@counta\endcsname
%\message{Column '\pgfplotstable@TMP' has entries: \expandafter\meaning\csname numtable@col@\the\c@pgf@counta\endcsname}%
		\expandafter\global\expandafter\let\csname numtable@col@\the\c@pgf@counta\endcsname=\pgfutil@empty
		\advance\c@pgf@counta by1\relax
	}%
	\global\let\pgfplotstable@colnames=\pgfutil@empty
}

\def\pgfplotstableread@loop@over@lines{%
	\ifeof1
%\pgfplots@message{EOF}%
	\else
		\read1 to\pgfplotstable@LINE
		\ifeof1
		\else
		\expandafter\pgfplotstableread@checkspecial@line\pgfplotstable@LINE\pgfplotstable@EOI
		\ifpgfplotstableread@skipline
		\else
			%--------------------------------------------------
			% \ifnum\pgfplotstableread@lineno=0
			% 	\let\pgfplotstable@firstline=\pgfplotstable@LINE
			% \fi
			%-------------------------------------------------- 
%\pgfplots@message{READING LINE \the\pgfplotstableread@lineno: '\meaning\pgfplotstable@LINE'.}%
			\ifnum\pgfplotstableread@numcols=0\relax
				\pgfplotstableread@curcol=0\relax
				\pgfplotstableread@curline@contains@colnamesfalse
				\expandafter\pgfplotstableread@impl@countcols@and@identifynames@ITERATE\pgfplotstable@LINE\pgfplotstable@EOI
				\pgfplotstableread@numcols=\pgfplotstableread@curcol
				\pgfplotstableread@curcol=0\relax
				% Create empty column lists:
				\pgfplotstableread@create@column@lists
				%
				\ifnum\pgfplotstableread@usablelineno=0\relax
				\ifnum\pgfplotstableread@lineno=2\relax
				\ifnum\pgfplotstableread@numcols=3\relax
					% The file started with
					% #...
					% #...
					% X Y i
					% -> thats a gnuplot file!
					\pgfplotstableread@curline@contains@colnamesfalse
				\fi
				\fi
				\fi
				% Now, read the first line.
				% It contains either
				% - column names,
				% - numerical data,
				% - nothing (comments).
				\ifpgfplotstableread@curline@contains@colnames
					\pgfplotstableread@foundcolnamestrue
					\pgfplotstableread@curcol=0\relax
					\expandafter\pgfplotstableread@impl@collectcolnames@ITERATE\pgfplotstable@LINE\pgfplotstable@EOI
				\else
					\pgfplotstableread@foundcolnamesfalse
					\pgfplotstableread@curcol=0\relax
					% Leave column name lists empty...
					\expandafter\pgfplotstableread@impl@nextrow@ITERATE\pgfplotstable@LINE\pgfplotstable@EOI
				\fi
%\pgfplots@message{After reading first row: found '\the\pgfplotstableread@numcols' columns; column name list='\meaning\pgfplotstable@colnames'}%
			\else
				\pgfplotstableread@curcol=0\relax
				\expandafter\pgfplotstableread@impl@nextrow@ITERATE\pgfplotstable@LINE\pgfplotstable@EOI
			\fi
			\ifnum\pgfplotstableread@curcol=\pgfplotstableread@numcols
			\else
				\pgfplotstable@error{ERROR: the input table has an unexpected number of columns in row '\the\pgfplotstableread@lineno'. Expected: '\the\pgfplotstableread@numcols'; got '\the\pgfplotstableread@curcol. Maybe the input table is corrupted?}%
			\fi
			\advance\pgfplotstableread@usablelineno by1\relax
		\fi
		\fi
		\advance\pgfplotstableread@lineno by1\relax
		\pgfplotstableread@loop@over@lines
	\fi
}

\def\pgfplotstableread@checkspecial@line{%
	\pgfutil@ifnextchar##{%
		\pgfplotstableread@skiplinetrue
		\pgfplotstableread@impl@gobble
	}{%
		\pgfutil@ifnextchar${%
			\pgfplotstableread@process@flags@line
		}{%
			\pgfutil@ifnextchar\pgfplotstable@EOI{%
				\pgfplotstableread@skiplinetrue
				\pgfplotstableread@impl@gobble
			}{%
				\pgfutil@ifnextchar\par{%
					\pgfplotstableread@skiplinetrue
					\pgfplotstableread@impl@gobble
				}{%
					\pgfplotstableread@skiplinefalse
					\pgfplotstableread@impl@gobble
				}%
			}%
		}%
	}%
}

\long\def\pgfplotstableread@process@flags@line$flags {%
%\pgfplots@message{Ignoring flags line ...}%
	\pgfplotstableread@skiplinetrue
	\pgfplotstableread@impl@gobble
}

\def\pgfplotstableread@create@column@lists{%
	\loop
	\ifnum\pgfplotstableread@curcol<\pgfplotstableread@numcols
		\expandafter\pgfplotslistnewempty\csname numtable@col@\the\pgfplotstableread@curcol\endcsname
		\advance\pgfplotstableread@curcol by1\relax
	\repeat
}

\def\pgfplotstableread@create@column@names@with@numbers{%
	\pgfplotstableread@curcol=0\relax
	\loop
	\ifnum\pgfplotstableread@curcol<\pgfplotstableread@numcols
		\expandafter\pgfplotslistpushback\the\pgfplotstableread@curcol\to\pgfplotstable@colnames
		\advance\pgfplotstableread@curcol by1\relax
	\repeat
}

\long\def\pgfplotstableread@impl@gobble#1\pgfplotstable@EOI{}%

\def\pgfplotstable@EOI{\pgfplotstable@EOI}%


\def\pgfplotstableread@impl@nextrow@ITERATE{%
	\pgfutil@ifnextchar\pgfplotstable@EOI{%
		\pgfplotstableread@impl@gobble
	}{%
		\pgfplotstableread@impl@nextrow@NEXT
	}%
}
\long\def\pgfplotstableread@impl@nextrow@NEXT#1 {%
%\pgfplots@message{Inserting '#1' at (\the\pgfplotstableread@lineno, \the\pgfplotstableread@curcol).}%
	\def\pgfplotstableread@TMP{\pgfplotslistpushback#1\to}%
	\expandafter\pgfplotstableread@TMP\csname numtable@col@\the\pgfplotstableread@curcol\endcsname
	\advance\pgfplotstableread@curcol by1\relax
	\pgfplotstableread@impl@nextrow@ITERATE
}



\def\pgfplotstableread@impl@collectcolnames@ITERATE{%
	\pgfutil@ifnextchar\pgfplotstable@EOI{%
		\pgfplotstableread@impl@gobble
	}{%
		\pgfplotstableread@impl@collectcolnames@NEXT
	}%
}
\long\def\pgfplotstableread@impl@collectcolnames@NEXT#1 {%
%\pgfplots@message{Got column name no \the\pgfplotstableread@curcol\ as '#1'}%
	\pgfutil@ifundefined{pgfplotstableread@impl@COLNAME@#1}{%
		\def\pgfplotstable@TMP{#1}%
	}{% generate unique column names
		\pgfplots@warning{Warning: numeric table '\pgfplotstableread@filename' has non-unique column name '#1'. Only the first occurence can be accessed via column names.}%
		\edef\pgfplotstable@TMP{#1--index\the\pgfplotstableread@curcol}%
	}%
	\expandafter\def\csname pgfplotstableread@impl@COLNAME@#1\endcsname{foo}% remember this name.
	\expandafter\pgfplotslistpushback\expandafter{\pgfplotstable@TMP}\to\pgfplotstable@colnames
	\advance\pgfplotstableread@curcol by1\relax
	\pgfplotstableread@impl@collectcolnames@ITERATE
}




\def\pgfplotstableread@impl@countcols@and@identifynames@ITERATE{%
	\pgfutil@ifnextchar\pgfplotstable@EOI{%
		\pgfplotstableread@impl@gobble
	}{%
		\pgfplotstableread@impl@countcols@and@identifynames@NEXT
	}%
}


\long\def\pgfplotstableread@impl@countcols@and@identifynames@NEXT#1 {%
	\advance\pgfplotstableread@curcol by1\relax
	\ifpgfplotstable@search@header
		\ifpgfplotstableread@curline@contains@colnames
		\else
			\pgfplotstableread@isnumber@ITERATE#1\pgfplotstable@EOI
%\ifpgfplotstableread@curline@contains@colnames\pgfplots@message{'#1' is a column name!}\else\pgfplots@message{'#1' is NO column name!}\fi
		\fi
	\fi
	\pgfplotstableread@impl@countcols@and@identifynames@ITERATE
}
\def\pgfplotstableread@isnumber@plus{+}
\def\pgfplotstableread@isnumber@minus{-}
\def\pgfplotstableread@isnumber@zero{0}
\def\pgfplotstableread@isnumber@one{1}
\def\pgfplotstableread@isnumber@two{2}
\def\pgfplotstableread@isnumber@three{3}
\def\pgfplotstableread@isnumber@four{4}
\def\pgfplotstableread@isnumber@five{5}
\def\pgfplotstableread@isnumber@six{6}
\def\pgfplotstableread@isnumber@seven{7}
\def\pgfplotstableread@isnumber@eight{8}
\def\pgfplotstableread@isnumber@nine{9}
\def\pgfplotstableread@isnumber@e{e}
\def\pgfplotstableread@isnumber@E{E}
\def\pgfplotstableread@isnumber@period{.}

\def\pgfplotstableread@isnumber@ITERATE#1{%
	\def\pgfplotstableread@CURTOK{#1}%
	\ifx\pgfplotstableread@CURTOK\pgfplotstable@EOI
		\def\pgfplotstableread@NEXT{}%
	\else
		\def\pgfplotstableread@NEXT{\pgfplotstableread@isnumber@ITERATE}%
		\ifx\pgfplotstableread@CURTOK\pgfplotstableread@isnumber@plus
		\else
		\ifx\pgfplotstableread@CURTOK\pgfplotstableread@isnumber@minus
		\else
		\ifx\pgfplotstableread@CURTOK\pgfplotstableread@isnumber@zero
		\else
		\ifx\pgfplotstableread@CURTOK\pgfplotstableread@isnumber@one
		\else
		\ifx\pgfplotstableread@CURTOK\pgfplotstableread@isnumber@two
		\else
		\ifx\pgfplotstableread@CURTOK\pgfplotstableread@isnumber@three
		\else
		\ifx\pgfplotstableread@CURTOK\pgfplotstableread@isnumber@four
		\else
		\ifx\pgfplotstableread@CURTOK\pgfplotstableread@isnumber@five
		\else
		\ifx\pgfplotstableread@CURTOK\pgfplotstableread@isnumber@six
		\else
		\ifx\pgfplotstableread@CURTOK\pgfplotstableread@isnumber@seven
		\else
		\ifx\pgfplotstableread@CURTOK\pgfplotstableread@isnumber@eight
		\else
		\ifx\pgfplotstableread@CURTOK\pgfplotstableread@isnumber@nine
		\else
		\ifx\pgfplotstableread@CURTOK\pgfplotstableread@isnumber@e
		\else
		\ifx\pgfplotstableread@CURTOK\pgfplotstableread@isnumber@E
		\else
		\ifx\pgfplotstableread@CURTOK\pgfplotstableread@isnumber@period
		\else
%\message{NO ITS NOT!  Token: '\meaning\pgfplotstableread@CURTOK'}%
			% it's no number, so it is a column name.
			\pgfplotstableread@curline@contains@colnamestrue
			\def\pgfplotstableread@NEXT{\pgfplotstableread@impl@gobble}%
		\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi
	\fi
	\pgfplotstableread@NEXT
}

\def\pgfplotstable@error#1{\PackageError{numtable}{#1}{Please refer to the manual for further information.}}%


\def\pgfplotstabletypeset@setkeys{%
	\pgfqkeys{/pgfplots/numeric table}%
}%

% Accepts a macro #1 which contains an argument denoting a column
% name.
%
% It checks whether #1 starts with '#', indicating that it is actually
% a column INDEX. If that is the case,
% \ifpgfplotstableread@foundcolnames is set to false and the index is
% returned into #1.
%
% Otherwise, \ifpgfplotstableread@foundcolnames is set to true.
\def\pgfplotstabletypeset@is@colname#1{%
	\expandafter\pgfplotstabletypeset@is@colname@#1\pgfplotstable@EOI
	\ifpgfplotstableread@foundcolnames
	\else
		\let#1=\pgfplotstable@TMP
	\fi
}%
\def\pgfplotstabletypeset@is@colname@{%
	\pgfutil@ifnextchar[{%
		\pgfplotstabletypeset@is@colname@index
	}{%
		\pgfplotstableread@foundcolnamestrue
		\pgfplotstabletypeset@is@colname@name
	}%
}
\def\pgfplotstabletypeset@is@colname@index@@{index}%
\def\pgfplotstabletypeset@is@colname@index[#1]#2\pgfplotstable@EOI{%
	\def\pgfplotstable@TMP{#1}%
	\ifx\pgfplotstable@TMP\pgfplotstabletypeset@is@colname@index@@
		\pgfplotstableread@foundcolnamesfalse
		\def\pgfplotstable@TMP{#2}%
	\else
		\pgfplotstableread@foundcolnamestrue
	\fi
}%
\def\pgfplotstabletypeset@is@colname@name#1\pgfplotstable@EOI{}%
\def\pgfplotstabletypeset@getfinalentry#1#2{%
	\pgfkeysvalueof{/pgfplots/numeric table/assign cell content/.@cmd}#1\pgfeov
	\pgfkeysgetvalue{/pgfplots/numeric table/@cell content}{#2}%
}%
\def\pgfplotstabletypeset@nocolname{\pgfkeysnovalue}

% TODO
% - replace grouped list foreach by popfront-loop and use arrays
%   directly -> group only the pgfkeys eval
\def\pgfplotstabletypeset@opt[#1]#2{%
	\begingroup
	\pgfplotstabletypeset@setkeys{every table,#1}%
	\pgfkeysgetvalue{/pgfplots/numeric table/columns}{\pgfplotstable@colnames}%
	\ifx\pgfplotstable@colnames\pgfutil@empty
		\pgfplotstablegetcolumnlist#2\to\pgfplotstable@colnames
	\else
		\expandafter\pgfplotslistnew\expandafter\pgfplotstable@colnames\expandafter{\pgfplotstable@colnames}%
	\fi
	\global\pgfplotslistnewempty\pgfplotstabletypeset@final@colnames
	\global\pgfplotslistnewempty\pgfplotstabletypeset@final@coltypes
	\global\pgfplotslistnewempty\pgfplotstabletypeset@final@cols
	\let\c@pgfplotstable@numcols=\c@pgf@counta
	\let\c@pgfplotstable@numrows=\c@pgf@countd
	\let\c@pgfplotstable@rowindex=\c@pgf@countc
	\let\c@pgfplotstable@colindex=\c@pgf@countb
	\pgfplotslistsize\pgfplotstable@colnames\to\c@pgfplotstable@numcols
	\c@pgfplotstable@colindex=0\relax
	\pgfplotslistforeach\pgfplotstable@colnames\as\pgfplotstable@colname{%
		\pgfplotstabletypeset@is@colname\pgfplotstable@colname
		\ifpgfplotstableread@foundcolnames
		\else
			\pgfplotstablegetcolumnnamebyindex\pgfplotstable@colname\of#2\to\pgfplotstable@colname
		\fi
		\pgfplotstablegetcolumnbyname\pgfplotstable@colname\of#2\to\pgfplotstable@col
		%
		% Set keys for columns!
		\ifodd\c@pgfplotstable@colindex
			\pgfplotslist@TOK@a={every odd column}%
		\else
			\pgfplotslist@TOK@a={every even column}%
		\fi
		\ifnum\c@pgfplotstable@colindex=0\relax
			\pgfplotslist@TOK@a=\expandafter{\the\pgfplotslist@TOK@a,every first column}%
		\fi
		\global\advance\c@pgfplotstable@colindex by1\relax
		\ifnum\c@pgfplotstable@colindex=\c@pgfplotstable@numcols
			\pgfplotslist@TOK@a=\expandafter{\the\pgfplotslist@TOK@a,every last column}%
		\fi
		\pgfplotslist@TOK@b=\expandafter{\pgfplotstable@colname}%
		\edef\pgfplotstable@TMP{\the\pgfplotslist@TOK@a,columns/\the\pgfplotslist@TOK@b/.try}%
		\expandafter\pgfplotstabletypeset@setkeys\expandafter{\pgfplotstable@TMP}%
		%
		\pgfkeysgetvalue{/pgfplots/numeric table/column name}{\pgfplotstable@colname@out}%
		\ifx\pgfplotstable@colname@out\pgfplotstabletypeset@nocolname
			\let\pgfplotstable@colname@out=\pgfplotstable@colname
		\fi
		{\globaldefs=1
		\expandafter\pgfplotslistpushback\pgfplotstable@colname@out\to\pgfplotstabletypeset@final@colnames
		}%
		\pgfkeysgetvalue{/pgfplots/numeric table/column type}{\pgfplotstable@coltype}%
		{\globaldefs=1
		\expandafter\pgfplotslistpushback\pgfplotstable@coltype\to\pgfplotstabletypeset@final@coltypes
		}%
		%
		\pgfplotslistnewempty\pgfplotstable@col@processed
		\pgfplotslistforeachungrouped\pgfplotstable@col\as\pgfplotstable@entry{%
			\expandafter\pgfplotstabletypeset@getfinalentry\expandafter{\pgfplotstable@entry}{\pgfplotstable@entry}%
			\expandafter\pgfplotslistpushback\pgfplotstable@entry\to\pgfplotstable@col@processed
		}%
		{\globaldefs=1
		\expandafter\pgfplotslistpushback\expandafter{\pgfplotstable@col@processed}\to\pgfplotstabletypeset@final@cols
		}%
	}%
	%
	% Ok, I have now everything which will come into the final table.
	%
	% But I have it column-oriented; I need to transpose the storage.
	%
	% The following code assembles a
	% \begin{tabular}{}
	% ...
	% \end{tabular}
	% statement piece after piece.
	%
%\message{I have now \meaning\pgfplotstabletypeset@final@colnames, and \meaning\pgfplotstabletypeset@final@cols.}%
	% Step 1: column names.
	\c@pgfplotstable@colindex=0\relax
	% STEP 1.1: collect column types:
	\def\pgfplotstable@resulttypes{}%
	\pgfplotslistforeachungrouped\pgfplotstabletypeset@final@coltypes\as\pgfplotstable@coltype{%
		\pgfplotslist@TOK@a=\expandafter{\pgfplotstable@resulttypes}%
		\pgfplotslist@TOK@b=\expandafter{\pgfplotstable@coltype}%
		\edef\pgfplotstable@resulttypes{\the\pgfplotslist@TOK@a\the\pgfplotslist@TOK@b}%
	}%
	\pgfkeysgetvalue{/pgfplots/numeric table/begin table}{\pgfplotstable@entry}%
	\pgfplotslist@TOK@a=\expandafter{\pgfplotstable@entry}%
	\ifx\pgfplotstable@resulttypes\pgfutil@empty
		\edef\pgfplotstable@result{\the\pgfplotslist@TOK@a}%
	\else
		\pgfplotslist@TOK@b=\expandafter{\pgfplotstable@resulttypes}%
		\edef\pgfplotstable@result{\the\pgfplotslist@TOK@a{\the\pgfplotslist@TOK@b}}%
	\fi
	% Step 1.2: Collect FIRST ROW
	\begingroup
	\pgfplotstabletypeset@setkeys{every head row}%
	\pgfkeysgetvalue{/pgfplots/numeric table/before row}{\pgfplotstable@before}%
	\pgfkeysgetvalue{/pgfplots/numeric table/after row}{\pgfplotstable@after}%
	\global\pgfplotslist@TOK@a=\expandafter{\pgfplotstable@before}%
	\global\pgfplotslist@TOK@b=\expandafter{\pgfplotstable@after}%
	\endgroup
	\edef\pgfplotstable@after{\the\pgfplotslist@TOK@b}%
	\pgfplotslist@TOK@b=\expandafter{\pgfplotstable@result}%
	% insert 'before row' here:
	\edef\pgfplotstable@result{\the\pgfplotslist@TOK@b\the\pgfplotslist@TOK@a}%
	%
	\pgfplotslistforeachungrouped\pgfplotstabletypeset@final@colnames\as\pgfplotstable@colname@out{%
		\advance\c@pgfplotstable@colindex by1\relax
		\pgfplotslist@TOK@a=\expandafter{\pgfplotstable@result}%
		\ifnum\c@pgfplotstable@colindex=\c@pgfplotstable@numcols\relax
			\pgfplotslist@TOK@b=\expandafter{\pgfplotstable@colname@out \\}%
		\else
			\pgfplotslist@TOK@b=\expandafter{\pgfplotstable@colname@out &}%
		\fi
		\edef\pgfplotstable@result{\the\pgfplotslist@TOK@a\the\pgfplotslist@TOK@b}%
	}%
	% insert 'after row' here:
	\pgfplotslist@TOK@a=\expandafter{\pgfplotstable@result}%
	\pgfplotslist@TOK@b=\expandafter{\pgfplotstable@after}%
	\edef\pgfplotstable@result{\the\pgfplotslist@TOK@a\the\pgfplotslist@TOK@b}%
	%
%\message{I have now \meaning\pgfplotstable@result.}%
	% Step 2: column contents.
	% I will first convert \pgfplotstabletypeset@final@cols into an array.
	\c@pgfplotstable@colindex=0\relax
	\pgfplotsarraynewempty\pgfplotstabletypeset@final@cols@array
	\pgfplotslistforeachungrouped\pgfplotstabletypeset@final@cols\as\pgfplotstable@col@processed{%
		\expandafter\pgfplotsarraypushback\expandafter{\pgfplotstable@col@processed}\to\pgfplotstabletypeset@final@cols@array
	}%
	% init numrows:
	\pgfplotsarrayselect\c@pgfplotstable@colindex\of\pgfplotstabletypeset@final@cols@array\to\pgfplotstable@col@processed
	\pgfplotslistsize\pgfplotstable@col@processed\to\c@pgfplotstable@numrows
	%
	% Now, we loop over every column as long as there are still rows
	% left. We assemble rows while we go.
	%
	\c@pgfplotstable@rowindex=0\relax
	\ifnum\c@pgfplotstable@colindex<\c@pgfplotstable@numcols
		\pgfplots@loop@CONTINUEtrue
	\else
		\pgfplots@loop@CONTINUEfalse
	\fi
	\loop
	\ifpgfplots@loop@CONTINUE
		\pgfplotsarrayselect\c@pgfplotstable@colindex\of\pgfplotstabletypeset@final@cols@array\to\pgfplotstable@col@processed
		\pgfplotslistcheckempty\pgfplotstable@col@processed
		\ifpgfplotslistempty
			\pgfplots@loop@CONTINUEfalse
		\else
			\ifnum\c@pgfplotstable@colindex=0\relax
				% Install styles for the next row.
				\begingroup
				\ifodd\c@pgfplotstable@rowindex
					\pgfplotslist@TOK@a={every odd row}%
				\else
					\pgfplotslist@TOK@a={every even row}%
				\fi
				\ifnum\c@pgfplotstable@rowindex=0\relax
					\pgfplotslist@TOK@a=\expandafter{\the\pgfplotslist@TOK@a,every first row}%
				\fi
				% misuse as temporary variable:
				\c@pgfplotstable@colindex=\c@pgfplotstable@rowindex
				\advance\c@pgfplotstable@colindex by1\relax
				\ifnum\c@pgfplotstable@colindex=\c@pgfplotstable@numrows
					\edef\pgfplotstable@TMP{\the\pgfplotslist@TOK@a,every row no \the\c@pgfplotstable@rowindex/.try,every last row}%
				\else
					\edef\pgfplotstable@TMP{\the\pgfplotslist@TOK@a,every row no \the\c@pgfplotstable@rowindex/.try}%
				\fi
				\expandafter\pgfplotstabletypeset@setkeys\expandafter{\pgfplotstable@TMP}%
				\pgfkeysgetvalue{/pgfplots/numeric table/before row}{\pgfplotstable@before}%
				\pgfkeysgetvalue{/pgfplots/numeric table/after row}{\pgfplotstable@after}%
				\global\pgfplotslist@TOK@a=\expandafter{\pgfplotstable@before}%
				\global\pgfplotslist@TOK@b=\expandafter{\pgfplotstable@after}%
				\endgroup
				\edef\pgfplotstable@after{\the\pgfplotslist@TOK@b}%
				\pgfplotslist@TOK@b=\expandafter{\pgfplotstable@result}%
				% insert 'before row' here:
				\edef\pgfplotstable@result{\the\pgfplotslist@TOK@b\the\pgfplotslist@TOK@a}%
			\fi
			%
			%
			\pgfplotslistpopfront\pgfplotstable@col@processed\to\pgfplotstable@entry
			\pgfplotsarrayletentry\c@pgfplotstable@colindex\of\pgfplotstabletypeset@final@cols@array=\pgfplotstable@col@processed
			\advance\c@pgfplotstable@colindex by1\relax
			\pgfplotslist@TOK@a=\expandafter{\pgfplotstable@result}%
			\ifnum\c@pgfplotstable@colindex=\c@pgfplotstable@numcols\relax
				\pgfplotslist@TOK@b=\expandafter{\pgfplotstable@entry \\}%
			\else
				\pgfplotslist@TOK@b=\expandafter{\pgfplotstable@entry &}%
			\fi
			\edef\pgfplotstable@result{\the\pgfplotslist@TOK@a\the\pgfplotslist@TOK@b}%
			\ifnum\c@pgfplotstable@colindex=\c@pgfplotstable@numcols\relax
				\c@pgfplotstable@colindex=0\relax
				% insert 'after row' here:
				\pgfplotslist@TOK@a=\expandafter{\pgfplotstable@result}%
				\pgfplotslist@TOK@b=\expandafter{\pgfplotstable@after}%
				\edef\pgfplotstable@result{\the\pgfplotslist@TOK@a\the\pgfplotslist@TOK@b}%
				\advance\c@pgfplotstable@rowindex by1\relax
			\fi
%\message{I have now \meaning\pgfplotstable@result.}%
		\fi
	\repeat
	\pgfplotslist@TOK@a=\expandafter{\pgfplotstable@result}%
	\pgfkeysgetvalue{/pgfplots/numeric table/end table}{\pgfplotstable@entry}%
	\pgfplotslist@TOK@b=\expandafter{\pgfplotstable@entry}%
	\edef\pgfplotstable@result{\the\pgfplotslist@TOK@a\the\pgfplotslist@TOK@b}%
	\pgfplotstable@result
	\pgfkeysgetvalue{/pgfplots/numeric table/outfile}{\pgfplotstable@entry}%
	\ifx\pgfplotstable@entry\pgfutil@empty
	\else
		\begingroup
		\expandafter\immediate\expandafter\openout\expandafter1\expandafter=\pgfplotstable@entry\relax
		\pgfplotslist@TOK@a=\expandafter{\pgfplotstable@result}%
		\immediate\write1{\the\pgfplotslist@TOK@a}%
		\immediate\closeout1
		\endgroup
	\fi
	\endgroup
}%


\endinput
