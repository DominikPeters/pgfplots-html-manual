%--------------------------------------------
% $Header: /cvsroot/pgfplots/pgfplots/generic/pgfplots/libs/pgflibrarysurfshading.code.tex,v 1.16 2009/03/10 21:34:37 ludewich Exp $
%
% Package pgfplots
%
% Provides a user-friendly interface to create function plots (normal
% plots, semi-logplots and double-logplots).
% 
% It is based on Till Tantau's PGF package.
%
% Copyright 2007/2008 by Christian Feuers√§nger.
%
% This program is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program.  If not, see <http://www.gnu.org/licenses/>.
%
%--------------------------------------------

%--------------------------------------------------
% \pgfqkeys{/pgfplots/surf shading}{
% 	cols=3,
% %	test colormap 1,
% }
% \pgfplotslibrarysurfstreamstart
% \pgfplotslibrarysurfstreamcoord{\pgfqpoint{0pt}{10pt}}{0}
% \pgfplotslibrarysurfstreamcoord{\pgfqpoint{100pt}{10pt}}{100}
% \pgfplotslibrarysurfstreamcoord{\pgfqpoint{180pt}{10pt}}{30}
% %
% \pgfplotslibrarysurfstreamcoord{\pgfqpoint{0pt}{100pt}}{300}
% \pgfplotslibrarysurfstreamcoord{\pgfqpoint{110pt}{90pt}}{1000}
% \pgfplotslibrarysurfstreamcoord{\pgfqpoint{190pt}{110pt}}{600}
% %
% \pgfplotslibrarysurfstreamcoord{\pgfqpoint{0pt}{200pt}}{0}
% \pgfplotslibrarysurfstreamcoord{\pgfqpoint{110pt}{200pt}}{100}
% \pgfplotslibrarysurfstreamcoord{\pgfqpoint{190pt}{200pt}}{60}
% \pgfplotslibrarysurfstreamend
% \fbox{%
% 	\pgfplotslibrarysurfdraw
% }%
%-------------------------------------------------- 


\pgfkeys{%
	% the extends need to provided as \pgfpoint... The boundary box
	% won't be computed manually!
	/pgfplots/surf shading/south west corner/.initial={\pgfpointorigin},%
	/pgfplots/surf shading/north east corner/.initial={\pgfqpoint{6cm}{6cm}},%
	/pgfplots/surf shading/anchor/.initial=\pgfpointorigin,%
	/pgfplots/surf shading/cols/.initial=,%
	/pgfplots/surf shading/colormap/.initial={%
		<<
			/FunctionType 2 
			/Domain [0 1] 
			/C0 [0 0 1] /C1 [1 0 0] /N 1 
			/Range [0 1 0 1 0 1]
		>>
	},%
	/pgfplots/surf shading/test colormap 1/.style={%
		/pgfplots/surf shading/colormap={
			<< 
				/FunctionType 3 
				/Domain [0 1] 
				/Functions [ 
					<< 
						/FunctionType 2 
						/Domain [0 1] 
						/C0 [0 0 1] /C1 [1 1 0] /N 1 
					>>  
					<< 
						/FunctionType 2 
						/Domain [0 1] 
						/C0 [1 1 0] /C1 [1 0.5 0] /N 1 
					>>  
					<< 
						/FunctionType 2 
						/Domain [0 1] 
						/C0 [1 0.5 0] /C1 [1 0 0] /N 1 
					>>
				]
				/Bounds [ 0.3 0.6 ] 
				/Encode [0 1  0 1 0 1] 
				/Range [0 1 0 1 0 1]
			>> 
		}%
	},%
}%

\def\pgfplotslibrarysurf@corner@sw{\pgfkeysvalueof{/pgfplots/surf shading/south west corner}}
\def\pgfplotslibrarysurf@corner@ne{\pgfkeysvalueof{/pgfplots/surf shading/north east corner}}%

\def\pgfplotslibrarysurf@decode{%
	-16383.999992 16384 % see the docs of \pgfplotsbinaryencodedimenmaplinearly
	-16383.999992 16384 %
	0 1 % map [0,2^BitsPerComponent-1] linearly to [0 1] for parametric color data
}%
\def\pgfplotslibrarysurf@count{0}%

\def\pgfplotslibrarysurfstreamstart{%
	\pgfplotsapplistXnewempty\pgfplotslibrarysurf@binarystream@accum
}%
\def\pgfplotslibrarysurfstreamend{%
	\pgfplotsapplistXlet\pgfplotslibrarysurf@binarystream=\pgfplotslibrarysurf@binarystream@accum
}%

% #1: a pgf point.
% #2: a color coordinate in the range [0,1000]
\def\pgfplotslibrarysurfstreamcoord#1#2{%
%\message{SAMPLES NO: \the\c@pgfplots@coordindex.}%
%\advance\c@pgfplots@coordindex by1
	\pgfplotsbinarysetbytes4%
	\pgf@process{#1}%
	% The idea is to map 
	% the low-level point coordinates LINEARLY into [0,2^{8*<bytes>}].
	%
	% This is what the pdf standard expects for surface shadings.
	%
	% To do that, we simply map
	% [-16384,16384] linearly into [0,2^{32}]
	% and write the resulting integer in big endian binary format to
	% the pdf low level stream.
	%
	% The decode procedure tells the pdf viewer how to invert that
	% stuff.
	%
	%% DEBUG NOTE: This mapping appears to work correctly according to
	%% my tests.
	%% For bc -l test codes: 
	%% ibase=16; 
	%% -4000 +  809658FA. / (2^20) * 8000
	%
	% FIXME : these coordinates ARE NOT USER SPACE CORRECTED.
	% SO: either use them as fill path for the surfaces rectangle
	% (which may work, I don't know) or make sure they are mapped
	% correctly into "user space".
	\pgf@sys@bp@correct\pgf@x%
	\pgfplotsbinaryencodedimenmaplinearly\pgf@x
%\message{ENCODING(x=\the\pgf@x)=\pgfplotsbinaryresult.}%
	\t@pgfplots@toka=\expandafter{\pgfplotsbinaryresult}%
	\pgf@sys@bp@correct\pgf@y%
	\pgfplotsbinaryencodedimenmaplinearly\pgf@y
%\message{ENCODING(y=\the\pgf@y)=\pgfplotsbinaryresult.}%
	\t@pgfplots@tokb=\expandafter{\pgfplotsbinaryresult}%
	{%
		% read fixed point input (in the range [0,1000]).
		\pgf@xa=#2pt
		% convert to integer (= *65536):
		\c@pgf@counta=\pgf@xa
		% provide map [0,1000] -> [0,2^16-1]
		\divide\c@pgf@counta by1000
		% now, we have \c@pgf@counta in [0,2^16]. Simply strip it into
		% the required range, that's ok.
		\ifnum\c@pgf@counta<0
			\c@pgf@counta=0
		\else
			\ifnum\c@pgf@counta>65535
				\c@pgf@counta=65535
			\fi
		\fi
		% Now, we have CDATA in the range [0,65535] 
		\xdef\pgfplots@glob@TMPa{\the\c@pgf@counta}%
%\message{ENCODING C = \pgfplots@glob@TMPa\space (for \the\pgf@xa).}%
	}%
	\pgfplotsbinarysetbytes2%
	\pgfplotsbinaryencodeunsigned\pgfplots@glob@TMPa
	\t@pgfplots@tokc=\expandafter{\pgfplotsbinaryresult}%
	\edef\pgfplots@loc@TMPa{\the\t@pgfplots@toka\the\t@pgfplots@tokb\the\t@pgfplots@tokc}%
	\expandafter\pgfplotsapplistXpushback\pgfplots@loc@TMPa\to\pgfplotslibrarysurf@binarystream@accum
}

\def\pgfplotslibrarysurfactivateshadefill{%
	\pgfplotssys@do@surfshading@fillpaths\pgfplots@loc@TMPa%
	\expandafter\pgfutil@addpdfresource@patterns\expandafter{\pgfplots@loc@TMPa}%%
}

%--------------------------------------------------
% \def\pgfplotslibrarysurfdraw{%
% %	\pgftext[at=\pgfqpoint{0pt}{0pt}]%
% 		{\pgfplotssys@do@surfshading}%
% }%
%-------------------------------------------------- 

\def\pgfplotslibrarysurfdrawinpicture{%
	\begingroup
	\pgftransformshift{\pgfplotslibrarysurf@corner@sw}%
	\pgftext[at=\pgfqpoint{0pt}{0pt},left,bottom] {%
		\pgfplotslibrarysurfdraw
% this does NOT work because I can't undo the box' shift:
%\pgfplotssys@do@surfshading
	}%
	\endgroup
}

\pgfplotsiffileexists{pgflibrarysurfshading.\pgfsysdriver}{%
	\input pgflibrarysurfshading.\pgfsysdriver\relax
}{%
	\def\pgfplotslibrarysurfdraw{%
		\pgfplots@error{Sorry, surfshading is NOT available for the selected driver `\pgfsysdriver'.}%
	}%
}
\endinput
