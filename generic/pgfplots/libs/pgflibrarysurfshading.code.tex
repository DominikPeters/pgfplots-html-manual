%--------------------------------------------
% $Header: /cvsroot/pgfplots/pgfplots/generic/pgfplots/libs/pgflibrarysurfshading.code.tex,v 1.13 2009/03/04 22:09:28 ludewich Exp $
%
% Package pgfplots
%
% Provides a user-friendly interface to create function plots (normal
% plots, semi-logplots and double-logplots).
% 
% It is based on Till Tantau's PGF package.
%
% Copyright 2007/2008 by Christian Feuers√§nger.
%
% This program is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program.  If not, see <http://www.gnu.org/licenses/>.
%
%--------------------------------------------

%--------------------------------------------------
% \pgfqkeys{/pgfplots/surf shading}{
% 	cols=3,
% %	test colormap 1,
% }
% \pgfplotslibrarysurfstreamstart
% \pgfplotslibrarysurfstreamcoord{\pgfqpoint{0pt}{10pt}}{0}
% \pgfplotslibrarysurfstreamcoord{\pgfqpoint{100pt}{10pt}}{100}
% \pgfplotslibrarysurfstreamcoord{\pgfqpoint{180pt}{10pt}}{30}
% %
% \pgfplotslibrarysurfstreamcoord{\pgfqpoint{0pt}{100pt}}{300}
% \pgfplotslibrarysurfstreamcoord{\pgfqpoint{110pt}{90pt}}{1000}
% \pgfplotslibrarysurfstreamcoord{\pgfqpoint{190pt}{110pt}}{600}
% %
% \pgfplotslibrarysurfstreamcoord{\pgfqpoint{0pt}{200pt}}{0}
% \pgfplotslibrarysurfstreamcoord{\pgfqpoint{110pt}{200pt}}{100}
% \pgfplotslibrarysurfstreamcoord{\pgfqpoint{190pt}{200pt}}{60}
% \pgfplotslibrarysurfstreamend
% \fbox{%
% 	\pgfplotslibrarysurfdraw
% }%
%-------------------------------------------------- 


\pgfkeys{%
	% the extends need to provided as \pgfpoint... The boundary box
	% won't be computed manually!
	/pgfplots/surf shading/south west corner/.initial={\pgfpointorigin},%
	/pgfplots/surf shading/north east corner/.initial={\pgfqpoint{6cm}{6cm}},%
	/pgfplots/surf shading/anchor/.initial=\pgfpointorigin,%
	/pgfplots/surf shading/cols/.initial=,%
	/pgfplots/surf shading/colormap/.initial={%
		<<
			/FunctionType 2 
			/Domain [0 1] 
			/C0 [0 0 1] /C1 [1 0 0] /N 1 
			/Range [0 1 0 1 0 1]
		>>
	},%
	/pgfplots/surf shading/test colormap 1/.style={%
		/pgfplots/surf shading/colormap={
			<< 
				/FunctionType 3 
				/Domain [0 1] 
				/Functions [ 
					<< 
						/FunctionType 2 
						/Domain [0 1] 
						/C0 [0 0 1] /C1 [1 1 0] /N 1 
					>>  
					<< 
						/FunctionType 2 
						/Domain [0 1] 
						/C0 [1 1 0] /C1 [1 0.5 0] /N 1 
					>>  
					<< 
						/FunctionType 2 
						/Domain [0 1] 
						/C0 [1 0.5 0] /C1 [1 0 0] /N 1 
					>>
				]
				/Bounds [ 0.3 0.6 ] 
				/Encode [0 1  0 1 0 1] 
				/Range [0 1 0 1 0 1]
			>> 
		}%
	},%
}%

\def\pgfplotslibrarysurf@corner@sw{\pgfkeysvalueof{/pgfplots/surf shading/south west corner}}
\def\pgfplotslibrarysurf@corner@ne{\pgfkeysvalueof{/pgfplots/surf shading/north east corner}}%

\def\pgfplotslibrarysurf@decode{%
	-16383.999992 16384 % see the docs of \pgfplotsbinaryencodedimenmaplinearly
	-16383.999992 16384 %
	0 1.0240 % phi: [ 0, 2^16-1 ] -> [ 0, X ] with phi(64000) = 1 is the real maximum. Thus, phi(x) = 1/64000 * x  and phi(2^16-1) is the upper decode limit.
}%
\def\pgfplotslibrarysurf@count{0}%

\def\pgfplotslibrarysurfstreamstart{%
	\pgfplotsapplistXnewempty\pgfplotslibrarysurf@binarystream@accum
}%
\def\pgfplotslibrarysurfstreamend{%
	\pgfplotsapplistXlet\pgfplotslibrarysurf@binarystream=\pgfplotslibrarysurf@binarystream@accum
}%

% #1: a pgf point.
% #2: a color coordinate in the range [0,1000]
\def\pgfplotslibrarysurfstreamcoord#1#2{%
%\message{SAMPLES NO: \the\c@pgfplots@coordindex.}%
%\advance\c@pgfplots@coordindex by1
	\pgfplotsbinarysetbytes4%
	\pgf@process{#1}%
	% The idea is to map 
	% the low-level point coordinates LINEARLY into [0,2^{8*<bytes>}].
	%
	% This is what the pdf standard expects for surface shadings.
	%
	% To do that, we simply map
	% [-16384,16384] linearly into [0,2^{32}]
	% and write the resulting integer in big endian binary format to
	% the pdf low level stream.
	%
	% The decode procedure tells the pdf viewer how to invert that
	% stuff.
	%
	%% DEBUG NOTE: This mapping appears to work correctly according to
	%% my tests.
	%% For bc -l test codes: 
	%% ibase=16; 
	%% -4000 +  809658FA. / (2^20) * 8000
	%
	% FIXME : these coordinates ARE NOT USER SPACE CORRECTED.
	% SO: either use them as fill path for the surfaces rectangle
	% (which may work, I don't know) or make sure they are mapped
	% correctly into "user space".
	\pgf@sys@bp@correct\pgf@x%
	\pgfplotsbinaryencodedimenmaplinearly\pgf@x
%\message{ENCODING(x=\the\pgf@x)=\pgfplotsbinaryresult.}%
	\t@pgfplots@toka=\expandafter{\pgfplotsbinaryresult}%
	\pgf@sys@bp@correct\pgf@y%
	\pgfplotsbinaryencodedimenmaplinearly\pgf@y
%\message{ENCODING(y=\the\pgf@y)=\pgfplotsbinaryresult.}%
	\t@pgfplots@tokb=\expandafter{\pgfplotsbinaryresult}%
	{%
		% convert to pt:
		\pgf@xa=#2pt
		% convert to integer (= *65536):
		\c@pgf@counta=\pgf@xa
		% enlarge data range from 1000*65536 to 16000*65536 ~= 2^14 * 2^16:
		\multiply\c@pgf@counta by16
		% quantize into 16 bit range: divide by 2^14:
		\divide\c@pgf@counta by16384
		% Now, we have CDATA in the range [0,64000] 
		% (the remaining bits are unused)
		\xdef\pgfplots@glob@TMPa{\the\c@pgf@counta}%
	}%
%\message{ENCODING C = \pgfplots@glob@TMPa.}%
	\pgfplotsbinarysetbytes2%
	\pgfplotsbinaryencodeunsigned\pgfplots@glob@TMPa
	\t@pgfplots@tokc=\expandafter{\pgfplotsbinaryresult}%
%	\edef\pgfplots@loc@TMPa{\the\t@pgfplots@toka\the\t@pgfplots@tokb\csname pgfp@bin@128\endcsname\csname pgfp@bin@0\endcsname}%\the\t@pgfplots@tokc}%
	\edef\pgfplots@loc@TMPa{\the\t@pgfplots@toka\the\t@pgfplots@tokb\the\t@pgfplots@tokc}%
	\expandafter\pgfplotsapplistXpushback\pgfplots@loc@TMPa\to\pgfplotslibrarysurf@binarystream@accum
}

\def\pgfplotslibrarysurfactivateshadefill{%
	\pgfplotssys@do@surfshading@fillpaths\pgfplots@loc@TMPa%
	\expandafter\pgfutil@addpdfresource@patterns\expandafter{\pgfplots@loc@TMPa}%%
}

%--------------------------------------------------
% \def\pgfplotslibrarysurfdraw{%
% %	\pgftext[at=\pgfqpoint{0pt}{0pt}]%
% 		{\pgfplotssys@do@surfshading}%
% }%
%-------------------------------------------------- 

\def\pgfplotslibrarysurfdrawinpicture{%
	\begingroup
	\pgftransformshift{\pgfplotslibrarysurf@corner@sw}%
	\pgftext[at=\pgfqpoint{0pt}{0pt},left,bottom] {%
		\pgfplotslibrarysurfdraw
% this does NOT work because I can't undo the box' shift:
%\pgfplotssys@do@surfshading
	}%
	\endgroup
}
\def\pgfplotslibrarysurfdraw{%
	\begingroup
	\setbox\pgfutil@tempboxa=\hbox{%
		\pgfpicture
		\pgfplotssys@do@surfshading@fillpaths\pgfplots@loc@TMPa%
		\global\let\pgfplots@glob@TMPa=\pgfplots@loc@TMPa
		\pgfpathrectanglecorners
			{\pgfplotslibrarysurf@corner@sw}
			{\pgfplotslibrarysurf@corner@ne}%
		\pgfusepath{fill}%
		\endpgfpicture
	}%
	\pdfxform resources{
		/Pattern << \pgfplots@glob@TMPa >> % write the pattern resource dictionary
	}\pgfutil@tempboxa
	\leavevmode
	\pdfrefxform\pdflastxform
	\endgroup
}

% To be used inside of a pgfpicture.
%
% #1: a macro name. The contents of this macro needs to be written
% into the pdf pattern dictionary contained in the pdf resources of
% the current context. The current context is either the current page
% or an xform object.
\def\pgfplotssys@do@surfshading@fillpaths#1{%
	% DEBUG INFO: wenn ich dieses obj hier durch ein einfacheres
	% shading ersetze, klappts auch im acroread!
	\immediate\pdfobj stream attr {%
		% stream length will be computed automatically
		%/Shading 
		/ShadingType 5
		/BitsPerCoordinate 32
		/BitsPerComponent 16
		/VerticesPerRow \pgfkeysvalueof{/pgfplots/surf shading/cols}
		/ColorSpace /DeviceRGB
		/Decode [\pgfplotslibrarysurf@decode]
		/Function 
			\iftrue
				\pgfkeysvalueof{/pgfplots/surf shading/colormap}
			\else
			<< 
				/FunctionType 3 
				/Domain [0.0 10000] 
				/Functions [ 
					<< 
						/FunctionType 2 
						/Domain [0.0 10000] 
						/C0 [0 0 1] /C1 [1 1 0] /N 1 
					>>  
					<< 
						/FunctionType 2 
						/Domain [0.0 10000] 
						/C0 [1 1 0] /C1 [1 0.5 0] /N 1 
					>>  
					<< 
						/FunctionType 2 
						/Domain [0.0 10000] 
						/C0 [1 0.5 0] /C1 [1 0 0] /N 1 
					>>
				]
				/Bounds [ 2300 4600 ] 
				/Encode [0 1  0 1 0 1] 
			>> 
			\fi
	} {%
		\pgfplotslibrarysurf@binarystream
	}%
	\edef\pgfplots@loc@TMPa{\the\pdflastobj}%
	\pgf@process{\pgfpointdiff{\pgfplotslibrarysurf@corner@sw}{\pgfkeysvalueof{/pgfplots/surf shading/anchor}}}%
	\pgf@sys@bp@correct\pgf@x%
	\pgf@sys@bp@correct\pgf@y%
	\immediate\pdfobj {<<
		/Type /Pattern
		/PatternType 2
%		/Matrix [\pgf@pt@aa\space\pgf@pt@ab\space\pgf@pt@ba\space\pgf@pt@bb\space\pgf@sys@tonumber\pgf@pt@x\space\pgf@sys@tonumber\pgf@pt@y]
		% FIXME: INCORPORATE TIKZ CM
		/Matrix [1 0 0 1 \pgf@sys@tonumber\pgf@x\space \pgf@sys@tonumber\pgf@y] %226.533 518.141] 
		%--------------------------------------------------
		% /ExtGState 
		% 	<<
		% 		/LW 2
		% 		/OP true
		% 		/OPM 1
		% 	>>
		%-------------------------------------------------- 
		/Shading 
			% A debug switch:
			\iftrue
				\pgfplots@loc@TMPa\space 0 R 
			\else
			\iftrue
			<<
				/ShadingType 2 
				/ColorSpace /DeviceRGB
				% these coordinates have been choosen consistently
				% with the clip path of my axis rectangle (in a test
				% figure) It's debugging stuff.
				/Coords [-86 0 150 0] 
				/Function 
				<< 
					/FunctionType 2 
					/Domain [0.0 1.0] 
					/C0 [0 0 1] /C1 [1 0 0] /N 1 
				>> 
				/Extend [false false] 
			>> 
			\else
			<<
				/ShadingType 2 
				/ColorSpace /DeviceRGB
				/Domain [0.0 226.76788] 
				/Coords [0.0 0 226.76788 0] 
				/Function 
				<< 
					/FunctionType 3 
					/Domain [0.0 226.76788] 
					/Functions [ 
						<< 
							/FunctionType 2 
							/Domain [0.0 226.76788] 
							/C0 [0 0 1] /C1 [1 1 0] /N 1 
						>>  
						<< 
							/FunctionType 2 
							/Domain [0.0 226.76788] 
							/C0 [1 1 0] /C1 [1 0.5 0] /N 1 
						>>  
						<< 
							/FunctionType 2 
							/Domain [0.0 226.76788] 
							/C0 [1 0.5 0] /C1 [1 0 0] /N 1 
						>>
					]
					/Bounds [ 75.5893 151.17859] 
					/Encode [0 1  0 1 0 1] 
				>> 
				/Extend [false false] 
			>> 
			\fi
			\fi
	>>}%
	\edef#1{%
		/pgfpatPlotsurface\pgfplotslibrarysurf@count\space \the\pdflastobj\space 0 R
		%--------------------------------------------------
		% /pgfpatPlotsurface <<
		% 	/Type /Pattern
		% 	/PatternType 2
		% 	/Shading \the\pdflastobj\space 0 R 
		% >>
		%-------------------------------------------------- 
	}%
	\pgfsys@setpatterncolored{Plotsurface\pgfplotslibrarysurf@count}%
	\pgfplotsutil@advancestringcounter@global\pgfplotslibrarysurf@count
%	\pgfsetfillcolor{blue}%
}

%
% FIXME : DEPRECATED  I can't use the '/sh' operator - it's not
% powerful enough (I need to change /Matrix which is not supported by
% /sh).
%
% DEPRECATED
\def\pgfplotssys@do@surfshading{%
	{%
		\pdfobj stream attr {%
			% stream length will be computed automatically
			%/Shading 
			/ShadingType 5
			/BitsPerCoordinate 32
			/BitsPerComponent 16
			/VerticesPerRow \pgfkeysvalueof{/pgfplots/surf shading/cols}
			/ColorSpace /DeviceRGB
			/Decode [\pgfplotslibrarysurf@decode]
			/Function 
			\iftrue
				\pgfkeysvalueof{/pgfplots/surf shading/colormap}
			\else
			<< 
				/FunctionType 3 
				/Domain [0.0 10000] 
				/Functions [ 
					<< 
						/FunctionType 2 
						/Domain [0.0 10000] 
						/C0 [0 0 1] /C1 [1 1 0] /N 1 
					>>  
					<< 
						/FunctionType 2 
						/Domain [0.0 10000] 
						/C0 [1 1 0] /C1 [1 0.5 0] /N 1 
					>>  
					<< 
						/FunctionType 2 
						/Domain [0.0 10000] 
						/C0 [1 0.5 0] /C1 [1 0 0] /N 1 
					>>
				]
				/Bounds [ 2000 6000 ] 
				/Encode [0 1  0 1 0 1] 
			>> 
			\fi
		} {%
			\pgfplotslibrarysurf@binarystream
		}%
		%--------------------------------------------------
		% \pdfobj {%
		% 	/TemporaryShade % this can be deleted. I use it to check what works - substitute /Plotsurface with /TemporaryShade to activate it.
		% 	<<
		% 		/ShadingType 2 
		% 		/ColorSpace /DeviceRGB
		% 		/Domain [0.0 226.76788] 
		% 		/Coords [0.0 0 226.76788 0] 
		% 		/Function 
		% 		<< 
		% 			/FunctionType 3 
		% 			/Domain [0.0 226.76788] 
		% 			/Functions [ 
		% 				<< 
		% 					/FunctionType 2 
		% 					/Domain [0.0 226.76788] 
		% 					/C0 [0 0 1] /C1 [1 1 0] /N 1 
		% 				>>  
		% 				<< 
		% 					/FunctionType 2 
		% 					/Domain [0.0 226.76788] 
		% 					/C0 [1 1 0] /C1 [1 0.5 0] /N 1 
		% 				>>  
		% 				<< 
		% 					/FunctionType 2 
		% 					/Domain [0.0 226.76788] 
		% 					/C0 [1 0.5 0] /C1 [1 0 0] /N 1 
		% 				>>
		% 			]
		% 			/Bounds [ 75.5893 151.17859] 
		% 			/Encode [0 1  0 1 0 1] 
		% 		>> 
		% 		/Extend [false false] 
		% 	>> 
		% }%
		%-------------------------------------------------- 
		% I don't know how to insert the shading into a properly sized PDF entity - this here appears to work.
		\pgfpointdiff%
			{\pgfplotslibrarysurf@corner@sw}%
			{\pgfplotslibrarysurf@corner@ne}%
		\setbox\pgfutil@tempboxa=\hbox to\pgf@x{%
			\vbox to\pgf@y{%
				\vfil
				\pgfsys@invoke{%
					/Plotsurface\pgfplotslibrarysurf@count\space sh% invoke 'sh'ading operator on /Plotsurface
				}%
			}%
			\hfil}%
		\pdfxform resources {%
			% the /Shading is a resource directory (predefined name)
			% while /Plotsurface is my name. Since type 5 shadings are
			% a stream, we need to reference them this way:
			/Shading << /Plotsurface\pgfplotslibrarysurf@count\space \the\pdflastobj\space 0 R >>
		}\pgfutil@tempboxa
		\pgfplotsutil@advancestringcounter@global\pgfplotslibrarysurf@count
		%--------------------------------------------------
		% \pgf@process{\pgfpoint{\pgf@max}{#2}}%
		% \pdfxform resources {%
		% 	/Shading << 
		% 		/Sh << 
		% /Length <BYTES>
		% 			/ShadingType 5
		% 			/BitsPerCoordinate 32
		% 			/BitsPerComponent 16
		% 			/VerticesPerRow \pgfplotslibrarysurf@cols
		% 			/ColorSpace /DeviceRGB
		% 			/Decode [xmin xmax ymin ymax c1min c1max c2min c2max c3min c3max ]
		% 		>> 
		% 	>>}\pgfutil@tempboxa% <<
		%-------------------------------------------------- 
		\xdef\pgfplots@glob@TMPa{%
			\leavevmode
			\noexpand\pdfrefobj\the\pdflastobj
			\noexpand\pdfrefxform\the\pdflastxform}% 
	}%
	\pgfplots@glob@TMPa
}
