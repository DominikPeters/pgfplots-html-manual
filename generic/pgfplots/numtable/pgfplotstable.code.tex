%--------------------------------------------
%
% Package numtable
%
% Provides support to read and work with abstact numeric tables of the
% form
%
% COLUMN1	COLUMN2 COLUMN3
% 1 		2		3
% 4			4		552
% 1e124		0.00001	1.2345e-12
% ...
%
% Copyright 2007/2008 by Christian Feuers√§nger.
%
% This program is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program.  If not, see <http://www.gnu.org/licenses/>.
%
%--------------------------------------------

\newif\ifpgfplotstable@search@header
\newcount\c@pgfplotstable@counta
\newwrite\pgfplotstable@outfile
\newif\ifpgfplotstabletypesetdebug
\newif\ifpgfplotstableuserow
\newif\ifpgfplotstabletypeset@includeoutfiles
\newif\ifpgfplotstabletypeset@force@remake

% should always be false; use only in grouped internal macros
\newif\ifpgfplots@table@options@areset
\newif\ifpgfplots@tableread@to@listener

\input pgfplotstable.coltype.code.tex

% #1= floating point number
% #2= TeX code to execute if #1 == 0
% #3= TeX code to execute if #1 != 0
\def\pgfplots@ifzero#1#2#3{%
	\expandafter\pgfmathfloat@decompose@F#1\relax\pgfmathfloat@a@S
	\ifnum\pgfmathfloat@a@S=0 #2\else#3\fi
}%

% just make sure no-one complaints if manual example are used without
% booktabs loaded:
\pgfutil@ifundefined{toprule}{%
	\def\toprule{\pgfplots@assert@LaTeX@package@loaded{booktabs}{\string\toprule}}%
	\def\midrule{\pgfplots@assert@LaTeX@package@loaded{booktabs}{\string\midrule}}%
	\def\bottomrule{\pgfplots@assert@LaTeX@package@loaded{booktabs}{\string\bottomrule}}%
}{\relax}%

% keys which are NOT predefined:
% /pgfplots/table/alias/<col alias>/.initial={<real col>}
% /pgfplots/table/columns/<col name>/.style={}
% /pgfplots/table/display columns/<col index>/.style={}
% /pgfplots/table/create on use/<col name>/.style={create options}
\pgfkeys{%
	/pgfplots/table/header/.is if=pgfplotstable@search@header,
	/pgfplots/table/header=true,
	/pgfplots/table/x index/.store in=\pgfplots@plot@tbl@xindex,
	/pgfplots/table/x index=0,
	/pgfplots/table/x/.store in=\pgfplots@plot@tbl@x,
	/pgfplots/table/x=,
	/pgfplots/table/y index/.store in=\pgfplots@plot@tbl@yindex,
	/pgfplots/table/y index=1,
	/pgfplots/table/y/.store in=\pgfplots@plot@tbl@y,
	/pgfplots/table/y=,
	/pgfplots/table/x error index/.initial=,
	/pgfplots/table/y error index/.initial=,
	/pgfplots/table/x error/.initial=,
	/pgfplots/table/y error/.initial=,
	/pgfplots/table/row predicate/.code={},
	/pgfplots/table/skip rows between index/.style 2 args={%
		/pgfplots/table/row predicate/.append code={%
			\ifnum##1<#1\relax
			\else
				\ifnum##1<#2\relax
					\pgfplotstableuserowfalse
				\fi
			\fi}
	},
	/pgfplots/table/select equal part entry of/.style 2 args={%
		/pgfplots/table/row predicate/.code={%
			\pgfplotstableuserowtrue
			\begingroup
			% this group re-uses counters as temporary variables.
			\c@pgfplotstable@colindex=\pgfplotstablerows\relax
			\divide\c@pgfplotstable@colindex by#2\relax
			\edef\pgfplotstablepartsize{\the\c@pgfplotstable@colindex}%
			% This here should create empty cells such that
			% remaining entries are distributed equally:
			\c@pgfplotstable@rowindex=\c@pgfplotstable@colindex
			\multiply\c@pgfplotstable@rowindex by#2\relax
			\ifnum\c@pgfplotstable@rowindex<\pgfplotstablerows\relax
				\c@pgfplotstable@colindex=\pgfplotstablerows\relax
				\advance\c@pgfplotstable@colindex by-\c@pgfplotstable@rowindex
				\advance\c@pgfplotstable@colindex by\pgfplotstablepartsize				
				\edef\pgfplotstablepartsize{\the\c@pgfplotstable@colindex}%
			\fi
			%
			\multiply\c@pgfplotstable@colindex by#1\relax
			\ifnum##1<\c@pgfplotstable@colindex\relax
				\aftergroup\pgfplotstableuserowfalse
			\else
				\advance\c@pgfplotstable@colindex by\pgfplotstablepartsize\relax
				\ifnum##1<\c@pgfplotstable@colindex\relax
				\else
					\aftergroup\pgfplotstableuserowfalse
				\fi
			\fi
			\endgroup
		}%
	},
	/pgfplots/table/col sep/.is choice,
	/pgfplots/table/col sep/space/.code		= {\def\pgfplotstableread@COLSEP@CASE{0}},
	/pgfplots/table/col sep/comma/.code		= {\def\pgfplotstableread@COLSEP@CASE{1}},
	/pgfplots/table/col sep/semicolon/.code	= {\def\pgfplotstableread@COLSEP@CASE{2}},
	/pgfplots/table/col sep/colon/.code		= {\def\pgfplotstableread@COLSEP@CASE{3}},
	/pgfplots/table/col sep/braces/.code	= {\def\pgfplotstableread@COLSEP@CASE{4}},
	/pgfplots/table/col sep=space,
	% columns={name1,name2}
	% or
	% columns={[index]2,name2,name3,[index]5}
	/pgfplots/table/columns/.initial=,
	/pgfplots/table/column name/.initial=\pgfkeysnovalue,
	%
	% this thing here allows to MODIFY 'column name'.
	%
	% Argument #1 is the current column name, that means after
	% evaluating 'column name'. If this key changes anything, it
	% should write its result back into 'column name'.
	%
	% That means you can use 'column name' to assign the name as such
	% and 'assign column name' to generate final TeX code (for example
	% to insert \multicolumn{1}{c}{#1} or so).
	% default is empty which means no change.
	%/pgfplots/table/assign column name/.code={
	%	\pgfkeyssetvalue{/pgfplots/table/column name}{#1}%
	%},
	%
	%
	%
	% A style which inserts \multicolumn{1}{#1}{<column name>} for
	% each column name.
	% The column name as such can be set with the 'column name' option.
	/pgfplots/table/multicolumn names/.style={%
		/pgfplots/table/assign column name/.code={%
			\pgfkeyssetvalue{/pgfplots/table/column name}{\multicolumn{1}{#1}{##1}}%
		}%
	},
	/pgfplots/table/multicolumn names/.default=c,
	/pgfplots/table/dec sep align/.code={%
		\pgfplots@assert@LaTeX@package@loaded{array}{dec sep align}%
		\pgfkeysalso{%
		/pgf/number format/assume math mode,
		/pgf/number format/@dec sep mark={&},
		/pgfplots/table/assign column name/.code={%
			\pgfkeyssetvalue{/pgfplots/table/column name}{\multicolumn{2}{#1}{##1}}%
		},%
		/pgfplots/table/column type={>{$}r<{$}@{}>{$}l<{$}},
		/pgfplots/table/assign cell content/.code={%
			\def\pgfmathresult{##1}%
			\ifx\pgfmathresult\pgfutil@empty
				\def\pgfmathresult{&}%
			%	\pgfutil@in@false
			\else
				\pgfmathprintnumberto{##1}\pgfmathresult%
			%	\expandafter\pgfutil@in@\expandafter&\expandafter{\pgfmathresult}%
			\fi
			%\ifpgfutil@in@
			%\else
			%	\expandafter\def\expandafter\pgfmathresult\expandafter{\pgfmathresult&}%
			%\fi
			\pgfkeyslet{/pgfplots/table/@cell content}\pgfmathresult
		},
		}%
	},
	/pgfplots/table/dec sep align/.default=c,
	/pgfplots/table/sci sep align/.code={%
		\pgfplots@assert@LaTeX@package@loaded{array}{sci sep align}%
		\pgfkeysalso{%
		/pgf/number format/assume math mode,
		/pgf/number format/@sci exponent mark={&},
		/pgfplots/table/assign column name/.code={%
			\pgfkeyssetvalue{/pgfplots/table/column name}{\multicolumn{2}{#1}{##1}}%
		},%
		/pgfplots/table/column type={>{$}r<{$}@{}>{$}l<{$}},
		/pgfplots/table/assign cell content/.code={%
			\def\pgfmathresult{##1}%
			\ifx\pgfmathresult\pgfutil@empty
				\def\pgfmathresult{&}%
				\pgfutil@in@true
			\else
				\pgfmathprintnumberto{##1}\pgfmathresult%
				\expandafter\pgfutil@in@\expandafter&\expandafter{\pgfmathresult}%
			\fi
			\ifpgfutil@in@
			\else
				\expandafter\def\expandafter\pgfmathresult\expandafter{\pgfmathresult&}%
			\fi
			\pgfkeyslet{/pgfplots/table/@cell content}\pgfmathresult
		},
		}%
	},
	/pgfplots/table/sci sep align/.default=c,
	%
	% A style which can be used together with the 'dcolumn' package by
	% David Carlisle.
	% #1: the dcolumn type, defaults to 'D{.}{.}{2}'
	% #2: the column name type, defaults to 'c'
	/pgfplots/table/dcolumn/.style 2 args={%
		/pgf/number format/assume math mode,
		column type={#1},
		multicolumn names=#2,
	},
	/pgfplots/table/dcolumn/.default={D{.}{.}{2}}{c},
	/pgfplots/table/column type/.initial={c},
	/pgfplots/table/every table/.style={},
	/pgfplots/table/every even row/.style={},
	/pgfplots/table/every odd row/.style={},
	/pgfplots/table/every last row/.style={},
	/pgfplots/table/every first row/.style={},
	/pgfplots/table/every head row/.style={},
	/pgfplots/table/every first column/.style={},
	/pgfplots/table/every last column/.style={},
	/pgfplots/table/every even column/.style={},
	/pgfplots/table/every odd column/.style={},
	/pgfplots/table/before row/.initial=,
	/pgfplots/table/after row/.initial=,
	/pgfplots/table/begin table/.initial={\begin{tabular}},
	/pgfplots/table/end table/.initial={\end{tabular}},
	/pgfplots/table/outfile/.initial=,
	/pgfplots/table/include outfiles/.is if=pgfplotstabletypeset@includeoutfiles,
	/pgfplots/table/include outfiles/.default=true,
	/pgfplots/table/force remake/.is if=pgfplotstabletypeset@force@remake,
	/pgfplots/table/force remake/.default=true,
	/pgfplots/table/debug/.is if=pgfplotstabletypesetdebug,
	%
	% will be redefined by |assign cell content| for every cell:
	/pgfplots/table/@cell content/.initial=,
	%
	% #1: the cells content as it has been found in the input table
	% this command key should somehow fill |cell content|.
	/pgfplots/table/assign cell content/.code={%
		\def\pgfmathresult{#1}%
		\ifx\pgfmathresult\pgfutil@empty
		\else
			\pgfmathprintnumberto{#1}\pgfmathresult%
		\fi
		\pgfkeyslet{/pgfplots/table/@cell content}\pgfmathresult
	},
	%
	% this here is the default formatting. It uses
	% \pgfmathprintnumber.
	/pgfplots/table/assign cell content as number/.code={%
		\def\pgfmathresult{#1}%
		\ifx\pgfmathresult\pgfutil@empty
		\else
			\pgfmathprintnumberto{#1}\pgfmathresult%
		\fi
		\pgfkeyslet{/pgfplots/table/@cell content}\pgfmathresult
	},
	/pgfplots/table/string type/.style={%
		/pgfplots/table/assign cell content/.style={%
			/pgfplots/table/@cell content={##1}%
		}%
	},%
	/pgfplots/table/set content/.style={%
		/pgfplots/table/postproc cell content/.style={%
			/pgfplots/table/@cell content={#1}%
		}%
	},%
	%
	/pgfplots/table/postproc cell content/.code={},
	/pgfplots/table/preproc cell content/.code={},
	%
	/pgfplots/table/clear infinite/.style={%
		/pgfplots/table/preproc cell content/.append code={%
			\pgfkeysgetvalue{/pgfplots/table/@cell content}\pgfmathresult
			\ifx\pgfmathresult\pgfutil@empty
			\else
				\pgfmathfloatparsenumber{\pgfmathresult}%
				\let\pgfmatharga=\pgfmathresult
				{%
				\pgfmathfloatgetflags\pgfmatharga\c@pgfplotstable@counta
				\xdef\pgfplots@glob@TMPc{\the\c@pgfplotstable@counta}%
				}%
				\ifnum\pgfplots@glob@TMPc<3
					\pgfmathfloattosci@\pgfmathresult
					\pgfkeyslet{/pgfplots/table/@cell content}{\pgfmathresult}%
				\else
					\pgfkeyslet{/pgfplots/table/@cell content}{\pgfutil@empty}%
				\fi
			\fi
		}
	},
	/pgfplots/table/multiply -1/.style={%
		/pgfplots/table/preproc cell content/.append code={%
			\pgfkeysgetvalue{/pgfplots/table/@cell content}\pgfmathresult
			\ifx\pgfmathresult\pgfutil@empty
			\else
				\pgfmathfloatparsenumber{\pgfmathresult}%
				\let\pgfmatharga=\pgfmathresult
				\pgfmathfloatcreate{2}{1.0}{0}%
				\let\pgfmathargb=\pgfmathresult
				\pgfmathfloatmultiply@{\pgfmatharga}{\pgfmathargb}%
				\pgfmathfloattosci@\pgfmathresult
				\pgfkeyslet{/pgfplots/table/@cell content}{\pgfmathresult}%
			\fi
		}
	},
	/pgfplots/table/empty cells with/.style={%
		/pgfplots/table/postproc cell content/.append code={%
			\ifnum\pgfplotstablepartno=0
				\pgfkeysgetvalue{/pgfplots/table/@cell content}\pgfmathresult
				\ifx\pgfmathresult\pgfutil@empty
					\pgfkeyssetvalue{/pgfplots/table/@cell content}{#1}%
				\fi
			\fi
		}%
	},
	%
	/pgfplots/table/font/.initial=,
	/pgfplots/table/.unknown/.code={%
		\pgfqkeys{/pgf/number format}{\pgfkeyscurrentname=#1}%
	},%
	/pgfplots/table/create col/assign first/.style={
		/pgfplots/table/create col/assign%
	},
	/pgfplots/table/create col/assign last/.style={
		/pgfplots/table/create col/assign%
	},
	/pgfplots/table/create col/assign/.style={
		/pgfplots/table/create col/next content={}%
	},
	/pgfplots/table/create col/next content/.initial={},
	/pgfplots/table/create col/expr/.style={%
		/pgfplots/table/create col/assign/.code={%
			\pgfmathparse{#1}%
			\pgfkeyslet{/pgfplots/table/create col/next content}\pgfmathresult%
		}%
	},%
	/pgfplots/table/create col/quotient/.style={%
		/pgfplots/table/columns={#1},
		/pgfplots/table/create col/assign first/.style={%
			/pgfplots/table/create col/next content=
		},%
		/pgfplots/table/create col/assign/.code={%
			\pgfmathfloatparsenumber{\prevrow{#1}}%
			\let\pgfmatharga=\pgfmathresult
			\pgfmathfloatparsenumber{\thisrow{#1}}%
			\let\pgfmathargb=\pgfmathresult
			\let\pgfmathaccuma=\pgfmathargb
			\pgfplots@ifzero\pgfmathargb{%
				\pgfkeyslet{/pgfplots/table/create col/next content}\pgfutil@empty%
			}{%
				\pgfmathfloatdivide@{\pgfmatharga}{\pgfmathargb}%
				\expandafter\pgfmathfloattosci@\expandafter{\pgfmathresult}%
				\pgfkeyslet{/pgfplots/table/create col/next content}\pgfmathresult%
			}%
		}%
	},%
	/pgfplots/table/create col/iquotient/.style={%
		/pgfplots/table/columns={#1},
		/pgfplots/table/create col/assign first/.style={%
			/pgfplots/table/create col/next content=
		},%
		/pgfplots/table/create col/assign/.code={%
			\pgfmathfloatparsenumber{\prevrow{#1}}%
			\let\pgfmathargb=\pgfmathresult
			\pgfmathfloatparsenumber{\thisrow{#1}}%
			\let\pgfmatharga=\pgfmathresult
			\let\pgfmathaccuma=\pgfmathargb
			\pgfplots@ifzero\pgfmathargb{%
				\pgfkeyslet{/pgfplots/table/create col/next content}\pgfutil@empty%
			}{%
				\pgfmathfloatdivide@{\pgfmatharga}{\pgfmathargb}%
				\expandafter\pgfmathfloattosci@\expandafter{\pgfmathresult}%
				\pgfkeyslet{/pgfplots/table/create col/next content}\pgfmathresult%
			}%
		}%
	},%
	%
	% Produces 'log2( \prevrow{#1}/\thisrow{#1} )
	%
	% Assumeing that every row contains error(h) = O(h^alpha)
	% and h_this = h_prev/2, this result in 'alpha', the convergence
	% rate.
	/pgfplots/table/create col/dyadic refinement rate/.style={%
		/pgfplots/table/columns={#1},
		/pgfplots/table/create col/assign first/.style={%
			/pgfplots/table/create col/next content=
		},%
		/pgfplots/table/create col/assign/.code={%
			\pgfmathfloatparsenumber{\prevrow{#1}}%
			\let\pgfmatharga=\pgfmathresult
			\pgfmathfloatparsenumber{\thisrow{#1}}%
			\let\pgfmathargb=\pgfmathresult
			\let\pgfmathaccuma=\pgfmathargb
			\pgfplots@ifzero\pgfmathargb{%
				\pgfkeyslet{/pgfplots/table/create col/next content}\pgfutil@empty%
			}{%
				\pgfmathfloatdivide@{\pgfmatharga}{\pgfmathargb}%
				\pgfmathlog@float{\pgfmathresult}%
				\ifx\pgfmathresult\pgfutil@empty
				\else
					\pgfmathmultiply@{1.442695}{\pgfmathresult}%
				\fi
				\pgfkeyslet{/pgfplots/table/create col/next content}\pgfmathresult%
			}%
		}%
	},%
	/pgfplots/table/create col/idyadic refinement rate/.style={%
		/pgfplots/table/columns={#1},
		/pgfplots/table/create col/assign first/.style={%
			/pgfplots/table/create col/next content=
		},%
		/pgfplots/table/create col/assign/.code={%
			\pgfmathfloatparsenumber{\prevrow{#1}}%
			\let\pgfmathargb=\pgfmathresult
			\pgfmathfloatparsenumber{\thisrow{#1}}%
			\let\pgfmatharga=\pgfmathresult
			\let\pgfmathaccuma=\pgfmathargb
			\pgfplots@ifzero\pgfmathargb{%
				\pgfkeyslet{/pgfplots/table/create col/next content}\pgfutil@empty%
			}{%
				\pgfmathfloatdivide@{\pgfmatharga}{\pgfmathargb}%
				\pgfmathlog@float{\pgfmathresult}%
				\ifx\pgfmathresult\pgfutil@empty
				\else
					\pgfmathmultiply@{1.442695}{\pgfmathresult}%
				\fi
				\pgfkeyslet{/pgfplots/table/create col/next content}\pgfmathresult%
			}%
		}%
	},%
	/pgfplots/table/create col/gradient/.style 2 args={%
		/pgfplots/table/columns={#1,#2},
		/pgfplots/table/create col/assign first/.code={%
			\pgfmathfloatparsenumber{\thisrow{#1}}%
			\let\pgfmathaccuma=\pgfmathresult
			\pgfmathfloatparsenumber{\thisrow{#2}}%
			\let\pgfmathaccumb=\pgfmathresult
			\def\pgfmathresult{}% leave first empty.
			\pgfkeyslet{/pgfplots/table/create col/next content}\pgfmathresult%
		},%
		/pgfplots/table/create col/assign/.code={%
			\let\pgfmathcur@x=\pgfmathaccuma
			\let\pgfmathcur@y=\pgfmathaccumb
			\pgfmathfloatparsenumber{\thisrow{#1}}%
			\let\pgfmathnext@x=\pgfmathresult
			\let\pgfmathaccuma=\pgfmathnext@x
			\pgfmathfloatparsenumber{\thisrow{#2}}%
			\let\pgfmathnext@y=\pgfmathresult
			\let\pgfmathaccumb=\pgfmathnext@y
			\pgfmathfloatsubtract@{\pgfmathnext@x}{\pgfmathcur@x}%
			\let\pgfmathdiff@x=\pgfmathresult
			\pgfmathfloatsubtract@{\pgfmathnext@y}{\pgfmathcur@y}%
			\let\pgfmathdiff@y=\pgfmathresult
			\pgfplots@ifzero\pgfmathdiff@x{%
				\pgfkeyslet{/pgfplots/table/create col/next content}\pgfutil@empty%
			}{%
				\pgfmathfloatdivide@{\pgfmathdiff@y}{\pgfmathdiff@x}%
				\expandafter\pgfmathfloattosci@\expandafter{\pgfmathresult}%
				\pgfkeyslet{/pgfplots/table/create col/next content}\pgfmathresult%
			}%
		},%
	},%
	/pgfplots/table/create col/gradient loglog/.style 2 args={%
		/pgfplots/table/columns={#1,#2},
		/pgfplots/table/create col/assign first/.code={%
			\pgfmathlog{\thisrow{#1}}%
			\let\pgfmathaccuma=\pgfmathresult
			\pgfmathlog{\thisrow{#2}}%
			\let\pgfmathaccumb=\pgfmathresult
			\def\pgfmathresult{}% leave first empty.
			\pgfkeyslet{/pgfplots/table/create col/next content}\pgfmathresult%
		},%
		/pgfplots/table/create col/assign/.code={%
			\let\pgfmathcur@x=\pgfmathaccuma
			\let\pgfmathcur@y=\pgfmathaccumb
			\pgfmathlog{\thisrow{#1}}%
			\let\pgfmathnext@x=\pgfmathresult
			\let\pgfmathaccuma=\pgfmathresult
			\pgfmathlog{\thisrow{#2}}%
			\let\pgfmathnext@y=\pgfmathresult
			\let\pgfmathaccumb=\pgfmathresult
			\pgfplots@loop@CONTINUEtrue
			\ifx\pgfmathcur@x\pgfutil@empty		\pgfplots@loop@CONTINUEfalse\fi
			\ifx\pgfmathcur@y\pgfutil@empty		\pgfplots@loop@CONTINUEfalse\fi
			\ifx\pgfmathnext@x\pgfutil@empty	\pgfplots@loop@CONTINUEfalse\fi
			\ifx\pgfmathnext@y\pgfutil@empty	\pgfplots@loop@CONTINUEfalse\fi
			\ifpgfplots@loop@CONTINUE
				\pgfmathsubtract@{\pgfmathnext@x}{\pgfmathcur@x}%
				\let\pgfmathdiff@x=\pgfmathresult
				\pgfmathsubtract@{\pgfmathnext@y}{\pgfmathcur@y}%
				\let\pgfmathdiff@y=\pgfmathresult
				\ifdim\pgfmathdiff@x pt=0.0pt
					\pgfkeyslet{/pgfplots/table/create col/next content}\pgfutil@empty%
				\else
					\pgfmathdivide@{\pgfmathdiff@y}{\pgfmathdiff@x}%
					\pgfkeyslet{/pgfplots/table/create col/next content}\pgfmathresult%
				\fi
			\else
			%	\pgfmathfloatcreate{3}{0.0}{0}%
			%	\pgfmathfloattosci@\pgfmathresult
			%	\pgfkeyslet{/pgfplots/table/create col/next content}\pgfmathresult%
				\pgfkeyslet{/pgfplots/table/create col/next content}\pgfutil@empty%
			\fi
		},%
	},%
	/pgfplots/table/create col/gradient semilogx/.style 2 args={%
		/pgfplots/table/columns={#1,#2},
		/pgfplots/table/create col/assign first/.code={%
			\pgfmathlog{\thisrow{#1}}%
			\ifx\pgfmathresult\pgfutil@empty
				\pgfmathfloatcreate{3}{0.0}{0}%
			\else
				\expandafter\pgfmathfloatqparsenumber\expandafter{\pgfmathresult}%
			\fi
			\let\pgfmathaccuma=\pgfmathresult
			\pgfmathfloatparsenumber{\thisrow{#2}}%
			\let\pgfmathaccumb=\pgfmathresult
			\def\pgfmathresult{}% leave first empty.
			\pgfkeyslet{/pgfplots/table/create col/next content}\pgfmathresult%
		},%
		/pgfplots/table/create col/assign/.code={%
			\let\pgfmathcur@x=\pgfmathaccuma
			\let\pgfmathcur@y=\pgfmathaccumb
			\pgfmathlog{\thisrow{#1}}%
			\ifx\pgfmathresult\pgfutil@empty
				\pgfmathfloatcreate{3}{0.0}{0}%
			\else
				\expandafter\pgfmathfloatqparsenumber\expandafter{\pgfmathresult}%
			\fi
			\let\pgfmathnext@x=\pgfmathresult
			\let\pgfmathaccuma=\pgfmathresult
			%
			\pgfmathfloatparsenumber{\thisrow{#2}}%
			\let\pgfmathnext@y=\pgfmathresult
			\let\pgfmathaccumb=\pgfmathresult
			\pgfmathfloatsubtract@{\pgfmathnext@x}{\pgfmathcur@x}%
			\let\pgfmathdiff@x=\pgfmathresult
			\pgfmathfloatsubtract@{\pgfmathnext@y}{\pgfmathcur@y}%
			\let\pgfmathdiff@y=\pgfmathresult
			\pgfplots@ifzero\pgfmathdiff@x{%
				\pgfkeyslet{/pgfplots/table/create col/next content}\pgfutil@empty%
			}{%
				\pgfmathfloatdivide@{\pgfmathdiff@y}{\pgfmathdiff@x}%
				\expandafter\pgfmathfloattosci@\expandafter{\pgfmathresult}%
				\pgfkeyslet{/pgfplots/table/create col/next content}\pgfmathresult%
			}%
		},%
	},%
	/pgfplots/table/create col/gradient semilogy/.style 2 args={%
		/pgfplots/table/columns={#1,#2},
		/pgfplots/table/create col/assign first/.code={%
			\pgfmathfloatparsenumber{\thisrow{#1}}%
			\let\pgfmathaccuma=\pgfmathresult
			\pgfmathlog{\thisrow{#2}}%
			\ifx\pgfmathresult\pgfutil@empty
				\pgfmathfloatcreate{3}{0.0}{0}%
			\else
				\expandafter\pgfmathfloatqparsenumber\expandafter{\pgfmathresult}%
			\fi
			\let\pgfmathaccumb=\pgfmathresult
			\def\pgfmathresult{}% leave first empty.
			\pgfkeyslet{/pgfplots/table/create col/next content}\pgfmathresult%
		},%
		/pgfplots/table/create col/assign/.code={%
			\let\pgfmathcur@x=\pgfmathaccuma
			\let\pgfmathcur@y=\pgfmathaccumb
			\pgfmathlog{\thisrow{#2}}%
			\ifx\pgfmathresult\pgfutil@empty
				\pgfmathfloatcreate{3}{0.0}{0}%
			\else
				\expandafter\pgfmathfloatparsenumber\expandafter{\pgfmathresult}%
			\fi
			\let\pgfmathnext@y=\pgfmathresult
			\let\pgfmathaccumb=\pgfmathresult
			%
			\pgfmathfloatparsenumber{\thisrow{#1}}%
			\let\pgfmathnext@x=\pgfmathresult
			\let\pgfmathaccuma=\pgfmathresult
			\pgfmathfloatsubtract@{\pgfmathnext@x}{\pgfmathcur@x}%
			\let\pgfmathdiff@x=\pgfmathresult
			\pgfmathfloatsubtract@{\pgfmathnext@y}{\pgfmathcur@y}%
			\let\pgfmathdiff@y=\pgfmathresult
			\pgfplots@ifzero\pgfmathdiff@x{%
				\pgfkeyslet{/pgfplots/table/create col/next content}\pgfutil@empty%
			}{%
				\pgfmathfloatdivide@{\pgfmathdiff@y}{\pgfmathdiff@x}%
				\expandafter\pgfmathfloattosci@\expandafter{\pgfmathresult}%
				\pgfkeyslet{/pgfplots/table/create col/next content}\pgfmathresult%
			}%
		},%
	},%
}
\pgfkeysgetvalue{/pgfplots/table/postproc cell content/.@cmd}\pgfplotstable@postproccellcontent@EMPTY

% \pgfplotstableread[OPTIONS] {FILE} to \name
%
% This method reads a table from FILE to macro \name.
%
% FILE is something like
% G	Basis	dof	L2	A	Lmax	cgiter	maxlevel	eps
% 5	5	5	8.31160034e-02	0.00000000e+00	1.80007647e-01	2	2	-1
% 17	17	17	2.54685628e-02	0.00000000e+00	3.75580565e-02	5	3	-1
% ...
%
% A number format line is also understood:
% G	Basis	dof	L2	A	Lmax	cgiter	maxlevel	eps
% $flags int	int	int	sci:8	sci:8	sci:8	int	int	std:8
% 5	5	5	8.31160034e-02	0.00000000e+00	1.80007647e-01	2	2	-1
%
% or a three-column-gnuplot file with 2 comment headers like
% #Curve 0, 20 points
% #x y type
% 0.00000 0.00000 i
% 0.52632 0.50235 i
%
% The table data is stored columnwise in lists and can be accessed
% with the other methods of this package.
%
% \pgfplotstableread[<options>]{<file>}{<\macro>}
% \pgfplotstableread[<options>]{<file>} to listener{<\macro>}
%
% The 'to listener' variant does NOT assemble a table data structure.
% Instead, it processes the input table row-wise and invokes <\macro>
% after each complete row. During the evaluation of <\macro>, the
% following methods can be used to query values:
%   \pgfplotstablereadgetcolindex{<index>}{<\macro>}
%   \pgfplotstablereadgetcolname{<name>}{<\macro>}
% Attention: 'to listener' is scoped by TeX groups, so any assignments
% need to be done globally (or with aftergroup magic).
\def\pgfplotstableread{%
	\pgfutil@ifnextchar[{%
		\pgfplotstableread@impl
	}{%
		\pgfplotstableread@impl[]%
	}%
}

% BACKWARDS COMPATIBILITY
\let\pgfnumtableread=\pgfplotstableread

\def\pgfplotstablegetcolumnlist#1\to#2{\let#2=#1}

% Returns a column vector in form of \pgfplotslist
% into #3.
%
% #1: the column name (not a macro)
% #2: the table structure
% #3: the output macro name.
\def\pgfplotstablegetcolumnbyname#1\of#2\to#3{%
	\pgfutil@ifundefined{\string#2@#1}{%
		% Oh, there is no column '#1' in table '#2'!
		%
		% Ok, then check for the 'create on use' and the 'alias'
		% features...
		% 1. create on use:
		%
		% WARNING : this code has been REPLICATED in
		% *** \pgfplotstablereadgetptrtocolname ***
		% *** \pgfplotstablegetcolumnbyname ***
		% *** \pgfplotstableresolvecolname ***
		\def\pgfplotstable@loc@TMPa{/pgfplots/table/create on use/#1}%
		\pgfkeysifdefined{\pgfplotstable@loc@TMPa/.@cmd}{%	
			% aah - a 'create on use' style exists. Apply it!
			\expandafter\pgfplotstablecreatecol\expandafter[\pgfplotstable@loc@TMPa]{#1}{#2}%
			% and return the newly generated col:
			\expandafter\let\expandafter#3\csname\string#2@#1\endcsname
		}{%
			% ok, then it is either an alias or it is simply not
			% existant.
			\def\pgfplotstable@loc@TMPa{/pgfplots/table/alias/#1}%
			\pgfkeysifdefined{\pgfplotstable@loc@TMPa}{%
				\pgfkeysgetvalue{\pgfplotstable@loc@TMPa}{\pgfplotstable@loc@TMPb}%
				\let\pgfplotstable@loc@TMPa=\pgfplotstable@loc@TMPb
				\pgfutil@ifundefined{\string#2@\pgfplotstable@loc@TMPa}{%
					\pgfplots@error{Sorry, could not retrieve aliased column '\pgfplotstable@loc@TMPa' from table '\pgfplotstablenameof{#2}'. The original request was for '#1', which does not exist either.}%
					\pgfplotslistnewempty#3
				}{%
					\expandafter\let\expandafter#3\csname\string#2@\pgfplotstable@loc@TMPa\endcsname
				}%
			}{%
				\pgfplots@error{Sorry, could not retrieve column '#1' from table '\pgfplotstablenameof{#2}'. Please check spelling (or introduce name aliases).}%
				\pgfplotslistnewempty#3
			}%
		}%
	}{%
		\expandafter\let\expandafter#3\csname\string#2@#1\endcsname
	}%
}

% Retrieves the column *NAME* '#1' of table #2 and writes it into
% '#3'.
%
% If there is no such column, column aliases will be checked. Finally
% if there are no aliases, the command fails with an error.
%
% The 'create on use' statements can't be used in this context.
% @see \pgfplotstablegetcolumnbyname
%
% #1: a column name (not a macro)
% #2: the table structure
% #3: a macro name which will be filled with the (probably modified)
% column name into #2.
\def\pgfplotstableresolvecolname#1\of#2\to#3{%
	\pgfutil@ifundefined{\string#2@#1}{%
		% Oh, there is no column '#1' in table '#2'!
		%
		% Ok, then check for the 'alias' feature ...
		%
		% WARNING : this code has been REPLICATED in
		% *** \pgfplotstablereadgetptrtocolname ***
		% *** \pgfplotstablegetcolumnbyname ***
		% *** \pgfplotstableresolvecolname ***
		\def\pgfplotstable@loc@TMPa{/pgfplots/table/alias/#1}%
		\pgfkeysifdefined{\pgfplotstable@loc@TMPa}{%
			\pgfkeysgetvalue{\pgfplotstable@loc@TMPa}{\pgfplotstable@loc@TMPb}%
			\let\pgfplotstable@loc@TMPa=\pgfplotstable@loc@TMPb
			\pgfutil@ifundefined{\string#2@\pgfplotstable@loc@TMPa}{%
				\def\pgfplotstable@loc@TMPb{/pgfplots/table/create on use/#1}%
				\pgfkeysifdefined{\pgfplotstable@loc@TMPb/.@cmd}{%
					\pgfplots@error{Sorry, '\pgfplotstable@loc@TMPb' from table '\pgfplotstableread@filename' can't be evaluated in this context. Please prepare the table before using it here.}%
				}{%
					\pgfplots@error{Sorry, could not retrieve aliased column '\pgfplotstable@loc@TMPa' from table '\pgfplotstablenameof{#2}'. The original request was for '#1', which does not exist either.}%
				}%
				\let#3=\pgfutil@empty
			}{%
				\let#3=\pgfplotstable@loc@TMPa
			}%
		}{%
			\pgfplots@error{Sorry, could not retrieve column '#1' from table '\pgfplotstablenameof{#2}'. Please check spelling (or introduce name aliases).}%
			\let#3=\pgfutil@empty
		}%
	}{%
		\def#3{#1}%
	}%
}

% Invokes either \pgfplotstablegetcolumnbyindex or
% \pgfplotstablegetcolumnbyname.
\def\pgfplotstablegetcolumn#1\of#2\to#3{%
	\pgfplotstable@is@colname{#1}%
	\ifpgfplotstableread@foundcolnames
	\else
		\pgfplotstablegetcolumnnamebyindex{#1}\of{#2}\to{#3}
	\fi
	\pgfplotstablegetcolumnbyname{#1}\of#2\to{#3}%
}%

\def\pgfplotstablegetcolumnnamebyindex#1\of#2\to#3{%
	\pgfplotslistselect#1\of#2\to#3\relax
}%
\def\pgfplotstablegetcolumnbyindex#1\of#2\to#3{%
	\pgfplotslistselect#1\of#2\to#3\relax
	\expandafter\pgfplotstablegetcolumnbyname#3\of#2\to{#3}%
}

\def\pgfplotstablecopy#1\to#2{%
	\let#2=#1%
	\pgfplotstablegetname#2\pgfplotstable@loc@TMPa
	\expandafter\let\csname\string#1@@table@name\endcsname=\pgfplotstable@loc@TMPa
	\pgfplotslistforeachungrouped#1\as\pgfplotstable@loc@TMPa{%
		\def\pgfplotstable@loc@TMPb{%
			\expandafter\let\csname\string#2@\pgfplotstable@loc@TMPa\endcsname}%
		\expandafter\pgfplotstable@loc@TMPb\csname\string#1@\pgfplotstable@loc@TMPa\endcsname
	}%
}

% Returns the file name of table '#1' into macro #2.
\def\pgfplotstablegetname#1#2{%
	\expandafter\let\expandafter#2\csname\string#1@@table@name\endcsname
}
	
% expands to the table file name of table '#1'
\def\pgfplotstablenameof#1{%
	\csname\string#1@@table@name\endcsname
}

% Creates a new column named #1 and appends it to table #2.
%
% The column entries will be created using the command keys
% 'create col/assign' 
% 'create col/assign last'
%
% The key 'create col/assign' will be invoked for every row of table #2.
% It is supposed to assign the key 'create col/next content'.
% During evaluation of 'create col/assign', the macro '\thisrow{<col name>}' 
% expands to the current row's value of the column named by <col name>.
% Furthermore, '\nextrow{<col name>}' expands to the \emph{next} row's
% value of the designated column.
%
% Since the "next row" is not available if we are currently processing
% the last row, 'create col/assign last' is used in for the last row's
% value.
%
% You can use
% - \thisrow{<col name>}, 
% - \getthisrow{<col name>}{\macro}
% - \nextrow{<col name>}, 
% - \getnextrow{<col name>}{\macro}
\def\pgfplotstablecreatecol{%
	\pgfutil@ifnextchar[{%
		\pgfplotstablecreatecol@opt
	}{%
		\pgfplotstablecreatecol@opt[]%
	}%
}%


% Typesets a table.
%
% \pgfplotstabletypeset[<options>]<\tablestructure>
%
% If you do not select any columns, the complete table is drawn.
%
% There are several options and styles which are available in
% <options>, see the declaration above.
%
% ATTENTION: the default implementation employs
% \begin{tabular}...\end{tabular} and is therefor only usable with
% LaTeX!
%
% You will need to reconfigure the tables.
%
% Inside of \pgfplotstabletypeset, the macros \pgfplotstablecol and
% \pgfplotstablerow will expand to the current column index and row
% index.
\def\pgfplotstabletypeset{%
	\pgfutil@ifnextchar[{%	
		\pgfplotstabletypeset@opt
	}{%
		\pgfplotstabletypeset@opt[]%
	}%
}

% Like \pgfplotstabletypeset, but the first argument is a file name.
\def\pgfplotstabletypesetfile{%
	\pgfutil@ifnextchar[{%	
		\pgfplotstabletypesetfile@opt
	}{%
		\pgfplotstabletypesetfile@opt[]%
	}%
}
\def\pgfplotstabletypesetfile@opt[#1]#2{%
	\begingroup
	\ifpgfplots@table@options@areset
	\else
		\pgfplots@table@options@aresettrue
		\pgfplotstableset{/pgfplots/table/every table={#2},#1}%
	\fi
	\ifpgfplotstabletypeset@force@remake
		\pgfplotstabletypeset@includeoutfilesfalse
	\else
		\ifpgfplotstabletypeset@includeoutfiles
			\pgfplotstabletypeset@includeoutfilesfalse
			\pgfkeysgetvalue{/pgfplots/table/outfile}\pgfplotstable@outfilename
			\ifx\pgfplotstable@outfilename\pgfutil@empty
			\else
				\openin1=\pgfplotstable@outfilename\relax
				\ifeof1 
				\else
					\pgfplotstabletypeset@includeoutfilestrue
				\fi
				\closein1
			\fi
		\fi
	\fi
	\ifpgfplotstabletypeset@includeoutfiles
		\input \pgfplotstable@outfilename\relax	
	\else
		\pgfplotstableread{#2}\pgfplotstabletypesetfile@opt@@
		\pgfplotstabletypeset\pgfplotstabletypesetfile@opt@@
	\fi
	\endgroup
}%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% IMPLEMENTATION
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newif\ifpgfplotstableread@curline@contains@colnames
\newif\ifpgfplotstableread@foundcolnames
\newif\ifpgfplotstableread@skipline

% Accept one of
% \pgfplotstableread[#1]{<file>}{<\macro>}
% \pgfplotstableread[#1]{<file>} to listener{<\macro>}
% or
% \pgfplotstableread[#1]{<file>} to {<\macro>} (DEPRECATED)
\def\pgfplotstableread@impl[#1]#2{%
	\pgfutil@ifnextchar t{%
		\pgfplotstableread@impl@@{#1}{#2}%
	}{%
		\pgfplotstableread@impl@{#1}{#2}%
	}%
}%

% I don't know why; but I started with 
% >> \pgfplotstableread[]{file} to \macro
% That ' to ' is really ugly. This here is for backwards
% compatibility:
\def\pgfplotstableread@impl@@#1#2to {%
	\pgfutil@ifnextchar l{%
		\pgfplotstableread@impl@@listener{#1}{#2}%
	}{%
		\pgfplotstableread@impl@{#1}{#2}%
	}%
}%
\def\pgfplotstableread@impl@@listener#1#2listener#3{%
	\pgfplots@tableread@to@listenertrue
	\pgfplotstableread@impl@{#1}{#2}{#3}%
	\pgfplots@tableread@to@listenerfalse
}%

\def\pgfplotstableread@impl@#1#2#3{%
	\begingroup
	\ifpgfplots@table@options@areset
	\else
		\pgfplotstableset{/pgfplots/table/every table={#2},#1}%
	\fi
%\pgfplots@message{ATTEMPTING TO READ #2}%
	\openin1=#2.tex
	\ifeof1
		\openin1=#2\relax
	\else
		\pgfplots@warning{%
			You requested to open table '#2', but there is also a '#2.tex'. 
			TeX will automatically append the suffix '.tex', so I will now open '#2.tex'.
			Please make sure you don't accidentally load TeX files - this may produce unrecoverable errors.}%
		\closein1
		\openin1=#2\relax
	\fi
	\def\pgfplotstableread@filename{#2}%
	\let\pgfplotstableread@lineno=\c@pgf@counta
	\let\pgfplotstableread@numcols=\c@pgf@countb
	\let\pgfplotstableread@curcol=\c@pgf@countc
	\let\pgfplotstableread@usablelineno=\c@pgf@countd
	\pgfplotstableread@lineno=0
	\pgfplotstableread@usablelineno=0
	\pgfplotstableread@numcols=0
	\global\pgfplotslistnewempty\pgfplotstable@colnames
	\ifeof1
		\pgfplotstable@error{Could not read table file '#2'.}%
		\global\pgfplotslistnewempty\pgfplotstable@colnames
	\else
		\ifpgfplots@tableread@to@listener
			\let\pgfplotstable@listener=#3%
			\let\pgfplotstableread@impl@nextrow@NEXT=\pgfplotstableread@impl@nextrow@NEXT@listener
			\let\pgfplotstablereadgetcolindex=\pgfplotstablereadgetcolindex@
			\let\pgfplotstablereadgetcolname=\pgfplotstablereadgetcolname@
			\let\pgfplotstablereadgetptrtocolname=\pgfplotstablereadgetptrtocolname@
			\let\pgfplotstablereadgetptrtocolindex=\pgfplotstablereadgetptrtocolindex@
			\let\pgfplotstablereadevalptr=\pgfplotstablereadevalptr@
		\fi
		%
		\pgfplotstableread@loop@over@lines
		\closein1
		%
		\pgfplotstableread@finish
	\fi
	\endgroup
	\ifpgfplots@tableread@to@listener
		% there are no data structures in this case.
	\else
		% Now, we can access the global variables!
		% copy them to #3.
		\let#3=\pgfplotstable@colnames
		\expandafter\def\csname\string#3@@table@name\endcsname{#2}%
		\c@pgfplotstable@counta=0\relax%
		\pgfplotslistforeachungrouped\pgfplotstable@colnames\as\pgfplotstable@loc@TMPa{%
			\def\pgfplotstable@loc@TMPb{%
				\expandafter\let\csname\string#3@\pgfplotstable@loc@TMPa\endcsname}%
			\expandafter\pgfplotstable@loc@TMPb\csname pgfp@numtable@glob@col@\the\c@pgfplotstable@counta\endcsname
	%\message{Column '\pgfplotstable@loc@TMPa' has entries: \expandafter\meaning\csname pgfp@numtable@glob@col@\the\c@pgfplotstable@counta\endcsname}%
			\expandafter\global\expandafter\let\csname pgfp@numtable@glob@col@\the\c@pgfplotstable@counta\endcsname=\pgfutil@empty
			\advance\c@pgfplotstable@counta by1\relax
		}%
	\fi
	\global\let\pgfplotstable@colnames=\pgfutil@empty
}

\def\pgfplotstableread@finish{%
	\ifpgfplots@tableread@to@listener
	\else
		\ifpgfplotstableread@foundcolnames
		\else
			\pgfplotstableread@create@column@names@with@numbers
		\fi
		\pgfplotstableread@curcol=0\relax%
		\pgfutil@loop
		\ifnum\pgfplotstableread@curcol<\pgfplotstableread@numcols
			\expandafter\pgfplotsapplistXflushbuffers\csname pgfp@numtable@glob@col@\the\pgfplotstableread@curcol\endcsname
			\advance\pgfplotstableread@curcol by1
		\pgfutil@repeat
	\fi
}

\def\pgfplotstableread@loop@over@lines{%
	\ifeof1
%\pgfplots@message{EOF}%
	\else
		\read1 to\pgfplotstable@LINE
		\ifeof1
		\else
		\expandafter\pgfplotstableread@checkspecial@line\pgfplotstable@LINE\pgfplotstable@EOI
		\ifpgfplotstableread@skipline
		\else
			%--------------------------------------------------
			% \ifnum\pgfplotstableread@lineno=0
			% 	\let\pgfplotstable@firstline=\pgfplotstable@LINE
			% \fi
			%-------------------------------------------------- 
%\pgfplots@message{READING LINE \the\pgfplotstableread@lineno: '\meaning\pgfplotstable@LINE'.}%
			\pgfplotstableread@curline@contains@colnamesfalse
			\ifnum\pgfplotstableread@numcols=0\relax
				\pgfplotstableread@curcol=0\relax
				\pgfplotstableread@impl@DO\pgfplotstableread@impl@countcols@and@identifynames@NEXT\pgfplotstable@LINE
				%\expandafter\pgfplotstableread@impl@countcols@and@identifynames@ITERATE\pgfplotstable@LINE\pgfplotstable@EOI
				\pgfplotstableread@numcols=\pgfplotstableread@curcol
				\pgfplotstableread@curcol=0\relax
				% Create empty column lists:
				\pgfplotstableread@create@column@lists
				%
				\ifnum\pgfplotstableread@usablelineno=0\relax
				\ifnum\pgfplotstableread@lineno=2\relax
				\ifnum\pgfplotstableread@numcols=3\relax
					% The file started with
					% #...
					% #...
					% X Y i
					% -> thats a gnuplot file!
					\pgfplotstableread@curline@contains@colnamesfalse
				\fi
				\fi
				\fi
				% Now, read the first line.
				% It contains either
				% - column names,
				% - numerical data,
				% - nothing (comments).
				\ifpgfplotstableread@curline@contains@colnames
					\pgfplotstableread@foundcolnamestrue
					\pgfplotstableread@curcol=0\relax
					\pgfplotstableread@impl@DO\pgfplotstableread@impl@collectcolnames@NEXT\pgfplotstable@LINE
					%\expandafter\pgfplotstableread@impl@collectcolnames@ITERATE\pgfplotstable@LINE\pgfplotstable@EOI
				\else
					\pgfplotstableread@foundcolnamesfalse
					\pgfplotstableread@curcol=0\relax
					% Leave column name lists empty...
					\pgfplotstableread@impl@DO\pgfplotstableread@impl@nextrow@NEXT\pgfplotstable@LINE
					%\expandafter\pgfplotstableread@impl@nextrow@ITERATE\pgfplotstable@LINE\pgfplotstable@EOI
				\fi
%\pgfplots@message{After reading first row: found '\the\pgfplotstableread@numcols' columns; column name list='\meaning\pgfplotstable@colnames'}%
			\else
				\pgfplotstableread@curcol=0\relax
				\pgfplotstableread@impl@DO\pgfplotstableread@impl@nextrow@NEXT\pgfplotstable@LINE
				%\expandafter\pgfplotstableread@impl@nextrow@ITERATE\pgfplotstable@LINE\pgfplotstable@EOI
			\fi
			\ifnum\pgfplotstableread@curcol=\pgfplotstableread@numcols
			\else
				\pgfplotstable@error{ERROR: the input table has an unexpected number of columns in row '\the\pgfplotstableread@lineno'. Expected: '\the\pgfplotstableread@numcols'; got '\the\pgfplotstableread@curcol. Maybe the input table is corrupted?}%
			\fi
			\ifpgfplots@tableread@to@listener
				\ifpgfplotstableread@curline@contains@colnames
				\else
					% report row!
					\pgfplotstable@listener
				\fi
			\fi
			\advance\pgfplotstableread@usablelineno by1\relax
		\fi
		\fi
		\advance\pgfplotstableread@lineno by1\relax
		\expandafter\pgfplotstableread@loop@over@lines
	\fi
}

% WARNING: this routine is also use in pgfplots.code.tex ...
\def\pgfplotstableread@checkspecial@line{%
	\pgfutil@ifnextchar##{%
		\pgfplotstableread@skiplinetrue
		\pgfplotstableread@impl@gobble
	}{%
		\pgfutil@ifnextchar${%
			\pgfplotstableread@process@flags@line
		}{%
			\pgfutil@ifnextchar\pgfplotstable@EOI{%
				\pgfplotstableread@skiplinetrue
				\pgfplotstableread@impl@gobble
			}{%
				\pgfutil@ifnextchar\par{%
					\pgfplotstableread@skiplinetrue
					\pgfplotstableread@impl@gobble
				}{%
					\pgfplotstableread@skiplinefalse
					\pgfplotstableread@impl@gobble
				}%
			}%
		}%
	}%
}

\long\def\pgfplotstableread@process@flags@line$flags {%
%\pgfplots@message{Ignoring flags line ...}%
	\pgfplotstableread@skiplinetrue
	\pgfplotstableread@impl@gobble
}

\def\pgfplotstableread@create@column@lists{%
	\pgfutil@loop
	\ifnum\pgfplotstableread@curcol<\pgfplotstableread@numcols
		\def\pgfplots@loc@TMPa{\pgfplotsapplistXnewempty[to global]}%
		\expandafter\pgfplots@loc@TMPa\csname pgfp@numtable@glob@col@\the\pgfplotstableread@curcol\endcsname
		\advance\pgfplotstableread@curcol by1\relax
	\pgfutil@repeat
}

\def\pgfplotstableread@create@column@names@with@numbers{%
	\pgfplotstableread@curcol=0\relax
	\pgfutil@loop
	\ifnum\pgfplotstableread@curcol<\pgfplotstableread@numcols
		\expandafter\pgfplotslistpushbackglobal\the\pgfplotstableread@curcol\to\pgfplotstable@colnames
		\advance\pgfplotstableread@curcol by1\relax
	\pgfutil@repeat
}

\long\def\pgfplotstableread@impl@gobble#1\pgfplotstable@EOI{}%

\def\pgfplotstable@EOI{\pgfplotstable@EOI}%

%%%%%%%%%%%%%%%

% A loop command which processes every single entry in a raw data row #2 
% and invokes the macro #1{<arg>}  for each found column entry.
%
% Columns are separated by the /pgfplots/table/col sep character.
%
% #1: a command which takes precisely one argument. It will be called
% for each found column entry
%
% #2: a macro containing a raw data line with <col sep> separated
% entries.
\def\pgfplotstableread@impl@DO#1#2{%
	\let\pgfplotstableread@impl@ITERATE@NEXT@=#1\relax
	\ifcase\pgfplotstableread@COLSEP@CASE\relax
		% SPACE:
		\expandafter\pgfplotstableread@impl@ITERATE#2\pgfplotstable@EOI
	\or
		% COMMA:
		\let\pgfplotstableread@impl@ITERATE@NEXT=\pgfplotstableread@impl@ITERATE@NEXT@COMMA
		\expandafter\pgfplotstableread@impl@ITERATE#2,\pgfplotstable@EOI
	\or
		% SEMICOLON:
		\let\pgfplotstableread@impl@ITERATE@NEXT=\pgfplotstableread@impl@ITERATE@NEXT@SEMICOLON
		\expandafter\pgfplotstableread@impl@ITERATE#2;\pgfplotstable@EOI
	\or
		% COLON:
		\let\pgfplotstableread@impl@ITERATE@NEXT=\pgfplotstableread@impl@ITERATE@NEXT@COLON
		\expandafter\pgfplotstableread@impl@ITERATE#2:\pgfplotstable@EOI
	\or
		% BRACE:
		\let\pgfplotstableread@impl@ITERATE@NEXT=\pgfplotstableread@impl@ITERATE@NEXT@BRACE
		\expandafter\pgfplotstableread@impl@ITERATE#2\pgfplotstable@EOI
	\fi
}%
\def\pgfplotstableread@impl@ITERATE{%
	\pgfutil@ifnextchar\pgfplotstable@EOI{%
		\pgfplotstableread@impl@gobble
	}{%
		\pgfplotstableread@impl@ITERATE@NEXT
	}%
}%
\def\pgfplotstableread@impl@ITERATE@NEXT#1 {%
	\pgfplotstableread@impl@ITERATE@NEXT@{#1}%
	\pgfplotstableread@impl@ITERATE
}%
\def\pgfplotstableread@impl@ITERATE@NEXT@COMMA#1,{%
	\pgfplotstableread@impl@ITERATE@NEXT@{#1}%
	\pgfplotstableread@impl@ITERATE
}%
\def\pgfplotstableread@impl@ITERATE@NEXT@SEMICOLON#1;{%
	\pgfplotstableread@impl@ITERATE@NEXT@{#1}%
	\pgfplotstableread@impl@ITERATE
}%
\def\pgfplotstableread@impl@ITERATE@NEXT@COLON#1:{%
	\pgfplotstableread@impl@ITERATE@NEXT@{#1}%
	\pgfplotstableread@impl@ITERATE
}%
\def\pgfplotstableread@impl@ITERATE@NEXT@BRACE#1{%
	\pgfplotstableread@impl@ITERATE@NEXT@{#1}%
	\pgfplotstableread@impl@ITERATE
}%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% these values are only usable for a read-listener, that means:
% when using
%
% \pgfplotstableread{<file>} to listener<\macro>
%
% -> <\macro> can than use the methods
%
% \pgfplotstablereadgetcolindex{<index>}{<\content>}
% performs \let\content=<content of column no <index> >
\def\pgfplotstablereadgetcolindex@#1#2{%
	\pgfutil@ifundefined{pgfplotstblread@colcontent@no#1}{%
		\pgfplots@error{Sorry, the requested column number '#1' in table '\pgfplotstableread@filename' does not exist!? Please verify you used the correct index 0 <= i < N.}%
		\let#2=\pgfutil@empty
	}{%
		\expandafter\let\expandafter#2\csname pgfplotstblread@colcontent@no#1\endcsname
	}%
}%

% \pgfplotstablereadgetcolname{<index>}{<name>}
% performs \let\content=<content of column named <name> >
\def\pgfplotstablereadgetcolname@#1#2{%
	\pgfplotstablereadgetptrtocolname{#1}{\pgfplots@loc@TMPa}%
	\pgfplotstablereadevalptr\pgfplots@loc@TMPa{#2}%
}%

% \pgfplotstablereadgetptrtocolname{<name>}{\ptr}
% Creates some sort of "pointer" to the column named <name>. This
% pointer can than be used every time a new line has been reported to
% the listener. IT works like this:
%
% \let\ptr=\pgfutil@empty
% \def\macro{%
% 	\ifx\ptr\empty
% 		\pgfplotstablereadgetptrtocolname{<my col>}{\ptr}%
% 	\fi
% 	\pgfplotstablereadevalptr{\ptr}{\content}%
% 	-> do something with \content!
% }
% 	
% \pgfplotstableread{<file>} to listener<\macro>
%
% -> will evaluate \macro foreach row.
\def\pgfplotstablereadgetptrtocolname@#1#2{%
	% Implementation note: it is necessary to replicate code becuase
	% in this context, the table structure is NOT available.
	\pgfutil@ifundefined{pgfplotstblread@colindex@for@name#1}{%
		% Oh, there is no column '#1'!
		%
		% Check for the 'alias' feature!
		%
		% WARNING : this code has been REPLICATED in
		% *** \pgfplotstablereadgetptrtocolname ***
		% *** \pgfplotstablegetcolumnbyname ***
		% *** \pgfplotstableresolvecolname ***
		%
		\def\pgfplotstable@loc@TMPa{/pgfplots/table/alias/#1}%
		\pgfkeysifdefined{\pgfplotstable@loc@TMPa}{%
			\pgfkeysgetvalue{\pgfplotstable@loc@TMPa}{\pgfplotstable@loc@TMPb}%
			\let\pgfplotstable@loc@TMPa=\pgfplotstable@loc@TMPb
			\pgfutil@ifundefined{pgfplotstblread@colindex@for@name\pgfplotstable@loc@TMPa}{%
				\pgfplots@error{Sorry, could not retrieve aliased column '\pgfplotstable@loc@TMPa' from table '\pgfplotstableread@filename'. The original request was for '#1', which does not exist either.}%
				\def#2{0}%
			}{%
				\edef#2{\csname pgfplotstblread@colindex@for@name\pgfplotstable@loc@TMPa\endcsname}%
			}%
		}{%
			\def\pgfplotstable@loc@TMPa{/pgfplots/table/create on use/#1}%
			\pgfkeysifdefined{\pgfplotstable@loc@TMPa/.@cmd}{%
				\pgfplots@error{Sorry, '\pgfplotstable@loc@TMPa' from table '\pgfplotstableread@filename' can't be evaluated in this context. Please prepare the table before using it here.}%
			}{%
				\pgfplots@error{Sorry, could not retrieve column '#1' from table '\pgfplotstableread@filename'. Please check spelling (or introduce name aliases).}%
			}%
			\def#2{0}%
		}%
	}{%
		\edef#2{\csname pgfplotstblread@colindex@for@name#1\endcsname}%
	}%
}%

% As \pgfplotstablereadgetptrtocolname, but this here access columns
% by index.
\def\pgfplotstablereadgetptrtocolindex@#1#2{\def#2{#1}}%

% \pgfplotstablereadevalptr{<\ptr>}{<\content}
% writes the current value of <\ptr> to <\content>. The pointer <\ptr>
% must be initialised with \pgfplotstablereadgetptrtocolname
\let\pgfplotstablereadevalptr@=\pgfplotstablereadgetcolindex@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\long\def\pgfplotstableread@impl@nextrow@NEXT@listener#1{%
	\expandafter\def\csname pgfplotstblread@colcontent@no\the\pgfplotstableread@curcol\endcsname{#1}%
	\advance\pgfplotstableread@curcol by1\relax
}

\long\def\pgfplotstableread@impl@nextrow@NEXT#1{%
%\pgfplots@message{Inserting '#1' at (\the\pgfplotstableread@lineno, \the\pgfplotstableread@curcol).}%
	\pgfplotslist@assembleentry{#1}\into\t@pgfplots@tokc
	\def\pgfplotstableread@TMP{\expandafter\pgfplotsapplistXpushback\expandafter{\the\t@pgfplots@tokc}\to}%
	\expandafter\pgfplotstableread@TMP\csname pgfp@numtable@glob@col@\the\pgfplotstableread@curcol\endcsname
	\advance\pgfplotstableread@curcol by1\relax
}



\long\def\pgfplotstableread@impl@collectcolnames@NEXT#1{%
%\pgfplots@message{Got column name no \the\pgfplotstableread@curcol\ as '#1'}%
	\pgfutil@ifundefined{pgfplotstableread@impl@COLNAME@#1}{%
		\def\pgfplotstable@loc@TMPa{#1}%
	}{% generate unique column names
		\pgfplots@warning{Table '\pgfplotstableread@filename' has non-unique column name '#1'. Only the first occurence can be accessed via column names.}%
		\edef\pgfplotstable@loc@TMPa{#1--index\the\pgfplotstableread@curcol}%
	}%
	\expandafter\def\csname pgfplotstableread@impl@COLNAME@#1\endcsname{foo}% remember this name.
	\expandafter\pgfplotslistpushbackglobal\expandafter{\pgfplotstable@loc@TMPa}\to\pgfplotstable@colnames
	\ifpgfplots@tableread@to@listener
		% create an associative container colindex -> colname
		% for use in a listener.
		\def\pgfplots@loc@TMPb{%
			\expandafter\def\csname pgfplotstblread@colindex@for@name#1\endcsname}%
		\expandafter\pgfplots@loc@TMPb\expandafter{\the\pgfplotstableread@curcol}%
	\fi
	\advance\pgfplotstableread@curcol by1\relax
}




\long\def\pgfplotstableread@impl@countcols@and@identifynames@NEXT#1{%
	\advance\pgfplotstableread@curcol by1\relax
	\ifpgfplotstable@search@header
		\ifpgfplotstableread@curline@contains@colnames
		\else
			\pgfplotstableread@isnumber@ITERATE#1\pgfplotstable@EOI
%\ifpgfplotstableread@curline@contains@colnames\pgfplots@message{'#1' is a column name!}\else\pgfplots@message{'#1' is NO column name!}\fi
		\fi
	\fi
}
\def\pgfplotstableread@isnumber@plus{+}
\def\pgfplotstableread@isnumber@minus{-}
\def\pgfplotstableread@isnumber@zero{0}
\def\pgfplotstableread@isnumber@one{1}
\def\pgfplotstableread@isnumber@two{2}
\def\pgfplotstableread@isnumber@three{3}
\def\pgfplotstableread@isnumber@four{4}
\def\pgfplotstableread@isnumber@five{5}
\def\pgfplotstableread@isnumber@six{6}
\def\pgfplotstableread@isnumber@seven{7}
\def\pgfplotstableread@isnumber@eight{8}
\def\pgfplotstableread@isnumber@nine{9}
\def\pgfplotstableread@isnumber@e{e}
\def\pgfplotstableread@isnumber@E{E}
\def\pgfplotstableread@isnumber@period{.}

\def\pgfplotstableread@isnumber@ITERATE#1{%
	\def\pgfplotstableread@CURTOK{#1}%
	\ifx\pgfplotstableread@CURTOK\pgfplotstable@EOI
		\def\pgfplotstableread@NEXT{}%
	\else
		\def\pgfplotstableread@NEXT{\pgfplotstableread@isnumber@ITERATE}%
		\ifx\pgfplotstableread@CURTOK\pgfplotstableread@isnumber@plus
		\else
		\ifx\pgfplotstableread@CURTOK\pgfplotstableread@isnumber@minus
		\else
		\ifx\pgfplotstableread@CURTOK\pgfplotstableread@isnumber@zero
		\else
		\ifx\pgfplotstableread@CURTOK\pgfplotstableread@isnumber@one
		\else
		\ifx\pgfplotstableread@CURTOK\pgfplotstableread@isnumber@two
		\else
		\ifx\pgfplotstableread@CURTOK\pgfplotstableread@isnumber@three
		\else
		\ifx\pgfplotstableread@CURTOK\pgfplotstableread@isnumber@four
		\else
		\ifx\pgfplotstableread@CURTOK\pgfplotstableread@isnumber@five
		\else
		\ifx\pgfplotstableread@CURTOK\pgfplotstableread@isnumber@six
		\else
		\ifx\pgfplotstableread@CURTOK\pgfplotstableread@isnumber@seven
		\else
		\ifx\pgfplotstableread@CURTOK\pgfplotstableread@isnumber@eight
		\else
		\ifx\pgfplotstableread@CURTOK\pgfplotstableread@isnumber@nine
		\else
		\ifx\pgfplotstableread@CURTOK\pgfplotstableread@isnumber@e
		\else
		\ifx\pgfplotstableread@CURTOK\pgfplotstableread@isnumber@E
		\else
		\ifx\pgfplotstableread@CURTOK\pgfplotstableread@isnumber@period
		\else
%\message{NO ITS NOT!  Token: '\meaning\pgfplotstableread@CURTOK'}%
			% it's no number, so it is a column name.
			\pgfplotstableread@curline@contains@colnamestrue
			\def\pgfplotstableread@NEXT{\pgfplotstableread@impl@gobble}%
		\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi
	\fi
	\pgfplotstableread@NEXT
}

\def\pgfplotstable@error#1{\pgfplots@error{#1}}%


\def\pgfplotstableset{%
	\pgfqkeys{/pgfplots/table}%
}%

% Accepts a macro #1 which contains an argument denoting a column
% name.
%
% It checks whether #1 starts with '#', indicating that it is actually
% a column INDEX. If that is the case,
% \ifpgfplotstableread@foundcolnames is set to false and the index is
% returned into #1.
%
% Otherwise, \ifpgfplotstableread@foundcolnames is set to true.
\def\pgfplotstable@is@colname#1{%
	\expandafter\pgfplotstabletypeset@is@colname@#1\pgfplotstable@EOI
	\ifpgfplotstableread@foundcolnames
	\else
		\let#1=\pgfplotstable@loc@TMPa
	\fi
}%
\def\pgfplotstabletypeset@is@colname@{%
	\pgfutil@ifnextchar[{%
		\pgfplotstabletypeset@is@colname@index
	}{%
		\pgfplotstableread@foundcolnamestrue
		\pgfplotstabletypeset@is@colname@name
	}%
}
\def\pgfplotstabletypeset@is@colname@index@@{index}%
\def\pgfplotstabletypeset@is@colname@index[#1]#2\pgfplotstable@EOI{%
	\def\pgfplotstable@loc@TMPa{#1}%
	\ifx\pgfplotstable@loc@TMPa\pgfplotstabletypeset@is@colname@index@@
		\pgfplotstableread@foundcolnamesfalse
		\def\pgfplotstable@loc@TMPa{#2}%
	\else
		\pgfplotstableread@foundcolnamestrue
	\fi
}%
\def\pgfplotstabletypeset@is@colname@name#1\pgfplotstable@EOI{}%

\def\pgfplotstabletypeset@getfinalentry#1#2{%
	\begingroup
	\def\pgfplotstablepartno{0}%
	\pgfkeyssetvalue{/pgfplots/table/@cell content}{#1}%
	\pgfkeysvalueof{/pgfplots/table/preproc cell content/.@cmd}#1\pgfeov
	\pgfkeysgetvalue{/pgfplots/table/@cell content}\pgfmathresult%
	%
	\pgfkeysgetvalue{/pgfplots/table/assign cell content/.@cmd}\pgfplotstable@assigncell
	\expandafter\pgfplotstable@assigncell\pgfmathresult\pgfeov
	%
	\pgfkeysgetvalue{/pgfplots/table/postproc cell content/.@cmd}\pgfplotstable@postproccellcontent
	\ifx\pgfplotstable@postproccellcontent\pgfplotstable@postproccellcontent@EMPTY
	\else
		% apply postprocessing to final cell content.
		% This is complicated if there is an '&' in '@cell content',
		% so handle that specially!
		%
		% FIXME also support more than one '&' ?
		\def\pgfplotstabletypeset@rawinput{#1}%
		\pgfkeysgetvalue{/pgfplots/table/@cell content}\pgfmathresult%
		\expandafter\pgfutil@in@\expandafter&\expandafter{\pgfmathresult}%
		\ifpgfutil@in@
			\expandafter\pgfplotstabletypeset@postproc@separately\pgfmathresult\pgfplotstable@EOI
		\else
			\pgfplotstable@postproccellcontent#1\pgfeov
		\fi
	\fi
	\pgfkeysgetvalue{/pgfplots/table/@cell content}\pgfmathresult%
	\pgfmath@smuggleone\pgfmathresult
	\endgroup
	\let#2=\pgfmathresult
}%

% This routine invokes 'postproc cell content' for columns which
% contain the column separate '&'.
%
% #1&#2 is the formatted number, the result of 'dec sep align
% #3 is the (unformatted) input number.
\def\pgfplotstabletypeset@postproc@separately#1&#2\pgfplotstable@EOI{%
	\def\pgfmathresult{#1}%
	\pgfkeyslet{/pgfplots/table/@cell content}\pgfmathresult
	\expandafter\pgfplotstable@postproccellcontent\pgfplotstabletypeset@rawinput\pgfeov
	\pgfkeysgetvalue{/pgfplots/table/@cell content}\pgfplotstable@entry@a
	%
	\def\pgfplotstablepartno{1}%
	\def\pgfmathresult{#2}%
	\pgfkeyslet{/pgfplots/table/@cell content}\pgfmathresult
	\expandafter\pgfplotstable@postproccellcontent\pgfplotstabletypeset@rawinput\pgfeov
	\pgfkeysgetvalue{/pgfplots/table/@cell content}\pgfmathresult
	\t@pgfplots@toka=\expandafter{\pgfplotstable@entry@a}%
	\t@pgfplots@tokb=\expandafter{\pgfmathresult}%
	\edef\pgfmathresult{\the\t@pgfplots@toka&\the\t@pgfplots@tokb}%
	\pgfkeyslet{/pgfplots/table/@cell content}\pgfmathresult
}

% processes the option 'assign column name'
\def\pgfplotstabletypeset@assign@final@colname#1#2{%
	\pgfkeysifdefined{/pgfplots/table/assign column name/.@cmd}{%
		\pgfkeysdef{/pgfplots/table/column name}{#1}%
		\pgfkeysvalueof{/pgfplots/table/assign column name/.@cmd}#1\pgfeov
		\pgfkeysgetvalue{/pgfplots/table/column name}{#2}%
	}{}%
}
\def\pgfplotstabletypeset@nocolname{\pgfkeysnovalue}

% checks if #1 contains invalid chars for pgfkeys and sets
% \ifpgfutil@in@ to true if that is the case.
\def\pgfplotstable@checkspecialchars@pgfkeys#1\pgfplotstable@EOI{%
	\pgfutil@in@/{#1}%
	\ifpgfutil@in@
	\else
		\pgfutil@in@={#1}%
		\ifpgfutil@in@
		\else
			\pgfutil@in@,{#1}%
		\fi
	\fi

}%

\def\pgfplotstable@insertemptycells@forbalance{%
	\pgfutil@loop
	\ifnum\c@pgfplotstable@counta<\pgfplotstable@firstnumrows\relax
		% let's hope @getfinalentry handles empty strings!
		\pgfplotstabletypeset@getfinalentry{}{\pgfplotstable@entry}%
		\expandafter\pgfplotslistpushback\pgfplotstable@entry\to\pgfplotstable@col@processed
		\pgfplotslistpushback\to\pgfplotstable@col@processed
		\advance\c@pgfplotstable@counta by1\relax
	\pgfutil@repeat
}

% TODO
% - replace grouped list foreach by popfront-loop and use arrays
%   directly -> group only the pgfkeys eval
\def\pgfplotstabletypeset@opt[#1]#2{%
	\begingroup
	%--------------------------------------------------
	% \pgfutil@ifundefined{#2}{%
	% 	\pgfplots@error{There is no such table '\string#2' loaded into memory. Maybe you meant to use '\string\pgfplotstabletypesetfile{\string#2}' instead of '\string\pgfplotstabletypeset{\string#2}'?}%
	% 	\pgfplotslistnewempty#2
	% }{}%
	%-------------------------------------------------- 
	\def\pgfplotstablecol{\the\c@pgfplotstable@colindex}%
	\def\pgfplotstablerow{\the\c@pgfplotstable@rowindex}%
	\def\pgfplotstablecols{\the\c@pgfplotstable@numcols}%
	\def\pgfplotstablerows{\the\c@pgfplotstable@numrows}%
	\ifpgfplots@table@options@areset
	\else
		\pgfplotstablegetname{#2}\pgfplotstable@loc@TMPa
		\t@pgfplots@toka=\expandafter{\pgfplotstable@loc@TMPa}%
		\edef\pgfplotstable@loc@TMPa{/pgfplots/table/every table={\the\t@pgfplots@toka}}%
		\expandafter\pgfplotstableset\expandafter{\pgfplotstable@loc@TMPa,#1}%
	\fi
	\pgfkeysgetvalue{/pgfplots/table/outfile}\pgfplotstable@outfilename
	\ifpgfplotstabletypeset@force@remake
		\pgfplotstabletypeset@includeoutfilesfalse
	\else
		\ifpgfplotstabletypeset@includeoutfiles
			\pgfplotstabletypeset@includeoutfilesfalse
			\ifx\pgfplotstable@outfilename\pgfutil@empty
			\else
				\openin1=\pgfplotstable@outfilename\relax
				\ifeof1 \else\pgfplotstabletypeset@includeoutfilestrue \fi
				\closein1
			\fi
		\fi
	\fi
	\ifpgfplotstabletypeset@includeoutfiles
		\input \pgfplotstable@outfilename\relax
	\else
	%
	% Prepare outfile and debug options:
	\let\pgfplotstable@notify@finished@line=\pgfutil@empty
	%
	% FLUSH assumes that \pgfplotstable@curline is finished. It
	% appends all its contents as-is to \pgfplotstable@result.
	%
	% Furthermore, it calls \pgfplotstable@notify@finished@line which
	% in turn may invoke additional output routines for the debug and
	% outfile options.
	%
	% Finally, it resets \pgfplotstable@curline.
	\def\pgfplotstable@curline@FLUSH{%
		\pgfplotstable@notify@finished@line
		\t@pgfplots@toka=\expandafter{\pgfplotstable@result}%
		\t@pgfplots@tokb=\expandafter{\pgfplotstable@curline}%
		\edef\pgfplotstable@result{\the\t@pgfplots@toka\the\t@pgfplots@tokb}%
		\let\pgfplotstable@curline=\pgfutil@empty
	}%
	\ifpgfplotstabletypesetdebug
		\immediate\write16{------- PGFPLOTSTABLE DEBUG MODE: --------}%
		\expandafter\def\expandafter\pgfplotstable@notify@finished@line\expandafter{\pgfplotstable@notify@finished@line
			\t@pgfplots@toka=\expandafter{\pgfplotstable@curline}%
			\immediate\write16{\the\t@pgfplots@toka\pgfplots@PERCENT@TEXT}%
		}%
	\fi
	\ifx\pgfplotstable@outfilename\pgfutil@empty
	\else
		\immediate\openout\pgfplotstable@outfile=\pgfplotstable@outfilename\relax
		\expandafter\def\expandafter\pgfplotstable@notify@finished@line\expandafter{\pgfplotstable@notify@finished@line
			\t@pgfplots@toka=\expandafter{\pgfplotstable@curline}%
			\immediate\write\pgfplotstable@outfile{\the\t@pgfplots@toka\pgfplots@PERCENT@TEXT}%
		}%
	\fi
	%
	% Start operation:
	\pgfkeysgetvalue{/pgfplots/table/columns}{\pgfplotstable@colnames}%
	\ifx\pgfplotstable@colnames\pgfutil@empty
		\pgfplotstablegetcolumnlist#2\to\pgfplotstable@colnames
	\else
		\expandafter\pgfplotslistnew\expandafter\pgfplotstable@colnames\expandafter{\pgfplotstable@colnames}%
	\fi
	\global\pgfplotslistnewempty\pgfplotstabletypeset@final@colnames
	\global\pgfplotslistnewempty\pgfplotstabletypeset@final@coltypes
	\global\pgfplotslistnewempty\pgfplotstabletypeset@final@cols
	\let\c@pgfplotstable@numcols=\c@pgf@counta
	\let\c@pgfplotstable@numrows=\c@pgf@countd
	\let\c@pgfplotstable@rowindex=\c@pgf@countc
	\let\c@pgfplotstable@colindex=\c@pgf@countb
	\pgfplotslistsize\pgfplotstable@colnames\to\c@pgfplotstable@numcols
	\def\pgfplotstable@firstnumrows{-1}%
	\c@pgfplotstable@numrows=-1\relax
	\c@pgfplotstable@colindex=0\relax
	\pgfplotslistforeach\pgfplotstable@colnames\as\pgfplotstable@colname{%
		\c@pgfplotstable@rowindex=0\relax
		\pgfplotstable@is@colname\pgfplotstable@colname
		\ifpgfplotstableread@foundcolnames
		\else
			\pgfplotstablegetcolumnnamebyindex\pgfplotstable@colname\of#2\to\pgfplotstable@colname
		\fi
		\pgfplotstablegetcolumnbyname\pgfplotstable@colname\of#2\to\pgfplotstable@col
		%
		% Init number of *input* rows here. This may not be the same
		% as the number of *output* rows (see the row predicate
		% below).
		%
		% Accessable with \pgfplotstablerows in style keys.
		\ifnum\c@pgfplotstable@numrows=-1\relax
			\pgfplotslistsize\pgfplotstable@col\to\c@pgfplotstable@numrows
			\global\c@pgfplotstable@numrows=\c@pgfplotstable@numrows
		\fi
		%
		% Set keys for columns!
		\ifodd\c@pgfplotstable@colindex
			\t@pgfplots@toka={every odd column}%
		\else
			\t@pgfplots@toka={every even column}%
		\fi
		\ifnum\c@pgfplotstable@colindex=0\relax
			\t@pgfplots@toka=\expandafter{\the\t@pgfplots@toka,every first column}%
		\fi
		% save this now before we increment '\c@pgfplotstable@colindex':
		\edef\pgfplotstable@displaycolkey{display columns/\the\c@pgfplotstable@colindex/.try}%
		%
		\global\advance\c@pgfplotstable@colindex by1\relax
		\ifnum\c@pgfplotstable@colindex=\c@pgfplotstable@numcols
			\t@pgfplots@toka=\expandafter{\the\t@pgfplots@toka,every last column}%
		\fi
		\t@pgfplots@tokb=\expandafter{\pgfplotstable@colname}%
		\expandafter\pgfplotstable@checkspecialchars@pgfkeys\the\t@pgfplots@tokb\pgfplotstable@EOI
		\ifpgfutil@in@
			\edef\pgfplotstable@loc@TMPa{\the\t@pgfplots@toka,columns/{\the\t@pgfplots@tokb}/.try}%
		\else
			\edef\pgfplotstable@loc@TMPa{\the\t@pgfplots@toka,columns/\the\t@pgfplots@tokb/.try}%
		\fi
		\t@pgfplots@toka=\expandafter{\pgfplotstable@loc@TMPa}%
		\t@pgfplots@tokb=\expandafter{\pgfplotstable@displaycolkey}%
		\edef\pgfplotstable@loc@TMPa{\the\t@pgfplots@toka,\the\t@pgfplots@tokb}%
		\expandafter\pgfplotstableset\expandafter{\pgfplotstable@loc@TMPa}%
		%
		\pgfkeysgetvalue{/pgfplots/table/column name}{\pgfplotstable@colname@out}%
		\ifx\pgfplotstable@colname@out\pgfplotstabletypeset@nocolname
			\let\pgfplotstable@colname@out=\pgfplotstable@colname
		\fi
		\expandafter\pgfplotstabletypeset@assign@final@colname\expandafter{\pgfplotstable@colname@out}\pgfplotstable@colname@out
		{\globaldefs=1
		\expandafter\pgfplotslistpushback\pgfplotstable@colname@out\to\pgfplotstabletypeset@final@colnames
		}%
		\pgfkeysgetvalue{/pgfplots/table/column type}{\pgfplotstable@coltype}%
		{\globaldefs=1
		\expandafter\pgfplotslistpushback\pgfplotstable@coltype\to\pgfplotstabletypeset@final@coltypes
		}%
		%
		\pgfplotslistnewempty\pgfplotstable@col@processed
		\c@pgfplotstable@counta=0 
		\pgfplotslistforeachungrouped\pgfplotstable@col\as\pgfplotstable@entry{%
			\pgfplotstableuserowtrue
			\edef\pgfplotstable@loc@TMPa{\noexpand\pgfkeysvalueof{/pgfplots/table/row predicate/.@cmd}\the\c@pgfplotstable@rowindex}%
			\pgfplotstable@loc@TMPa\pgfeov
			\ifpgfplotstableuserow
				\ifnum\pgfplotstable@firstnumrows=-1\relax
				\else
					\ifnum\c@pgfplotstable@counta=\pgfplotstable@firstnumrows
						\t@pgfplots@toka=\expandafter{\pgfplotstable@entry}%
						\t@pgfplots@tokb=\expandafter{\pgfplotstable@colname@out}%
						\pgfplots@warning{Unbalanced cell with content '\the\t@pgfplots@toka' of column '\the\t@pgfplots@tokb' has been skipped: row count \the\c@pgfplotstable@counta+1 > \pgfplotstable@firstnumrows (which is the number of rows in the first column)}%
						\pgfplotstableuserowfalse
					\fi
				\fi
				\ifpgfplotstableuserow
					\expandafter\pgfplotstabletypeset@getfinalentry\expandafter{\pgfplotstable@entry}{\pgfplotstable@entry}%
					\expandafter\pgfplotslistpushback\pgfplotstable@entry\to\pgfplotstable@col@processed
					\advance\c@pgfplotstable@counta by1\relax
				\fi
			\fi
			\advance\c@pgfplotstable@rowindex by1\relax
		}%
		\ifnum\pgfplotstable@firstnumrows=-1\relax
			\xdef\pgfplotstable@firstnumrows{\the\c@pgfplotstable@counta}%
		\else
			% balance columns:
			\pgfplotstable@insertemptycells@forbalance
		\fi
		{\globaldefs=1
		\expandafter\pgfplotslistpushback\expandafter{\pgfplotstable@col@processed}\to\pgfplotstabletypeset@final@cols
		}%
	}%
	%
	% Ok, I have now everything which will come into the final table.
	%
	% But I have it column-oriented; I need to transpose the storage.
	%
	% The following code assembles a
	% \begin{tabular}{}
	% ...
	% \end{tabular}
	% statement piece after piece.
	%
%\message{I have now \meaning\pgfplotstabletypeset@final@colnames, and \meaning\pgfplotstabletypeset@final@cols.}%
	% Step 1: column names.
	\c@pgfplotstable@colindex=0\relax
	% STEP 1.1: collect column types:
	\def\pgfplotstable@resulttypes{}%
	\pgfplotslistforeachungrouped\pgfplotstabletypeset@final@coltypes\as\pgfplotstable@coltype{%
		\t@pgfplots@toka=\expandafter{\pgfplotstable@resulttypes}%
		\t@pgfplots@tokb=\expandafter{\pgfplotstable@coltype}%
		\edef\pgfplotstable@resulttypes{\the\t@pgfplots@toka\the\t@pgfplots@tokb}%
	}%
	\let\pgfplotstable@result=\pgfutil@empty
	%
	\pgfkeysgetvalue{/pgfplots/table/font}{\pgfplotstable@font}%
	\ifx\pgfplotstable@font\pgfutil@empty
	\else
		\t@pgfplots@toka=\expandafter{\pgfplotstable@font}%
		\edef\pgfplotstable@curline{\noexpand\begingroup\the\t@pgfplots@toka}%
		\pgfplotstable@curline@FLUSH
	\fi
	%
	\pgfkeysgetvalue{/pgfplots/table/begin table}{\pgfplotstable@entry}%
	\t@pgfplots@toka=\expandafter{\pgfplotstable@entry}%
	\ifx\pgfplotstable@resulttypes\pgfutil@empty
		\edef\pgfplotstable@curline{\the\t@pgfplots@toka}%
	\else
		\t@pgfplots@tokb=\expandafter{\pgfplotstable@resulttypes}%
		\edef\pgfplotstable@curline{\the\t@pgfplots@toka{\the\t@pgfplots@tokb}}%
	\fi
	\pgfplotstable@curline@FLUSH
	%

	% Step 1.2: Collect FIRST ROW (column names)
	\begingroup
	\pgfplotstableset{every head row}%
	\pgfkeysgetvalue{/pgfplots/table/before row}{\pgfplotstable@before}%
	\pgfkeysgetvalue{/pgfplots/table/after row}{\pgfplotstable@after}%
	\t@pgfplots@toka=\expandafter{\pgfplotstable@before}%
	\t@pgfplots@tokb=\expandafter{\pgfplotstable@after}%
	\xdef\pgfplots@glob@TMPc{%
		\noexpand\def\noexpand\pgfplotstable@before{\the\t@pgfplots@toka}%
		\noexpand\def\noexpand\pgfplotstable@after{\the\t@pgfplots@tokb}%
	}%
	\endgroup
	\pgfplots@glob@TMPc
	% insert 'before row' here:
	\t@pgfplots@toka=\expandafter{\pgfplotstable@before}%
	\t@pgfplots@tokb=\expandafter{\pgfplotstable@curline}%
	\edef\pgfplotstable@curline{\the\t@pgfplots@tokb\the\t@pgfplots@toka}%
	%
	\pgfplotslistforeachungrouped\pgfplotstabletypeset@final@colnames\as\pgfplotstable@colname@out{%
		\advance\c@pgfplotstable@colindex by1\relax
		\t@pgfplots@toka=\expandafter{\pgfplotstable@curline}%
		\ifnum\c@pgfplotstable@colindex=\c@pgfplotstable@numcols\relax
			\t@pgfplots@tokb=\expandafter{\pgfplotstable@colname@out \\}%
		\else
			\t@pgfplots@tokb=\expandafter{\pgfplotstable@colname@out &}%
		\fi
		\edef\pgfplotstable@curline{\the\t@pgfplots@toka\the\t@pgfplots@tokb}%
	}%
	% insert 'after row' here:
	\t@pgfplots@toka=\expandafter{\pgfplotstable@curline}%
	\t@pgfplots@tokb=\expandafter{\pgfplotstable@after}%
	\edef\pgfplotstable@curline{\the\t@pgfplots@toka\the\t@pgfplots@tokb}%
	%
	\pgfplotstable@curline@FLUSH
	%
%\message{I have now \meaning\pgfplotstable@result.}%
	% Step 2: column contents.
	% I will first convert \pgfplotstabletypeset@final@cols into an array.
	\c@pgfplotstable@colindex=0\relax
	\pgfplotsarraynewempty\pgfplotstabletypeset@final@cols@array
	\pgfplotslistforeachungrouped\pgfplotstabletypeset@final@cols\as\pgfplotstable@col@processed{%
		\expandafter\pgfplotsarraypushback\expandafter{\pgfplotstable@col@processed}\to\pgfplotstabletypeset@final@cols@array
	}%
	% init numrows:
	\pgfplotsarrayselect\c@pgfplotstable@colindex\of\pgfplotstabletypeset@final@cols@array\to\pgfplotstable@col@processed
	\pgfplotslistsize\pgfplotstable@col@processed\to\c@pgfplotstable@numrows
	%
	% Now, we loop over every column as long as there are still rows
	% left. We assemble rows while we go.
	%
	\c@pgfplotstable@rowindex=0\relax
	\ifnum\c@pgfplotstable@colindex<\c@pgfplotstable@numcols
		\pgfplots@loop@CONTINUEtrue
	\else
		\pgfplots@loop@CONTINUEfalse
	\fi
	\pgfutil@loop
	\ifpgfplots@loop@CONTINUE
		\pgfplotsarrayselect\c@pgfplotstable@colindex\of\pgfplotstabletypeset@final@cols@array\to\pgfplotstable@col@processed
		\pgfplotslistcheckempty\pgfplotstable@col@processed
		\ifpgfplotslistempty
			% assume that each column has the same number of entries
			% (normalised tables):
			\pgfplots@loop@CONTINUEfalse
		\else
			\ifnum\c@pgfplotstable@colindex=0\relax
				% Install styles for the next row.
				\begingroup
				\ifodd\c@pgfplotstable@rowindex
					\t@pgfplots@toka={every odd row}%
				\else
					\t@pgfplots@toka={every even row}%
				\fi
				\ifnum\c@pgfplotstable@rowindex=0\relax
					\t@pgfplots@toka=\expandafter{\the\t@pgfplots@toka,every first row}%
				\fi
				% misuse as temporary variable:
				\c@pgfplotstable@colindex=\c@pgfplotstable@rowindex
				\advance\c@pgfplotstable@colindex by1\relax
				\ifnum\c@pgfplotstable@colindex=\c@pgfplotstable@numrows
					\edef\pgfplotstable@loc@TMPa{\the\t@pgfplots@toka,every row no \the\c@pgfplotstable@rowindex/.try,every last row}%
				\else
					\edef\pgfplotstable@loc@TMPa{\the\t@pgfplots@toka,every row no \the\c@pgfplotstable@rowindex/.try}%
				\fi
				\expandafter\pgfplotstableset\expandafter{\pgfplotstable@loc@TMPa}%
				\pgfkeysgetvalue{/pgfplots/table/before row}{\pgfplotstable@before}%
				\pgfkeysgetvalue{/pgfplots/table/after row}{\pgfplotstable@after}%
				\t@pgfplots@toka=\expandafter{\pgfplotstable@before}%
				\t@pgfplots@tokb=\expandafter{\pgfplotstable@after}%
				\xdef\pgfplots@glob@TMPc{%
					\noexpand\def\noexpand\pgfplotstable@before{\the\t@pgfplots@toka}%
					\noexpand\def\noexpand\pgfplotstable@after{\the\t@pgfplots@tokb}%
				}%
				\endgroup
				\pgfplots@glob@TMPc
				% insert 'before row' here:
				\t@pgfplots@toka=\expandafter{\pgfplotstable@before}%
				\t@pgfplots@tokb=\expandafter{\pgfplotstable@curline}%
				\edef\pgfplotstable@curline{\the\t@pgfplots@tokb\the\t@pgfplots@toka}%
			\fi
			%
			%
			\pgfplotslistpopfront\pgfplotstable@col@processed\to\pgfplotstable@entry
			\pgfplotsarrayletentry\c@pgfplotstable@colindex\of\pgfplotstabletypeset@final@cols@array=\pgfplotstable@col@processed
			\advance\c@pgfplotstable@colindex by1\relax
			\t@pgfplots@toka=\expandafter{\pgfplotstable@curline}%
			\ifnum\c@pgfplotstable@colindex=\c@pgfplotstable@numcols\relax
				\t@pgfplots@tokb=\expandafter{\pgfplotstable@entry \\}%
			\else
				\t@pgfplots@tokb=\expandafter{\pgfplotstable@entry &}%
			\fi
			\edef\pgfplotstable@curline{\the\t@pgfplots@toka\the\t@pgfplots@tokb}%
			\ifnum\c@pgfplotstable@colindex=\c@pgfplotstable@numcols\relax
				\c@pgfplotstable@colindex=0\relax
				% insert 'after row' here:
				\t@pgfplots@toka=\expandafter{\pgfplotstable@curline}%
				\t@pgfplots@tokb=\expandafter{\pgfplotstable@after}%
				\edef\pgfplotstable@curline{\the\t@pgfplots@toka\the\t@pgfplots@tokb}%
				\advance\c@pgfplotstable@rowindex by1\relax
				\pgfplotstable@curline@FLUSH
			\fi
%\message{I have now \meaning\pgfplotstable@result.}%
		\fi
	\pgfutil@repeat
	\t@pgfplots@toka=\expandafter{\pgfplotstable@curline}%
	\pgfkeysgetvalue{/pgfplots/table/end table}{\pgfplotstable@entry}%
	\t@pgfplots@tokb=\expandafter{\pgfplotstable@entry}%
	\edef\pgfplotstable@curline{\the\t@pgfplots@toka\the\t@pgfplots@tokb}%
	\pgfplotstable@curline@FLUSH
	%
	\ifx\pgfplotstable@font\pgfutil@empty
	\else
		\edef\pgfplotstable@curline{\noexpand\endgroup}%
		\pgfplotstable@curline@FLUSH
	\fi
	\ifx\pgfplotstable@outfilename\pgfutil@empty
	\else
		\immediate\closeout\pgfplotstable@outfile
	\fi
%\message{I have now \meaning\pgfplotstable@result.}%
	\pgfplotstable@result
	\fi
	\endgroup
}%

\newif\ifpgfplotstable@isfirstrow
\newif\ifpgfplotstable@islastrow
\newif\ifpgfplotstablecreatecol@isreallynew

\def\pgfplotstablecreatecol@opt[#1]#2#3{%
	\begingroup
	\pgfplotstableset{columns=,#1}%
	\pgfkeysgetvalue{/pgfplots/table/columns}{\pgfplotstable@colnames}%
	\ifx\pgfplotstable@colnames\pgfutil@empty
		\pgfplotstablegetcolumnlist#3\to\pgfplotstable@colnames
	\else
		\expandafter\pgfplotslistnew\expandafter\pgfplotstable@colnames\expandafter{\pgfplotstable@colnames}%
	\fi
	\pgfplotslistnewempty\pgfplotstable@colnames@real
	\t@pgfplots@toka=\expandafter{#2}% this should handle macro names in '#2'.
	\edef\pgfplotstable@newcolname{\the\t@pgfplots@toka}%
	\global\pgfplotstablecreatecol@isreallynewtrue
	\pgfplotslistforeachungrouped\pgfplotstable@colnames\as\pgfplotstable@colname{%
		\pgfplotstable@is@colname\pgfplotstable@colname
		\ifpgfplotstableread@foundcolnames
			\expandafter\pgfplotslistpushback\expandafter{\pgfplotstable@colname}\to\pgfplotstable@colnames@real
		\else
			\pgfplotstablegetcolumnnamebyindex\pgfplotstable@colname\of#2\to\pgfplotstable@colname
			\expandafter\pgfplotslistpushback\expandafter{\pgfplotstable@colname}\to\pgfplotstable@colnames@real
		\fi
		\ifx\pgfplotstable@colname\pgfplotstable@newcolname
			\global\pgfplotstablecreatecol@isreallynewfalse
		\fi
	}%
	\pgfplotstable@isfirstrowtrue
	\pgfplotstable@islastrowfalse
	\pgfplotslistnewempty\pgfplotstable@newcol
	%
	\let\c@pgfplotstable@numrows=\c@pgf@countd
	\let\c@pgfplotstable@rowindex=\c@pgf@countc
	\c@pgfplotstable@numrows=-1\relax
	\c@pgfplotstable@rowindex=0\relax
	\def\pgfplotstablerow{\the\c@pgfplotstable@rowindex}%
	\def\pgfplotstablerows{\the\c@pgfplotstable@numrows}%
	%
	\def\prevrow##1{\csname pgfplotstablecreate@prev@##1\endcsname}%
	\def\thisrow##1{\csname pgfplotstablecreate@cur@##1\endcsname}%
	\def\nextrow##1{\csname pgfplotstablecreate@next@##1\endcsname}%
	\def\getprevrow##1##2{\expandafter\let\expandafter##2\csname pgfplotstablecreate@prev@##1\endcsname}%
	\def\getthisrow##1##2{\expandafter\let\expandafter##2\csname pgfplotstablecreate@cur@##1\endcsname}%
	\def\getnextrow##1##2{\expandafter\let\expandafter##2\csname pgfplotstablecreate@next@##1\endcsname}%
	%
	\pgfplots@loop@CONTINUEtrue
	% allow this here to accumulate something.
	\let\pgfmathaccuma=\pgfutil@empty
	\let\pgfmathaccumb=\pgfutil@empty
	\pgfutil@loop% loop over each row until there are no more rows.
	\ifpgfplots@loop@CONTINUE
		\ifnum\c@pgfplotstable@numrows=-1\relax
			\pgfplotslistfront\pgfplotstable@colnames\to\pgfplotstable@colname
			\expandafter\pgfplotslistsize\csname\string#3@\pgfplotstable@colname\endcsname\to\c@pgfplotstable@numrows
		\fi
		\pgfplotslistforeachungrouped\pgfplotstable@colnames\as\pgfplotstable@colname{%
			\expandafter\pgfplotstableresolvecolname\expandafter{\pgfplotstable@colname}\of#3\to\pgfplotstable@real@colname
			\ifpgfplotstable@isfirstrow
				\expandafter\pgfplotslistcheckempty\csname\string#3@\pgfplotstable@real@colname\endcsname
				\ifpgfplotslistempty
					% the table is completely empty. break.
					\pgfplots@loop@CONTINUEfalse
				\else
					\expandafter\let\csname pgfplotstablecreate@prev@\pgfplotstable@colname\endcsname=\pgfutil@empty
					\expandafter\pgfplotslistpopfront\csname\string#3@\pgfplotstable@real@colname\endcsname\to\pgfplotstable@entry
					\expandafter\let\csname pgfplotstablecreate@cur@\pgfplotstable@colname\endcsname=\pgfplotstable@entry
				\fi
			\else
				\expandafter\let\expandafter\pgfplotstable@prev\csname pgfplotstablecreate@cur@\pgfplotstable@colname\endcsname
				\expandafter\let\csname pgfplotstablecreate@prev@\pgfplotstable@colname\endcsname=\pgfplotstable@prev
				%
				\expandafter\let\expandafter\pgfplotstable@next\csname pgfplotstablecreate@next@\pgfplotstable@colname\endcsname
				\expandafter\let\csname pgfplotstablecreate@cur@\pgfplotstable@colname\endcsname=\pgfplotstable@next
			\fi
			\expandafter\pgfplotslistcheckempty\csname\string#3@\pgfplotstable@real@colname\endcsname
			\ifpgfplotslistempty
				\expandafter\let\csname pgfplotstablecreate@next@\pgfplotstable@colname\endcsname=\pgfutil@empty
				\pgfplotstable@islastrowtrue
			\else
				\expandafter\pgfplotslistpopfront\csname\string#3@\pgfplotstable@real@colname\endcsname\to\pgfplotstable@entry
				\expandafter\let\csname pgfplotstablecreate@next@\pgfplotstable@colname\endcsname=\pgfplotstable@entry
			\fi
		}%
		\ifpgfplots@loop@CONTINUE
			% Compute content:
			%
			\begingroup
			\ifpgfplotstable@isfirstrow
				\pgfkeysvalueof{/pgfplots/table/create col/assign first/.@cmd}\pgfeov
			\else
				\ifpgfplotstable@islastrow
					\pgfkeysvalueof{/pgfplots/table/create col/assign last/.@cmd}\pgfeov
				\else
					\pgfkeysvalueof{/pgfplots/table/create col/assign/.@cmd}\pgfeov
				\fi
			\fi
			\pgfkeysgetvalue{/pgfplots/table/create col/next content}{\pgfplotstable@entry}%
			\t@pgfplots@toka=\expandafter{\pgfplotstable@entry}%
			\t@pgfplots@tokb=\expandafter{\pgfmathaccuma}%
			\xdef\pgfplots@glob@TMPc{%
				\noexpand\def\noexpand\pgfplotstable@entry{\the\t@pgfplots@toka}%
				\noexpand\def\noexpand\pgfmathaccuma{\the\t@pgfplots@tokb}%
			}%
			\pgfmath@smuggleone\pgfmathaccumb
			\endgroup
			\pgfplots@glob@TMPc
			\expandafter\pgfplotslistpushback\expandafter{\pgfplotstable@entry}\to\pgfplotstable@newcol
			%
			\ifpgfplotstable@islastrow
				\pgfplots@loop@CONTINUEfalse
			\fi
		\fi
		\pgfplotstable@isfirstrowfalse
		\advance\c@pgfplotstable@rowindex by1\relax
	\pgfutil@repeat
	\global\let\pgfplots@glob@TMPc=\pgfplotstable@newcol
	\global\let\pgfplots@glob@TMPb=\pgfplotstable@newcolname
	\endgroup
	\ifpgfplotstablecreatecol@isreallynew
		\expandafter\pgfplotslistpushback\expandafter{\pgfplots@glob@TMPb}\to#3
	\fi
	\expandafter\let\csname\string#3@\pgfplots@glob@TMPb\endcsname=\pgfplots@glob@TMPc
}%

\endinput
