% Additions to pgfkeys.code.tex (should be loaded AFTER
% pgfkeys.code.tex)
%
% written by Christian Feuersaenger 2008
%
% Improvements:
%
% - option filtering 
%   you provide
%     - a boolean predicate
%     - a "filter handler" which will be invoked for non-matching
%     options,
%     - a key=value list as usual.
%   The filter sets only matching options and invokes the handler for
%   unmatching ones.
%
% - Fast family support.
%   - The '.is family' handler now supports family
%     activation/deactivation.
%   - A key like /my tree/my option  can be associated with /my family
%   - you can set only options of activated families.
%  Unprocessed options can be collected into a macro.

\pgfutil@ifundefined{pgfkeysfiltered}{}{\endinput}%

% WARNING:
% this file overwrites
% \pgfkeys@addpath
% \pgfkeys@nevermind
%
% all other features are 'additive'


% these implementations will be switched dynamically with their
% filtered versions (in \pgfkeys@install@filter@and@invoke)
\let\pgfkeys@orig@case@one=\pgfkeys@case@one
\let\pgfkeys@orig@@set=\pgfkeys@@set
\let\pgfkeys@orig@@qset=\pgfkeys@@qset
\let\pgfkeys@orig@try=\pgfkeys@try
\let\pgfkeys@orig@unknown=\pgfkeys@unknown

\newif\ifpgfkeysfiltercontinue
\let\pgfkeys@key@predicate=\pgfkeys@empty
\let\pgfkeys@key@handler=\pgfkeys@empty
\newtoks\pgfkeys@tmptoks

% Performs 'filtered' key settings.
%
% For every option for which the path prefixing has already been done, 
% the predicate #1 will be invoked with one argument, namely an
% integer denoting what type of option it is (see below). If the predicate
% returns true, pgfkeys will not process this key any
% further. Instead, it invokes the handler #2 (with the same argument).
%
% The predicate and handler semantics are as follows:
% PRECONDITION:
% 		1. The variables
% 			\pgfkeyscurrentkey (full path including name)
% 			\pgfkeyscurrentkeyRAW (the current key as it has been
% 			                       found in the key=value list
% 			                       without path modification)
% 			\pgfkeyscurrentvalue
% 			are all set. Use \pgfkeyssplitpath in this context to also
% 			compute
%	 			\pgfkeyscurrentname 
%	 		and
% 				\pgfkeyscurrentpath.
%		2. The type of option has already been checked, that means
%			case (1) whether '.@cmd' exists
%			case (2) whether the key as such has its value
%			case (3) it is a handler like '.code', '.cd' or whatever.
%			case (0) it is unknown.
%			The actual case number (0-3) will be provided as argument to
%			both #1 and #2.
%			Please note that unknown options will be processed with
%			the usual '.unknown' handlers.
%
% POSTCONDITION:
% 		the predicate sets \pgfkeysfiltercontinuetrue or
% 		\pgfkeysfiltercontinuefalse (the global
% 		\ifpgfkeysfiltercontinue)
% Depending on this if, option processing will be continued or
% skipped.
%
% The handler can do anything with the option, for example collect
% unmatched ones.
%
% ATTENTION: \pgfkeysfiltered can't be nested (yet). Use the
% \pgfkeyspredicateAND if you need multiple predicates at once.
%
% ATTENTION: you can't filter error messages.
%
% REMARK: In case (3), the macros \pgfkeyscurrentpath and
% \pgfkeyscurrentname have already been computed, you do not need to
% invoke \pgfkeyssplitpath. In any other case, neither path nor name
% are required for the options processing - if you need them for
% predicates/handlers, you need to compute them by hand.
% 
%
% Example:
%   \def\unmatched{}
%   \pgfkeysfiltered%
%   	{pgfkeysisdescendantof{/axis}}%
%   	{\pgfkeysappendfilterednamestomacro{\unmatched}}%
%   	{/axis/option 1=value 1,/tikz/option 2=value 2}
% ->
%  will set '/axis/option 1' as usual, but '/tikz/option 2' will not
%  be set. Instead, it will be appended to '\unmatched' such that 
%  \unmatched = {/tikz/option 2=value2}
%  after the operation.
%
% Arguments:
% #1:  boolean key predicate (which accepts one (more) argument)
% #2:  key handler (which accepts one (more) argument)
% #3:  key-value list.
%
% @see \pgfkeyspredicatenameexistsin
% @see \pgfkeysappendfilterednamestomacro
\def\pgfkeysfiltered#1#2{%
	% produce 
	% '{<old key predicate>}{<old key handler>}{<default path>}'
	% each expanded exactly one time into the register:  
	% FIXME I had to introduce these expandafters to allow NESTED
	% filters.... isn't there a better way!?
	\pgfkeys@tmptoks=\expandafter{\expandafter{\pgfkeys@key@predicate}}%
	\pgfkeys@tmptoks=\expandafter\expandafter\expandafter{\expandafter\the\expandafter\pgfkeys@tmptoks\expandafter{\pgfkeys@key@handler}}%
	\pgfkeys@tmptoks=\expandafter\expandafter\expandafter{\expandafter\the\expandafter\pgfkeys@tmptoks\expandafter{\pgfkeysdefaultpath}}%
	\expandafter\pgfkeysfiltered@@install\the\pgfkeys@tmptoks{#1}{#2}%
}

% #1,#2,#3: old values of predicate, handler, default path.
% #4,#5: new values of predicate and handler
% #6: key-value-list.
\def\pgfkeysfiltered@@install#1#2#3#4#5#6{%
	\pgfkeys@install@filter@and@invoke{#1}{#2}{#4}{#5}{%
		\let\pgfkeysdefaultpath\pgfkeys@root%
		\pgfkeys@parse#6,\pgfkeys@mainstop%
		\def\pgfkeysdefaultpath{#3}%
	}%
}

% Activates families #1 and processes all options of #3 which belong to
% any activated family.
%
% At the end, families #1 will be deactivated again.
%
% For each *unprocessed* option, the filter handler #2 will be invoked
% with one further argument, namely the type of option (see
% \pgfkeysfiltered).
%
%
% #1: comma separated family list
% #2: a filter handler for the options which did not match the filter.
% #3: key-value pairs
%
% @see \pgfkeysfamilyoptionsone
\def\pgfkeysfamilyoptions#1#2#3{%
	\pgfkeysactivatefamilies{#1}{\pgfkeys@family@deactivation}%
	\pgfkeysfiltered\pgfkeyshasactivefamily{#2}{#3}%
	\pgfkeys@family@deactivation
}
% The same as \pgfkeysfamilyoptions, but with
% \pgfkeyshasactivefamilyornofamily
% as predicate.
%
% #1: comma separated family list
% #2: the predicate which will be invoked if the current key has not
%     family.
% #3: the predicate which will be invoked if the current key is
%     unknown.
% #4: a filter handler for the options which did not match the filter.
% #5: key-value pairs
\def\pgfkeysfamilyoptionsdetailed#1#2#3#4#5{%
	\pgfkeysactivatefamilies{#1}{\pgfkeys@family@deactivation}%
	\pgfkeysfiltered
		{\pgfkeyshasactivefamilyornofamily{#2}{#3}}%
		{#4}{#5}%
	\pgfkeys@family@deactivation
}

% Assuming that macro #1 contains a key=value list, this command
% performs an \pgfkeysalso command for the content of macro #1.
%
% It can be used in conjunction with 
%   - \pgfkeysfiltered and
%   - \pgfkeysappendfilterednamestomacro:
% the first pass fill only process options matching the filter, then,
% a \pgfkeysalsofrom can be used at a later time to set the remaining
% options.
%
% Example:
% \pgfkeys{/my group/.cd,/utils/exec=\pgfkeysalsofrom\filtered}
\def\pgfkeysalsofrom#1{%
	\expandafter\pgfkeysalso\expandafter{#1}%
}

% The same as \pgfkeysalsofrom, but it invokes \pgfkeysalsofiltered.
\def\pgfkeysalsofilteredfrom#1#2#3{%
	\def\pgfkeyspred@TMP{\pgfkeysalsofiltered{#1}{#2}}%
	\expandafter\pgfkeyspred@TMP\expandafter{#3}%
}

% #1 = filter predicate
% #2 = filter handler
% #3 = options
\long\def\pgfkeysalsofiltered#1#2#3{%
	% produce 
	% '{<old key predicate>}{<old key handler>}'
	% each expanded exactly one time into the register:
	\pgfkeys@tmptoks=\expandafter{\expandafter{\pgfkeys@key@predicate}}%
	\pgfkeys@tmptoks=\expandafter\expandafter\expandafter{\expandafter\the\expandafter\pgfkeys@tmptoks\expandafter{\pgfkeys@key@handler}}%
	\expandafter\pgfkeys@install@filter@and@invoke\the\pgfkeys@tmptoks{#1}{#2}{\pgfkeysalso{#3}}%
	%\pgfkeys@install@filter@and@invoke{#1}{#2}{\pgfkeysalso{#3}}%
}%

% The same like \pgfkeysfiltered, but with quick search path setting.
%
% #1: filter predicate
% #2: filter handler
% #3: default path
% #4: key-value-pairs
\def\pgfqkeysfiltered#1#2{%
	% produce 
	% '{<old key predicate>}{<old key handler>}{<default path>}'
	% each expanded exactly one time into the register:
	\pgfkeys@tmptoks=\expandafter{\expandafter{\pgfkeys@key@predicate}}%
	\pgfkeys@tmptoks=\expandafter\expandafter\expandafter{\expandafter\the\expandafter\pgfkeys@tmptoks\expandafter{\pgfkeys@key@handler}}%
	\pgfkeys@tmptoks=\expandafter\expandafter\expandafter{\expandafter\the\expandafter\pgfkeys@tmptoks\expandafter{\pgfkeysdefaultpath}}%
	\expandafter\pgfqkeysfiltered@@install\the\pgfkeys@tmptoks{#1}{#2}%
}

% #1,#2,#3: old values of predicate, handler, default path.
% #4,#5: new values of predicate and handler
% #6: default path
% #7: key-value-list.
\def\pgfqkeysfiltered@@install#1#2#3#4#5#6#7{%
	\pgfkeys@install@filter@and@invoke{#1}{#2}{#4}{#5}{%
		\def\pgfkeysdefaultpath{#6/}\pgfkeys@parse#7,\pgfkeys@mainstop\def\pgfkeysdefaultpath{#3}%
	}%
}

% Family management
%
% The family code provides the following features:
% 1. every key can be associated with 0 or 1 'family'.
% 2. Families are a loose association which are independend of the key
% hierarchy.
%   For example, /my tree/key1  can belong to family /tikz.
%
% 3. It is possible to "activate" or "deactivate" single families.
%    Furthermore, it is possible to set only keys which belong to 
%    active families (using \pgfkeysfiltered).
% 4. Runtime complexities:
%    If you have N options and you only want to process K active
%    families, the runtime is O( N + K ):
%      - activate every family O(K)
%      - use \pgfkeyshasactivefamily as filter predicate O(N)
%      - deactivate every family O(K)


% .is family should
%  1. '.cd' into the families' path,
%  2. define booleans to activate/deactive the family 
%     (see \pgfkeysisfamilyactive)
%  3. make sure that \pgfkeyshasactivefamily returns true for
%     the family itsself.
\pgfkeys{/handlers/.is family/.append code={%
	\expandafter\newif\csname if\pgfkeyscurrentpath/familyactive\endcsname
	\let\pgfkeyspred@TMP=\pgfkeyscurrentpath
	\pgfkeysalso{\pgfkeyspred@TMP/.belongs to family=\pgfkeyspred@TMP}%
	}%
}
\pgfkeys{/handlers/.activate family/.code=\pgfkeysactivatefamily{\pgfkeyscurrentpath}}
\pgfkeys{/handlers/.deactivate family/.code=\pgfkeysdeactivatefamily{\pgfkeyscurrentpath}}
\pgfkeys{/handlers/.belongs to family/.code={%
		\pgfkeysiffamilydefined{#1}{%
			\pgfkeyssetvalue{\pgfkeyscurrentpath/family}{#1}%
		}{%
			\pgfkeysalso{/errors/family unknown=#1}%
		}%
	}%
}%
\pgfkeys{/errors/family unknown/.code=\pgfkeys@error{%
	I do not know family '#1' and can't work with any assoicated family handling. Perhaps you misspelled it.}}

% Activates family #1.
%
% #1 maybe a macro.
\def\pgfkeysactivatefamily#1{\csname#1/familyactivetrue\endcsname
%\message{[ACTIVATING FAMILY #1]}%
}

% Deactivates family #1.
%
% #1 maybe a macro.
\def\pgfkeysdeactivatefamily#1{\csname#1/familyactivefalse\endcsname%
%\message{[DEACTIVATING FAMILY #1]}%
}

% Activates all families in the comma separated list #1.
%
% It will also generate code for deactivation of all those families
% into the command #2.
%
% #1: a comma-separated list of fully qualified family names.
% #2: a command which will be filled with a deactivate-all command.
\def\pgfkeysactivatefamilies#1#2{%
	\let#2=\pgfkeys@empty%
	\pgfkeysfiltered
		{\pgfkeyspredicateFALSE}%
		{\pgf@family@activate@handler{#2}}%
		{#1}%
}

\def\pgf@family@activate@handler#1#2{%
	\pgfkeysactivatefamily{\pgfkeyscurrentkey}%
	% produce 
	%   <old list> '\pgfkeysdeactivatefamily{' <current key> '}'
	\pgfkeys@tmptoks=\expandafter\expandafter\expandafter{\expandafter#1\expandafter\pgfkeysdeactivatefamily\expandafter{\pgfkeyscurrentkey}}%
	\edef\pgfkeys@family@deactivation{\the\pgfkeys@tmptoks}%
}

% If for testing whether a family exists.
%
% #1 = fully qualified family name
% #2 = if-case
% #3 = else-case
%
% Description:
%
% If the family exists, #2 will be executed. Otherwise, #3 will be
% called.
\long\def\pgfkeysiffamilydefined#1#2#3{\pgfkeys@ifcsname if#1/familyactive\endcsname#2\else#3\fi}

% Sets the TeX boolean 
%   \ifpgfkeysfiltercontinue := ( family #1 is active )
% 
% Argument:
% #1 the family name. Maybe a macro.
\def\pgfkeysisfamilyactive#1{%
	\pgfkeysiffamilydefined{#1}{%
		\expandafter\let\expandafter\ifpgfkeysfiltercontinue\csname if#1/familyactive\endcsname
	}{%
		\pgfkeys{/errors/family unknown={#1}}%
		\expandafter\expandafter\expandafter\let\csname ifpgfkeysfiltercontinue\endcsname\csname iffalse\endcsname
	}%
}%

% Retrieve the family of full key #1 into macro #2.
%
% Will set the TeX boolean \ifpgfkeyssuccess to whether the full key
% really has a family.
%
% The family for any key is stored in the sub-key #1/family.
%
% Parameters:
% #1:  the full key name for which the family is requested. Maybe a
%      macro.
% #2:  a macro name which will be filled with the result.
\def\pgfkeysgetfamily#1#2{%
	\pgfkeysifdefined{#1/family}{\pgfkeysgetvalue{#1/family}{#2}\pgfkeyssuccesstrue}{\pgfkeyssuccessfalse}%
}
	

% Possible filter predicate for \pgfkeysfiltered.
%
% Returns true iff the currently processed key belongs to an active family.
%
% A family is active if it has been activated before.
\def\pgfkeyshasactivefamily#1{%
	\ifnum#1=0
		% unknown options shall be processed with the
		% unknown-handlers.
		\pgfkeysfiltercontinuetrue
	\else
		\ifnum#1=3
			\pgfkeysgetfamily\pgfkeyscurrentpath\pgfkeyspred@TMP
		\else
			\pgfkeysgetfamily\pgfkeyscurrentkey\pgfkeyspred@TMP
		\fi
		\ifpgfkeyssuccess
			\pgfkeysisfamilyactive{\pgfkeyspred@TMP}%
		\else% Ok, it does not belong to any family.
			\pgfkeysfiltercontinuefalse
		\fi
	\fi
}

% Possible filter predicate for \pgfkeysfiltered.
%
% This filter works as follows:
% 1. if the current key belongs to a family:
% 	return whether its family is active,
% 2. if the current key does NOT belong to a family:
%   return the result of criterion '#1',
% 3. the current key is unknown:
% 	return the result of criterion '#2'.
%
% Arguments:
% #1: the predicate which will be invoked in case 2.
%   It will be invoked with the current case number as argument.
% #2: the predicate which will be invoked in case 3 with 
%   the current case number as argument.
% #3: the current case number. Will be set by \pgfkeysfiltered.
\def\pgfkeyshasactivefamilyornofamily#1#2#3{%
	\ifnum#3=0
%\message{[pgfkeyshasactivefamilyornofamily(\pgfkeyscurrentkey, #3) invoking unknown handler]}%
		#2{#3}%
	\else
		\ifnum#3=3
			\pgfkeysgetfamily\pgfkeyscurrentpath\pgfkeyspred@TMP
		\else
			\pgfkeysgetfamily\pgfkeyscurrentkey\pgfkeyspred@TMP
		\fi
		\ifpgfkeyssuccess
			\pgfkeysisfamilyactive{\pgfkeyspred@TMP}%
%--------------------------------------------------
% \ifpgfkeysfiltercontinue
% \message{[pgfkeyshasactivefamilyornofamily(\pgfkeyscurrentkey, #3) family is ACTIVE]}%
% \else
% \message{[pgfkeyshasactivefamilyornofamily(\pgfkeyscurrentkey, #3) family is NOT active.]}%
% \fi
%-------------------------------------------------- 
		\else% Ok, it does not belong to any family.
%\message{[pgfkeyshasactivefamilyornofamily(\pgfkeyscurrentkey, #3) invoking has-no-family-handler]}%
			#1{#3}%
		\fi
	\fi
}
% A variant of \pgfkeyshasactivefamily which disables unknown key
% handlers.
\def\pgfkeyshasactivefamilyN#1{%
	\pgfkeyshasactivefamilyornofamily
		{\pgfkeyspredicateFALSE}%
		{\pgfkeyspredicateFALSE}%
		{#1}%
}


% Possible filter predicate for \pgfkeysfiltered.
%
% Processes only options which are childs of #1.
%
% Example:
%   \pgfkeysindescendantof{/foo}...
% will be true for
%  /foo/bar/x=y
%  /foo/.cd
%  /foo/bar/.style=...
% but not for
%  /bar/foo/...
\long\def\pgfkeysisdescendantof#1#2{%
	\ifnum#2=0
		% unknown options shall be processed with the
		% unknown-handlers.
		\pgfkeysfiltercontinuetrue
	\else
		\long\def\pgfkeysisdescendantof@impl##1#1##2\pgf@@eov{%
			\def\pgfkeyspred@TMP{##1}%
			\ifx\pgfkeyspred@TMP\pgfkeys@empty
%\message{'\pgfkeyscurrentkey' (case #2) is descendant of '#1': TRUE.}%
				\pgfkeysfiltercontinuetrue
			\else
%\message{'\pgfkeyscurrentkey' (case #2) is descendant of '#1': FALSE.}%
				\pgfkeysfiltercontinuefalse
			\fi
		}%
		\expandafter\pgfkeysisdescendantof@impl\pgfkeyscurrentkey#1\pgf@@eov
	\fi
}

% True, if the current option is either descendand of #1 or of #2.
\long\def\pgfkeysisdescendantoftwo#1#2#3{%
	\pgfkeysisdescendantof{#1}{#3}%
	\ifpgfkeysfiltercontinue
	\else
		\pgfkeysisdescendantof{#2}{#3}%
	\fi
}

% True, if the current option is either descendand of #1, #2 or #3.
\long\def\pgfkeysisdescendantofthree#1#2#3#4{%
	\pgfkeysisdescendantof{#1}{#4}%
	\ifpgfkeysfiltercontinue
	\else
		\pgfkeysisdescendantof{#2}{#4}%
		\ifpgfkeysfiltercontinue
		\else
			\pgfkeysisdescendantof{#3}{#4}%
		\fi
	\fi
}

% Possible filter predicate for \pgfkeysfiltered.
%
% It returns true if the currently processed full key equals #1.
\long\def\pgfkeysequals#1#2{%
	\ifnum#2=0
		% Unknown option:
		\pgfkeysfiltercontinuetrue
	\else
		\def\pgfkeyspred@TMP{#1}%
		\ifx\pgfkeyscurrentkey\pgfkeyspred@TMP
			\pgfkeysfiltercontinuetrue
		\else
			\pgfkeysfiltercontinuefalse
		\fi
	\fi
}%

% Possible filter predicate for \pgfkeysfiltered.
%
% Argument #1 can be any other filter predicate, its logical return
% value will be inverted.
\long\def\pgfkeyspredicateNOT#1#2{%
	#1{#2}%
	\ifpgfkeysfiltercontinue
		\pgfkeysfiltercontinuefalse
	\else
		\pgfkeysfiltercontinuetrue
	\fi
}

% Possible filter predicate for \pgfkeysfiltered.
%
% Returns true if #1 or #2 is true.
%
% If #1 is true, #2 won't be queried.
%
% #3 is the argument which is supplied by \pgfkeysfiltered
\long\def\pgfkeyspredicateOR#1#2#3{%
	#1{#3}%
	\ifpgfkeysfiltercontinue
	\else
		#2{#3}%
	\fi
}

% Like \pgfkeyspredicateOR, just with a logical AND.
\long\def\pgfkeyspredicateAND#1#2#3{%
	#1{#3}%
	\ifpgfkeysfiltercontinue
		#2{#3}%
	\fi
}

% Like \pgfkeyspredicateOR, returns always TRUE.
\long\def\pgfkeyspredicateTRUE#1{\pgfkeysfiltercontinuetrue}
\long\def\pgfkeyspredicateFALSE#1{\pgfkeysfiltercontinuefalse}


% Possible filter predicate for \pgfkeysfiltered.
%
% It returns false if the current key is unknown, which avoids calling
% the unknown handlers.
\def\pgfkeysknown#1{%
	\ifnum#1=0
		\pgfkeysfiltercontinuefalse
	\else
		\pgfkeysfiltercontinuetrue
	\fi
}

% Possible filter handler for \pgfkeysfiltered.
%
% It does nothing if an option has not been processed.
\def\pgfkeysignore#1{}%

% Possible filter handler for \pgfkeysfiltered.
%
% It appends key=value for each option which has not been processed to
% the macro #1. It doesn't reset #1 at the beginning.
\def\pgfkeysappendfilterednamestomacro#1#2{%
	% Produce
	%  <orig key> '={' <value> '}'
	% where both, the key and the value are expanded just ONCE:
	\pgfkeys@tmptoks=\expandafter\expandafter\expandafter{\expandafter\pgfkeyscurrentkeyRAW\expandafter=\expandafter{\pgfkeyscurrentvalue}}%
	\ifx#1\pgfkeys@empty
	\else
		% Produce <old list> ','  <orig key> '={' <value> '}'
		\pgfkeys@tmptoks=\expandafter\expandafter\expandafter{\expandafter#1\expandafter,\the\pgfkeys@tmptoks}%
	\fi
	\edef#1{\the\pgfkeys@tmptoks}%
}

% Possible filter handler for \pgfkeysfiltered.
%
% It simply writes a log message for each options which has not been
% processed.
\def\pgfkeyslogfiltered#1{%
	\message{LOG: the option '\pgfkeyscurrentkey' (was originally '\pgfkeyscurrentkeyRAW') (case #1) has not been processed due to pgfkeysfiltered.}%
}

% An addition to the '.try' and '.retry' handlers:
%
% It is the same as '.retry', but if the option is still unknown, the
% usual handlers for unknown keys will be invoked.
\pgfkeys{/handlers/.lastretry/.code=
	\ifpgfkeyssuccess\else
		\pgfkeys@try
		\ifpgfkeyssuccess\else
			% discard the '.lastretry' suffix:
			\edef\pgfkeyscurrentkey{\pgfkeyscurrentpath}%
			\pgfkeys@split@path%
			\pgfkeys@unknown
		\fi
	\fi}

% -----------------------------------------------------------------------------
%
%  IMPLEMENTATION
%
% -----------------------------------------------------------------------------


% Sets \ifpgfkeysfiltercontinue to true iff the current key belongs to
% the /errors tree.
\long\def\pgfkeys@cur@is@descendant@of@errors{%
	\expandafter\pgfkeys@cur@is@descendant@of@errors@impl\pgfkeyscurrentkey/errors\pgf@@eov
}%
\long\def\pgfkeys@cur@is@descendant@of@errors@impl#1/errors#2\pgf@@eov{%
	\def\pgfkeyspred@TMP{#1}%
	\ifx\pgfkeyspred@TMP\pgfkeys@empty
%\message{[SPECIAL CHECK] '\pgfkeyscurrentkey' is descendant of '/errors': TRUE.}%
		\pgfkeysfiltercontinuetrue
	\else
%\message{[SPECIAL CHECK] '\pgfkeyscurrentkey' is descendant of '/errors': FALSE.}%
		\pgfkeysfiltercontinuefalse
	\fi
}%

% #1,#2: old values of predicate and handler
% #3,#4: new value of predicate and handler
% #5 the code to invoke before init and cleanup
\def\pgfkeys@install@filter@and@invoke#1#2#3#4#5{%
	\def\pgfkeys@key@predicate{#3}%
	\def\pgfkeys@filtered@handler{#4}%
	\let\pgfkeys@case@one=\pgfkeys@case@one@filtered
	\let\pgfkeys@try=\pgfkeys@try@filtered
	\let\pgfkeys@unknown=\pgfkeys@unknown@filtered
	#5%
	\def\pgfkeys@key@predicate{#1}%
	\def\pgfkeys@key@handler{#2}%
	\ifx\pgfkeys@key@predicate\pgfkeys@empty
		\let\pgfkeys@case@one=\pgfkeys@orig@case@one
		\let\pgfkeys@try=\pgfkeys@orig@try
		\let\pgfkeys@unknown=\pgfkeys@orig@unknown
	\fi
}


% This command does THE SAME work as \pgfkeys@case@one,
% but it applies filtering whenever it identified the type of an
% option.
\def\pgfkeys@case@one@filtered{%
	\pgfkeys@cur@is@descendant@of@errors
	\ifpgfkeysfiltercontinue
		\pgfkeys@orig@case@one
	\else
		\pgfkeysfiltercontinuetrue
		\pgfkeysifdefined{\pgfkeyscurrentkey/.@cmd}{%
			% CASE ONE: a command option
			\pgfkeys@key@predicate{1}%
			\ifpgfkeysfiltercontinue
%\message{PROCESSING KEY \pgfkeyscurrentkey!}%
				\pgfkeysgetvalue{\pgfkeyscurrentkey/.@cmd}{\pgfkeys@code}%
				\expandafter\pgfkeys@code\pgfkeyscurrentvalue\pgfeov
			\else
%\message{FILTEReD OUT  KEY \pgfkeyscurrentkey!}%
				\pgfkeys@filtered@handler{1}%
			\fi
		}{%
			% CASE TWO: a normal value option
			\pgfkeysifdefined{\pgfkeyscurrentkey}{%
				\pgfkeys@key@predicate{2}%
				\ifpgfkeysfiltercontinue
%\message{PROCESSING KEY \pgfkeyscurrentkey!}%
					\pgfkeys@case@two@extern
				\else
%\message{FILTEReD OUT  KEY \pgfkeyscurrentkey!}%
					\pgfkeys@filtered@handler{2}%
				\fi
			}{%
				\pgfkeys@split@path
				% CASE THREE: a handler
				\pgfkeysifdefined{/handlers/\pgfkeyscurrentname/.@cmd}{%
					\pgfkeys@key@predicate{3}%
					\ifpgfkeysfiltercontinue
%\message{PROCESSING KEY \pgfkeyscurrentkey!}%
						\pgfkeysgetvalue{/handlers/\pgfkeyscurrentname/.@cmd}{\pgfkeys@code}%
						\expandafter\pgfkeys@code\pgfkeyscurrentvalue\pgfeov
					\else
%\message{FILTERED OUT  KEY \pgfkeyscurrentkey!}%
						\pgfkeys@filtered@handler{3}%
					\fi
				}{%
					\pgfkeys@unknown
				}%
			}%
		}%
	\fi
}%

\def\pgfkeys@unknown@filtered{%
	% CASE ZERO: an unknown option.
	\pgfkeys@key@predicate{0}%
	\ifpgfkeysfiltercontinue
%\message{PROCESSING  KEY \pgfkeyscurrentkey!}%
		% start normal 'unknown' handlers:
		\pgfkeys@orig@unknown
	\else
%\message{FILTEReD OUT  KEY \pgfkeyscurrentkey!}%
		\pgfkeys@filtered@handler{0}%
	\fi
}

% Does the same as \pgfkeys@try, but it also invokes the key filters.
\def\pgfkeys@try@filtered{%
	\ifpgfkeysfiltercontinue
		\pgfkeys@orig@try
	\else
		\pgfkeysfiltercontinuetrue
		\pgfkeysifdefined{\pgfkeyscurrentpath/.@cmd}%
		{%
			% CASE ONE: a command option
			\pgfkeys@key@predicate{1}%
			\ifpgfkeysfiltercontinue
				\pgfkeysgetvalue{\pgfkeyscurrentkey/.@cmd}{\pgfkeys@code}%
				\ifx\pgfkeyscurrentvalue\pgfkeysnovalue@text% Hmm... no value
					\pgfkeysifdefined{\pgfkeyscurrentpath/.@def}%
					{\pgfkeysgetvalue{\pgfkeyscurrentpath/.@def}{\pgfkeyscurrentvalue}}
					{}% no default, so leave it
				\fi%
				\expandafter\pgfkeys@code\pgfkeyscurrentvalue\pgfeov%
			\else
				\pgfkeys@filtered@handler{1}%
			\fi
			\pgfkeyssuccesstrue%
		}%
		{%
			\pgfkeysifdefined{\pgfkeyscurrentpath}%
			{% CASE TWO: a normal value option
				\pgfkeys@key@predicate{2}%
				\ifpgfkeysfiltercontinue
					\ifx\pgfkeyscurrentvalue\pgfkeysnovalue@text%
						\pgfkeysvalueof{\pgfkeyscurrentpath}%
					\else%
						\pgfkeyslet{\pgfkeyscurrentpath}\pgfkeyscurrentvalue%
					\fi%
				\else
					\pgfkeys@filtered@handler{2}%
				\fi
				\pgfkeyssuccesstrue%
			}%
			{\pgfkeyssuccessfalse}%
		}%
	\fi
}



\def\pgfkeys@nevermind#1\relax{\let\pgfkeyscurrentkeyRAW=\pgfkeyscurrentkey}
\def\pgfkeys@addpath#1\relax{\def\pgfkeyscurrentkeyRAW{#1}% old @addpath:	
	\edef\pgfkeyscurrentkey{\pgfkeysdefaultpath#1}%
}

% #1: comma separated family list
% #2: filter handler
% #3: default path
% #4: key-value pairs
\def\pgfqkeysfamilyoptions#1#2#3#4{%
	\pgfkeysactivatefamilies{#1}{\pgfkeys@family@deactivation}%
	\pgfqkeysfiltered\pgfkeyshasactivefamily{#2}{#3}{#4}%
	\pgfkeys@family@deactivation
}

% The same as \pgfqkeysfamilyoptions, just with
% \pgfkeyshasactivefamilyN as predicate.
%
% #1: comma separated family list
% #2: the predicate which will be invoked if the current key has not
%     family.
% #3: the predicate which will be invoked if the current key is
%     unknown.
% #4: filter handler
% #5: default path
% #6: key-value pairs
\def\pgfqkeysfamilyoptionsdetailed#1#2#3#4#5#6{%
	\pgfkeysactivatefamilies{#1}{\pgfkeys@family@deactivation}%
	\pgfqkeysfiltered%
		{\pgfkeyshasactivefamilyornofamily{#2}{#3}}%
		{#4}{#5}{#6}%
	\pgfkeys@family@deactivation
}


\def\pgfkeyssplitpath{\pgfkeys@split@path}%


% #1: family (maybe a macro)
% #2: filter handler
% #3: default path
% #4: key-value pairs
\def\pgfqkeysfamilyoptionsone#1#2#3#4{%
	\pgfkeysactivatefamily{#1}%
	\pgfqkeysfiltered\pgfkeyshasactivefamily{#2}{#3}{#4}%
	\pgfkeysdeactivatefamily{#1}%
}

% The same but with \pgfkeyshasactivefamilyN instead of
% \pgfkeyshasactivefamily.
\def\pgfqkeysfamilyoptionsNone#1#2#3#4{%
	\pgfkeysactivatefamily{#1}%
	\pgfqkeysfiltered\pgfkeyshasactivefamilyN{#2}{#3}{#4}%
	\pgfkeysdeactivatefamily{#1}%
}


% Like \pgfkeysfamilyoptionsone, just with the 'also' method.
\def\pgfkeysalsofamilyoptionsone#1#2#3{%
	\pgfkeysactivatefamily{#1}%
	\pgfkeysalsofiltered\pgfkeyshasactivefamily{#2}{#3}%
	\pgfkeysdeactivatefamily{#1}%
}

% #1: family (maybe a macro)
% #2: filter handler
% #3: key-value pairs
\def\pgfkeysfamilyoptionsone#1#2#3{%
	\pgfkeysactivatefamily{#1}%
	\pgfkeysfiltered\pgfkeyshasactivefamily{#2}{#3}%
	\pgfkeysdeactivatefamily{#1}%
}

\endinput
