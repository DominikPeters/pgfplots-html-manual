%--------------------------------------------
%
% Package pgfplots
%
% Provides a user-friendly interface to create function plots (normal
% plots, semi-logplots and double-logplots).
% 
% It is based on Till Tantau's PGF package.
%
% Copyright 2007/2008 by Christian Feuers√§nger.
%
% This program is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program.  If not, see <http://www.gnu.org/licenses/>.
%
%--------------------------------------------

%
% This file contains the implementation for stacked plots.
%
% Stacked plots always keep record of the last plotted coordinates.
% Any new plot will be ADDED on top of the last plotted coordinates.
% 
% Terminology: "last plotted coordinates" are called "zero levels"
% because they actually work like shifts.
%
% Programming Structure:
%
% 1. We keep TWO lists of coordinates: a list of CURRENT zero level
% coordinates and a list of NEXT zero level coordinates.
%
% The first one will be queried whenever a zero level coordinate is
% requested.
%
% The second one will be used to form zero levels for the next plot.
%
% 2. At the beginning and end of each plot, the lists in 1.) are
% initialised properly.
%
% 3. While plot coordinates are processed, the following methods
% interact with the stacked API:
% \pgfplots@stacked@preparepoint@inmacro
% 	-> compute the 'stacked' sum.
% 	This may need to be done with floating point arithmetics because
% 	the data scaling trafo is not yet initialised
%
% \pgfplots@stacked@finishpoint
% 	-> takes coordinates as they will be given to Tikz. This method is
% 	used to 
% 		- communicate zero level coordinates to Tikz
% 		- implement the 'closed paths' option (allows filled stacked plots).
%
% \pgfplots@stacked@rememberzerolevelpoint@for@next@plot
% \pgfplots@stacked@getnextzerolevelpoint
%
% 4. Zero levels are communicated to Tikz by
% \pgfplots@stacked@initzerolevelhandler. This routine initialises an
% input stream for Tikz plot handlers which produces a sequence of
% zero levels. It is used by [xy]comb and [xy]bar.
%
%
% REMARK:
% the state of the boolean \ifpgfplots@datascaletrafo@initialised
% determines whether these routines expect and return floating point
% numbers or fixed point numbers.

\let\pgfplots@stacked@zerolevelpoint@x=\pgfutil@empty
\let\pgfplots@stacked@zerolevelpoint@y=\pgfutil@empty
\newif\ifpgfplots@stacked@isfirstplot
\newif\ifpgfplots@stacked@isinitialised

% Pre-initialisation.
% Needs to be called before the first call to
% \pgfplots@stacked@beginplot.
\def\pgfplots@stacked@initialise{%
	\pgfplots@stacked@isfirstplottrue
	\pgfplots@stacked@isinitialisedtrue
}%

% Cleanup method. Truncates any global variables to reduce string
% space.
\def\pgfplots@stacked@finalize{%
	\global\pgfplotslistnewempty\pgfplots@stacked@zerolevellist
	\global\pgfplotslistnewempty\pgfplots@stacked@nextzerolevellist
	\pgfplots@stacked@isinitialisedfalse
}%

% (Re)defines the macro \pgfplots@stacked@getnextzerolevelpoint
% at the beginning of each plot.
%
% The macro \pgfplots@stacked@getnextzerolevelpoint fills
% \pgfplots@stacked@zerolevelpoint@[xy].
%
% ATTENTION: call \pgfplots@stacked@initialise before the first call
% to beginplot!
\def\pgfplots@stacked@beginplot{%
%\message{pgfplots@stacked@beginplot: PLOT STARTED.}%
	\ifpgfplots@stacked@isinitialised
	\else
		\pgfplots@error{LOGIC ERROR: please call \string\pgfplots@stacked@initialise.}%
	\fi
	\global\pgfplotslistnewempty\pgfplots@stacked@PGFzerolevels
	% accumulate this command here for \closedcycle:
	\let\pgfplots@stacked@closedcycle@impl=\pgfutil@empty
	\ifpgfplots@stacked@isfirstplot
		\global\pgfplotslistnewempty\pgfplots@stacked@zerolevellist
		\def\pgfplots@stacked@zerolevelpoint@x{0}%
		\def\pgfplots@stacked@zerolevelpoint@y{0}%
		% only work with float if its really necessary - for
		% example if the scaling trafo which maps to pgfmath is
		% not yet initialised.
		\ifpgfplots@datascaletrafo@initialised
		\else
			\ifpgfplots@xislinear
				\pgfmathfloatcreate{0}{0.0}{0}%
				\let\pgfplots@stacked@zerolevelpoint@x=\pgfmathresult
			\fi
			\ifpgfplots@yislinear
				\pgfmathfloatcreate{0}{0.0}{0}%
				\let\pgfplots@stacked@zerolevelpoint@y=\pgfmathresult
			\fi
		\fi
		\def\pgfplots@stacked@getnextzerolevelpoint{}% will remain constant anyway.
	\else
		{\globaldefs=1
		\pgfplotslistcopy\pgfplots@stacked@nextzerolevellist\to\pgfplots@stacked@zerolevellist
		}%
		\def\pgfplots@stacked@getnextzerolevelpoint{%
			{\globaldefs=1
			\pgfplotslistpopfront\pgfplots@stacked@zerolevellist\to\pgfmathresult
			}%
			\expandafter\pgfplots@stacked@parsezerolevelpoint\pgfmathresult
		}%
	\fi
	\global\pgfplotslistnewempty\pgfplots@stacked@nextzerolevellist
}%

\def\pgfplots@stacked@parsezerolevelpoint(#1,#2){%
	\def\pgfplots@stacked@zerolevelpoint@x{#1}%
	\def\pgfplots@stacked@zerolevelpoint@y{#2}%
}

\def\pgfplots@stacked@endplot{%
	\ifpgfplots@stacked@isfirstplot
		\let\pgfplots@stacked@closedcycle@impl=\pgfplots@path@closed@cycle@std
	\else
		\pgfplots@toka=\expandafter{\pgfplots@stacked@closedcycle@impl}%
		\edef\pgfplots@stacked@closedcycle@impl{%
			[mark=none,/utils/exec=\noexpand\pgfplots@try@mirror@plot@handler]
			--plot coordinates{\the\pgfplots@toka}
			--cycle
		}%
	\fi
	\global\pgfplots@stacked@isfirstplotfalse
%\message{pgfplots@stacked@endplot: PLOT ENDED}%
}%

% WARNING: when this method is called, NEITHER
% \ifpgfplots@stacked@isfirstplot NOR the zero level lists are
% initialised!
\def\pgfplots@stacked@initzerolevelhandler{%
	\ifpgfplots@stacked@x
		\pgfplotxzerolevelstream@@list
		\pgfplotyzerolevelstreamconstant{\pgfplots@ZERO@y}%
	\else
		\pgfplotxzerolevelstreamconstant{\pgfplots@ZERO@x}%
		\pgfplotyzerolevelstream@@list
	\fi
}%

\def\pgfplots@stacked@rememberzerolevelpoint@for@next@plot#1{%
	\edef\pgfplots@TMP{#1}%
	{\globaldefs=1
	\expandafter\pgfplotslistpushback\pgfplots@TMP\to\pgfplots@stacked@nextzerolevellist
	}%
}

\def\pgfplots@stacked@finishpoint#1#2{%
	\ifpgfplots@stacked@isfirstplot
	\else
		\pgfpointxy{\pgfplots@stacked@zerolevelpoint@x}{\pgfplots@stacked@zerolevelpoint@y}%
		\ifpgfplots@stacked@x
			\edef\pgfplots@TMP{\the\pgf@x}%
		\else
			\edef\pgfplots@TMP{\the\pgf@y}%
		\fi
		{\globaldefs=1
		\expandafter\pgfplotslistpushback\pgfplots@TMP\to\pgfplots@stacked@PGFzerolevels
		}%
		\pgfplotslist@TOK@a=\expandafter{\pgfplots@stacked@closedcycle@impl}%
		\edef\pgfplots@stacked@closedcycle@impl{%
			(\pgfplots@stacked@zerolevelpoint@x,\pgfplots@stacked@zerolevelpoint@y)%
			\the\pgfplotslist@TOK@a}%
	\fi
}%

\def\pgfplots@stacked@preparepoint@inmacro#1#2{%
	\pgfplots@stacked@getnextzerolevelpoint
	\ifpgfplots@stacked@x
		\ifpgfplots@stacked@plus
			\let\pgfplots@stacked@op=\pgfmathadd@
		\else
			\let\pgfplots@stacked@op=\pgfmathsubtract@
		\fi
		\ifpgfplots@xislinear
			\ifpgfplots@datascaletrafo@initialised
			\else
				\ifpgfplots@stacked@plus
					\let\pgfplots@stacked@op=\pgfmathfloatadd@
				\else
					\let\pgfplots@stacked@op=\pgfmathfloatsubtract@
				\fi
			\fi
		\fi
		\pgfplots@stacked@op{\pgfplots@stacked@zerolevelpoint@x}{#1}%
		\let#1=\pgfmathresult
	\else
		\ifpgfplots@stacked@plus
			\let\pgfplots@stacked@op=\pgfmathadd@
		\else
			\let\pgfplots@stacked@op=\pgfmathsubtract@
		\fi
		\ifpgfplots@yislinear
			\ifpgfplots@datascaletrafo@initialised
			\else
				\ifpgfplots@stacked@plus
					\let\pgfplots@stacked@op=\pgfmathfloatadd@
				\else
					\let\pgfplots@stacked@op=\pgfmathfloatsubtract@
				\fi
			\fi
		\fi
		\pgfplots@stacked@op{\pgfplots@stacked@zerolevelpoint@y}{#2}%
		\let#2=\pgfmathresult
	\fi
	\pgfplots@stacked@rememberzerolevelpoint@for@next@plot{(#1,#2)}%
}

% This here is a re-implementation of the stored plot processing.
%
% The idea is simply, although it requires quite some work:
%
% If we stack plots on top of each other, early drawing commands
% (early plots) will be OVERDRAWN by later drawing commands (later
% plots). This is especially unfortunate if we use filled bar plots
% or comb plots.
%
% IDEA: draw plots in REVERSE order. The positioning, styles and
% whatever must not be affected, only the sequence of drawing commands
% shall change.
%
% So, this command here does all numerics which is to be done and
% assembles a NEW, REVERSED STORED PLOT LIST.
\def\pgfplots@stacked@finalize@stored@plots{%
	\pgfplotslistnewempty\pgfplots@stored@plotlist@reversed
	\begingroup
	\pgfplotslistforeachungrouped\pgfplots@stored@plotlist\as\pgfplots@TMP{%
		\expandafter\pgfplots@stored@plotlist@EXTRACTENTRY\pgfplots@TMP
		\ifx\pgfplots@stored@current@cmd\pgfutil@empty
		\else
			\ifpgfplots@apply@datatrafo
				% Apply the data scaling transformation, but do NOT
				% issue any drawing commands (-> use the ...@dryrun
				% version)
				\expandafter\pgfplots@coord@stream@finalize@storedcoords@START@dryrun\pgfplots@stored@current@data\to\pgfplots@stored@current@data\pgfplots@stored@current@precmdapp%
				% save any intermediate results as "precmd":
				\pgfplotslist@TOK@b=\expandafter{\pgfplots@stored@current@precmd}%
				\pgfplotslist@TOK@a=\expandafter{\pgfplots@stored@current@precmdapp}%
				\edef\pgfplots@stored@current@precmd{\the\pgfplotslist@TOK@b\the\pgfplotslist@TOK@a}%
			\fi
		\fi
		% Now, we need to insert all stored entities into the new,
		% reversed list. We only expand them ONCE.
		\pgfplotslist@TOK@a=\expandafter{\pgfplots@stored@current@precmd}%
		\pgfplotslist@TOK@b=\expandafter{\pgfplots@stored@current@cmd}%
		\edef\pgfplots@TMP{%
			{\the\pgfplotslist@TOK@a}{\the\pgfplotslist@TOK@b}}%
		\pgfplots@toka=\expandafter{\pgfplots@TMP}%
		\pgfplotslist@TOK@a=\expandafter{\pgfplots@stored@current@data}%
		\pgfplotslist@TOK@b=\expandafter{\pgfplots@stored@current@postcmd}%
		\edef\pgfplots@TMP{%
			\the\pgfplots@toka
			{\the\pgfplotslist@TOK@a}{\the\pgfplotslist@TOK@b}}%
		% Reverse sequence:
		\expandafter\pgfplotslistpushfront\pgfplots@TMP\to\pgfplots@stored@plotlist@reversed
	}%
	% Now, overwrite the original list:
	\global\let\pgfplots@stored@plotlist=\pgfplots@stored@plotlist@reversed
	\endgroup
}%

\def\pgfplots@stacked@path@closed@cycle{%
	\pgfplots@stacked@closedcycle@impl
}

% Saves the finalized variables into macro #1 such that a call to #1
% restores them.
%
% This affects pgf zero level handlers and whether this here is the
% first plot or not..
\def\pgfplots@stacked@savestateto#1{%
	\pgfplotslist@TOK@a=\expandafter{\pgfplots@stacked@PGFzerolevels}%
	\ifpgfplots@stacked@isfirstplot
		\pgfplotslist@TOK@b={\pgfplots@stacked@isfirstplottrue}%
	\else
		\pgfplotslist@TOK@b={\pgfplots@stacked@isfirstplotfalse}%
	\fi
	\pgfplots@toka=\expandafter{\pgfplots@stacked@closedcycle@impl}%
	\edef#1{%
		\noexpand\gdef\noexpand\pgfplots@stacked@PGFzerolevels{\the\pgfplotslist@TOK@a}%
		\the\pgfplotslist@TOK@b
		\noexpand\def\noexpand\pgfplots@stacked@closedcycle@impl{\the\pgfplots@toka}%
	}%
}

% PGF interfaces:
\def\pgfplotxzerolevelstream@@list{%
	\def\pgf@plotxzerolevelstreamstart{%
		\global\let\pgfplotxzerolevelstream@@list@@backup=\pgfplots@stacked@PGFzerolevels
		\gdef\pgf@plotxzerolevelstreamnext{%
			\pgfplotslistcheckempty\pgfplots@stacked@PGFzerolevels
			\ifpgfplotslistempty
				\global\pgf@x=\pgfplots@ZERO@x\relax
			\else
				{\globaldefs=1\relax
				\pgfplotslistpopfront\pgfplots@stacked@PGFzerolevels\to\pgfmathresult
				}%
				\global\pgf@x=\pgfmathresult\relax
			\fi
		}%
	}%
	\def\pgf@plotxzerolevelstreamend{%
		\global\let\pgfplots@stacked@PGFzerolevels=\pgfplotxzerolevelstream@@list@@backup
	}%
}%

\def\pgfplotyzerolevelstream@@list{%
	\def\pgf@plotyzerolevelstreamstart{%
		\global\let\pgfplotyzerolevelstream@@list@@backup=\pgfplots@stacked@PGFzerolevels
		\gdef\pgf@plotyzerolevelstreamnext{%
			\pgfplotslistcheckempty\pgfplots@stacked@PGFzerolevels
			\ifpgfplotslistempty
				\global\pgf@x=\pgfplots@ZERO@y\relax
			\else
				{\globaldefs=1\relax
				\pgfplotslistpopfront\pgfplots@stacked@PGFzerolevels\to\pgfmathresult
				}%
				\global\pgf@x=\pgfmathresult\relax
			\fi
		}%
	}%
	\def\pgf@plotyzerolevelstreamend{%
		\global\let\pgfplots@stacked@PGFzerolevels=\pgfplotyzerolevelstream@@list@@backup
	}%
}%
