%--------------------------------------------
%
% Package pgfplots
%
% Provides a user-friendly interface to create function plots (normal
% plots, semi-logplots and double-logplots).
% 
% It is based on Till Tantau's PGF package.
%
% Copyright 2007/2008 by Christian Feuers√§nger.
%
% This program is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program.  If not, see <http://www.gnu.org/licenses/>.
%
%--------------------------------------------

% This file contains the code to process coordinates
% - coordinate input: \addplot and its variants,
% - coordinate loops,
% - single coordinate processing


% Denotes a point in a twodimensional hyperplane. The hyperplane is
% one of the six planes of the threedimensional axis cube.
% 
% The meaning of coordinates #1 and #2 will be redefined depending on
% which surface we are currently processing. You can get the axis
% names for '#1' (a) and '#2' (b) using the macros
% \pgfplotspointonorientedsurfaceA
% and
% \pgfplotspointonorientedsurfaceB.
%
% Example:
% \pgfplotspointonorientedsurfaceabsetupforxyz{0}
% ->
%  \pgfplotspointonorientedsurfaceA = x
%  \pgfplotspointonorientedsurfaceB = y
%  \pgfplotspointonorientedsurfaceab{3}{4} = \pgfqpointxyz{3}{4}{0}
%
% \pgfplotspointonorientedsurfaceabsetupforyxz{0}
% ->
%  \pgfplotspointonorientedsurfaceA = y
%  \pgfplotspointonorientedsurfaceB = x
%  \pgfplotspointonorientedsurfaceab{3}{4} = \pgfqpointxyz{4}{3}{0}
%
% @see \pgfplotspointonorientedsurfaceabsetupforxyz
\def\pgfplotspointonorientedsurfaceab#1#2{%
	\pgfplots@error{Internal logic error: \string\pgfplotspointonorientedsurfaceab\ used although surface has not been declared! You need to call \string\pgfplotspointonorientedsurfaceabsetupforxyz\ or its friends to do so.}%
}%

% Initialises \pgfplotspointonorientedsurfaceab such that 'a' is the x
% axis and 'b' is the y axis and the z coordinate has been fixed with
% \pgfplotspointonorientedsurfaceabsetupforsetz{}.
%
% The Z value needs to be fixed with 
% \pgfplotspointonorientedsurfaceabsetupforsetz
\def\pgfplotspointonorientedsurfaceabsetupforxyz{%
	\def\pgfplotspointonorientedsurfaceab##1##2{\pgfplotsqpointxyz{##1}{##2}{\pgfplotspointonorientedsurfaceabsetupfor@fixedZ}}%
	\def\pgfplotspointonorientedsurfaceA{x}%
	\def\pgfplotspointonorientedsurfaceB{y}%
	\edef\pgflotspointonorientedsurfacespec{ab\pgfplotspointonorientedsurfaceabsetupfor@fixedsymbol}%
}%
\def\pgfplotspointonorientedsurfaceabsetupforyxz{%
	\def\pgfplotspointonorientedsurfaceab##1##2{\pgfplotsqpointxyz{##2}{##1}{\pgfplotspointonorientedsurfaceabsetupfor@fixedZ}}%
	\def\pgfplotspointonorientedsurfaceA{y}%
	\def\pgfplotspointonorientedsurfaceB{x}%
	\edef\pgflotspointonorientedsurfacespec{ba\pgfplotspointonorientedsurfaceabsetupfor@fixedsymbol}%
}%
\def\pgfplotspointonorientedsurfaceabsetupforxzy{%
	\def\pgfplotspointonorientedsurfaceab##1##2{\pgfplotsqpointxyz{##1}{\pgfplotspointonorientedsurfaceabsetupfor@fixedY}{##2}}%
	\def\pgfplotspointonorientedsurfaceA{x}%
	\def\pgfplotspointonorientedsurfaceB{z}%
	\edef\pgflotspointonorientedsurfacespec{a\pgfplotspointonorientedsurfaceabsetupfor@fixedsymbol b}%
}%
\def\pgfplotspointonorientedsurfaceabsetupforzxy{%
	\def\pgfplotspointonorientedsurfaceab##1##2{\pgfplotsqpointxyz{##2}{\pgfplotspointonorientedsurfaceabsetupfor@fixedY}{##1}}%
	\def\pgfplotspointonorientedsurfaceA{z}%
	\def\pgfplotspointonorientedsurfaceB{x}%
	\edef\pgflotspointonorientedsurfacespec{b\pgfplotspointonorientedsurfaceabsetupfor@fixedsymbol a}%
}%
\def\pgfplotspointonorientedsurfaceabsetupforyzx{%
	\def\pgfplotspointonorientedsurfaceab##1##2{\pgfplotsqpointxyz{\pgfplotspointonorientedsurfaceabsetupfor@fixedX}{##1}{##2}}%
	\def\pgfplotspointonorientedsurfaceA{y}%
	\def\pgfplotspointonorientedsurfaceB{z}%
	\edef\pgflotspointonorientedsurfacespec{\pgfplotspointonorientedsurfaceabsetupfor@fixedsymbol ab}%
}%
\def\pgfplotspointonorientedsurfaceabsetupforzyx{%
	\def\pgfplotspointonorientedsurfaceab##1##2{\pgfplotsqpointxyz{\pgfplotspointonorientedsurfaceabsetupfor@fixedX}{##2}{##1}}%
	\def\pgfplotspointonorientedsurfaceA{z}%
	\def\pgfplotspointonorientedsurfaceB{y}%
	\edef\pgflotspointonorientedsurfacespec{\pgfplotspointonorientedsurfaceabsetupfor@fixedsymbol ba}%
}%

% Fixes 'x' to #1 for use in
% \pgfplotspointonorientedsurfaceabsetupforzyx and 
% \pgfplotspointonorientedsurfaceabsetupforyzx.
%
% #1: The fixed value for 'x'.
% #2: a one-character symbol describing 'x'.
% Command characters are
% 	- 0 : x is the lower x-axis range.
% 	- 1 : x is the upper x-axis range.
% 	- 2 : other.
\def\pgfplotspointonorientedsurfaceabsetupforsetx#1#2{%
	\edef\pgfplotspointonorientedsurfaceabsetupfor@fixedX{#1}%
	\edef\pgfplotspointonorientedsurfaceabsetupfor@fixedsymbol{#2}%
}%
\def\pgfplotspointonorientedsurfaceabsetupforsety#1#2{%
	\edef\pgfplotspointonorientedsurfaceabsetupfor@fixedY{#1}%
	\edef\pgfplotspointonorientedsurfaceabsetupfor@fixedsymbol{#2}%
}%
\def\pgfplotspointonorientedsurfaceabsetupforsetz#1#2{%
	\edef\pgfplotspointonorientedsurfaceabsetupfor@fixedZ{#1}%
	\edef\pgfplotspointonorientedsurfaceabsetupfor@fixedsymbol{#2}%
}%

% Helper methods which should be used if no Z component exists (pure
% 2d plots).
\def\pgfplotspointonorientedsurfaceabsetupforxy{%
	\let\pgfplotspointonorientedsurfaceabsetupfor@fixedsymbol=\pgfutil@empty%
	\def\pgfplotspointonorientedsurfaceab##1##2{\pgfplotsqpointxy{##1}{##2}}%
	\def\pgfplotspointonorientedsurfaceA{x}%
	\def\pgfplotspointonorientedsurfaceB{y}%
	\edef\pgflotspointonorientedsurfacespec{ab\pgfplotspointonorientedsurfaceabsetupfor@fixedsymbol}%
}%
\def\pgfplotspointonorientedsurfaceabsetupforyx{%
	\let\pgfplotspointonorientedsurfaceabsetupfor@fixedsymbol=\pgfutil@empty%
	\def\pgfplotspointonorientedsurfaceab##1##2{\pgfplotsqpointxy{##2}{##1}}%
	\def\pgfplotspointonorientedsurfaceA{y}%
	\def\pgfplotspointonorientedsurfaceB{x}%
	\edef\pgflotspointonorientedsurfacespec{ba\pgfplotspointonorientedsurfaceabsetupfor@fixedsymbol}%
}%

% Checks whether the line specified by a three-character-string '#1'
% is inside of the currently set-up oriented surface.
%
% The return value is encoded as integer into the macro #2 as
% described below.
%
% #1 : a three-character string uniquely identifing an axis line.
%      Each of the three characters can be 'x', '0' or '1'.
%      The value '0' denotes the lower axis range while '1' denotes
%      the upper axis range. The first character contains the values
%      for the 'x' axis, the second character for the 'y' axis and the
%      third character for the 'z' axis.
%      Example:
%      	'x01' is the axis line with 'y=lower y limit' and 'z=upper z limit'
%      	'10x' is the axis line with 'x=upper x limit' and 'y=lower y limit'
%      The 'x' character indicates the varying component. There may be
%      only one 'x'.
% #2 : a macro name. It will be empty if the line is NOT on the
% 		current surface. If will be non-empty if it IS on the current
% 		surface.
% 		To be more precise, If the line IS on the current surface, '#2' will be set to
% 		the character in '#1' which belongs to the second oriented
% 		surface axis.
%
% Result values are
% 		'0': the axis is NOT in the surface.
% 		'1': the axis is on the surface and the 'b' component of the
% 		surface 
% 	
% 		Example:
% 		\pgfplotspointonorientedsurfaceabsetupforsetz{\zmax}{1}
% 		\pgfplotspointonorientedsurfaceabsetupforyxz
% 		\pgfplotspointonorientedsurfaceabmatchaxisline{x01}{\result}
% 		-> \result will be '0' because 'y=0' in '{x01}
%
% 		\pgfplotspointonorientedsurfaceabsetupforsetx{\xmax}{1}
% 		\pgfplotspointonorientedsurfaceabsetupforyzx
% 		\pgfplotspointonorientedsurfaceabmatchaxisline{10x}{\result}
% 		-> \result will be 'x' because 'z=x' in '{10x}
\def\pgfplotspointonorientedsurfaceabmatchaxisline#1#2{%
}%

% Internal stream methods.
%
% Please overwrite 
% - \pgfplots@coord@stream@start@,
% - \pgfplots@coord@stream@end@ and 
% - \pgfplots@coord@stream@coord@
% if you implement streams.
%
% FIXME: REPLACE THIS HERE WITH METHODS OF THE VISUALIZATION FRAMEWORK
\newif\ifpgfplots@coord@stream@isfirst
\def\pgfplots@coord@stream@start{%
	\pgfplots@coord@stream@isfirsttrue
	\let\pgfplots@current@point@x=\pgfutil@empty
	\let\pgfplots@current@point@y=\pgfutil@empty
	\let\pgfplots@current@point@z=\pgfutil@empty
	\let\pgfplots@current@point@x@error=\pgfutil@empty
	\let\pgfplots@current@point@y@error=\pgfutil@empty
	\let\pgfplots@current@point@z@error=\pgfutil@empty
	\pgfplots@coord@stream@start@}%
\def\pgfplots@coord@stream@end{\pgfplots@coord@stream@end@}

% Will be invoked for every point coordinate.
%
% It invokes \pgfplots@coord@stream@coord@.
%
% Arguments:
% \pgfplots@current@point@[xyz]
% \pgfplots@current@point@[xyz]@error (if in argument list)
\def\pgfplots@coord@stream@coord{%
	\pgfplots@coord@stream@coord@%
	% FIXME : needs to be updated for 3D
	% FIXME : reduce \if's
	\ifpgfplots@coord@stream@isfirst
		\ifx\pgfplots@currentplot@firstcoord@x\pgfutil@empty
		\else
			\ifx\pgfplots@currentplot@firstcoord@y\pgfutil@empty
			\else
				\let\pgfplots@currentplot@firstcoord@x=\pgfplots@current@point@x
				\let\pgfplots@currentplot@firstcoord@y=\pgfplots@current@point@y
				\pgfplots@coord@stream@isfirstfalse
			\fi
		\fi
	\fi
	\ifx\pgfplots@current@point@x\pgfutil@empty
	\else
		\ifx\pgfplots@current@point@y\pgfutil@empty
		\else
			\let\pgfplots@currentplot@lastcoord@x=\pgfplots@current@point@x
			\let\pgfplots@currentplot@lastcoord@y=\pgfplots@current@point@y
		\fi
	\fi
}%

% Initialises 
% \pgfplots@coord@stream@start
% \pgfplots@coord@stream@coord
% \pgfplots@coord@stream@end
% such that a following coordinate stream is processed properly. The
% following coordinate stream may come from different input methods.
%
% Arguments:
% #1:  all options of \addplot[...] (the plot style)
% #2:  any trailing path commands after the 'plot' command as such,
%      for example \addplot plot coordinates {...} -- (0,0);
%      would yield #2 =' -- (0,0)'
%
% PRECONDITION:
% 	- needs to be called inside of \addplot.
%
\long\def\pgfplots@PREPARE@COORD@STREAM#1#2{%
	\ifpgfplots@curplot@threedim
		\global\pgfplots@threedimtrue
	\fi
	\def\pgfplots@coord@stream@start@{%
		\pgfplotsapplistXXnewempty
		\ifpgfplots@errorbars@enabled
			\pgfplots@streamerrorbar@recordto{\pgfplots@recordederrorbar}%
			\pgfplots@streamerrorbarstart
		\else
			\let\pgfplots@recordederrorbar=\pgfutil@empty
		\fi
		\ifpgfplots@stackedmode
			\pgfplots@stacked@beginplot
		\fi
		%
		%\let\pgfplots@coord@stream@recorded=\pgfutil@empty
		%
		\pgfplots@perpointmeta@usesfloattrue
		% %%%%%%%%%%%%%%
		%
		% Define \pgfplots@set@perpointmeta properly:
		\ifcase\pgfplots@perpointmeta@choice
			% disabled.
			\def\pgfplots@set@perpointmeta{%	
				\let\pgfplots@current@point@meta=\pgfutil@empty
			}%
		\or
			% point meta/x
			\def\pgfplots@set@perpointmeta{%	
				\let\pgfplots@current@point@meta=\pgfplots@current@point@x
			}%
			\ifpgfplots@xislinear
			\else	
				\pgfplots@perpointmeta@usesfloatfalse
			\fi
		\or
			% point meta/y
			\def\pgfplots@set@perpointmeta{%	
				\let\pgfplots@current@point@meta=\pgfplots@current@point@y
			}%
			\ifpgfplots@yislinear
			\else	
				\pgfplots@perpointmeta@usesfloatfalse
			\fi
		\or
			% point meta/z
			\def\pgfplots@set@perpointmeta{%	
				\let\pgfplots@current@point@meta=\pgfplots@current@point@z
			}%
			\ifpgfplots@zislinear
			\else	
				\pgfplots@perpointmeta@usesfloatfalse
			\fi
		\or
			% point meta/explicit : parse the information found
			% somewhere:
			\def\pgfplots@set@perpointmeta{%	
				\pgfmathfloatparsenumber{\pgfplots@current@point@meta}%
				\let\pgfplots@current@point@meta=\pgfmathresult
			}%
		\or
			% point meta/explicit symbolic : simply collect the
			% information, no math.
			\def\pgfplots@set@perpointmeta{}%
		\fi
		\ifnum\pgfplots@perpointmeta@choice=0
			\let\pgfplots@metamin=\pgfutil@empty
			\let\pgfplots@metamax=\pgfutil@empty
		\else
			\ifnum\pgfplots@perpointmeta@choice=5
				\let\pgfplots@metamin=\pgfutil@empty
				\let\pgfplots@metamax=\pgfutil@empty
			\else
				% We need to work with per point meta data.
				% So, also compute the data range on a per-stream basis!
				% These limits are important later.
				\ifpgfplots@perpointmeta@usesfloat
					\pgfmathfloatcreate{1}{1.0}{2147483645}%
					\let\pgfplots@invalidrange@metamin=\pgfmathresult
					\pgfmathfloatcreate{2}{1.0}{2147483645}%
					\let\pgfplots@invalidrange@metamax=\pgfmathresult
					\let\pgfplots@metamin=\pgfplots@invalidrange@metamin
					\let\pgfplots@metamax=\pgfplots@invalidrange@metamax
					\expandafter\def\expandafter\pgfplots@set@perpointmeta\expandafter{%
						\pgfplots@set@perpointmeta
						\pgfmathfloatmin@{\pgfplots@metamin}{\pgfplots@current@point@meta}%
						\let\pgfplots@metamin=\pgfmathresult
						\pgfmathfloatmax@{\pgfplots@metamax}{\pgfplots@current@point@meta}%
						\let\pgfplots@metamax=\pgfmathresult
					}%
				\else
					\def\pgfplots@invalidrange@xmin{16300}%
					\def\pgfplots@invalidrange@xmax{-16300}%
					\let\pgfplots@metamin=\pgfplots@invalidrange@metamin
					\let\pgfplots@metamax=\pgfplots@invalidrange@metamax
					\expandafter\def\expandafter\pgfplots@set@perpointmeta\expandafter{%
						\pgfplots@set@perpointmeta
						\pgfmathmin@{\pgfplots@metamin}{\pgfplots@current@point@meta}%
						\let\pgfplots@metamin=\pgfmathresult
						\pgfmathmax@{\pgfplots@metamax}{\pgfplots@current@point@meta}%
						\let\pgfplots@metamax=\pgfmathresult
					}%
				\fi
			\fi
		\fi
	}%
	\begingroup
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\let\E=\noexpand
	% Updates the current x and y limits for point (#1,#2).
	%
	% To eliminate all those case distinctions, it is created with
	% 'edef' and a lot of '\noexpand' calls here:
	%
	%
	% The point coordinates may be given in floating point format, see
	% below.
	%
	% Please note that if user specified limits are given, automatic
	% limits are only applied to points which fall into the user specified
	% clipping region.
	%
	% PRECONDITIONS:
	% - the input coordinates have been parsed correctly (floating point
	%   format for linear axis, log applied for logarithmic ones)
	%
	% Arguments:
	% \pgfplots@current@point@[xyz]
	\xdef\pgfplots@update@limits@for@one@point{%
%\E\tracingmacros=2\E\tracingcommands=2
%\E\pgfplots@message{Updating limits for (\E\pgfplots@current@point@x,\E\pgfplots@current@point@y) ...}%
		%
		% VIM SEARCH PATTERN: 
		%   [^E]\zs\\\ze[^E]
		% -> this finds '\' which is neither '\E' nor is it prefixed
		%  by 'E'.
		%
		%
		%
		\E\pgfplots@update@limits@for@one@point@ISCLIPPEDfalse
		% check whether we need to clip limits:
		\ifpgfplots@clip@limits
			\ifpgfplots@autocompute@xmin
			\else
				\ifpgfplots@xislinear
					\E\pgfmathfloatlessthan@{\E\pgfplots@current@point@x}{\E\pgfplots@xmin}%
					\E\ifpgfmathfloatcomparison
						\E\pgfplots@update@limits@for@one@point@ISCLIPPEDtrue
					\E\fi
				\else
					\E\pgfplotsmathlessthan{\E\pgfplots@current@point@x}{\E\pgfplots@xmin}%
					\E\ifpgfmathfloatcomparison
						\E\pgfplots@update@limits@for@one@point@ISCLIPPEDtrue
					\E\fi
				\fi
			\fi
			\ifpgfplots@autocompute@xmax
			\else
				\ifpgfplots@xislinear
					\E\pgfmathfloatlessthan@{\E\pgfplots@xmax}{\E\pgfplots@current@point@x}%
					\E\ifpgfmathfloatcomparison
						\E\pgfplots@update@limits@for@one@point@ISCLIPPEDtrue
					\E\fi
				\else
					\E\pgfplotsmathlessthan{\E\pgfplots@xmax}{\E\pgfplots@current@point@x}%
					\E\ifpgfmathfloatcomparison
						\E\pgfplots@update@limits@for@one@point@ISCLIPPEDtrue
					\E\fi
				\fi
			\fi
			\ifpgfplots@autocompute@ymin
			\else
				\ifpgfplots@yislinear
					\E\pgfmathfloatlessthan@{\E\pgfplots@current@point@y}{\E\pgfplots@ymin}%
					\E\ifpgfmathfloatcomparison
						\E\pgfplots@update@limits@for@one@point@ISCLIPPEDtrue
					\E\fi
				\else
					\E\pgfplotsmathlessthan{\E\pgfplots@current@point@y}{\E\pgfplots@ymin}%
					\E\ifpgfmathfloatcomparison
						\E\pgfplots@update@limits@for@one@point@ISCLIPPEDtrue
					\E\fi
				\fi
			\fi
			\ifpgfplots@autocompute@ymax
			\else
				\ifpgfplots@yislinear
					\E\pgfmathfloatlessthan@{\E\pgfplots@ymax}{\E\pgfplots@current@point@y}%
					\E\ifpgfmathfloatcomparison
						\E\pgfplots@update@limits@for@one@point@ISCLIPPEDtrue
					\E\fi
				\else
					\E\pgfplotsmathlessthan{\E\pgfplots@ymax}{\E\pgfplots@current@point@y}%
					\E\ifpgfmathfloatcomparison
						\E\pgfplots@update@limits@for@one@point@ISCLIPPEDtrue
					\E\fi
				\fi
			\fi
			\ifpgfplots@curplot@threedim
			\else
				\ifpgfplots@autocompute@zmin
				\else
					\ifpgfplots@zislinear
						\E\pgfmathfloatlessthan@{\E\pgfplots@current@point@z}{\E\pgfplots@zmin}%
						\E\ifpgfmathfloatcomparison
							\E\pgfplots@update@limits@for@one@point@ISCLIPPEDtrue
						\E\fi
					\else
						\E\pgfplotsmathlessthan{\E\pgfplots@current@point@z}{\E\pgfplots@zmin}%
						\E\ifpgfmathfloatcomparison
							\E\pgfplots@update@limits@for@one@point@ISCLIPPEDtrue
						\E\fi
					\fi
				\fi
				\ifpgfplots@autocompute@zmax
				\else
					\ifpgfplots@zislinear
						\E\pgfmathfloatlessthan@{\E\pgfplots@zmax}{\E\pgfplots@current@point@z}%
						\E\ifpgfmathfloatcomparison
							\E\pgfplots@update@limits@for@one@point@ISCLIPPEDtrue
						\E\fi
					\else
						\E\pgfplotsmathlessthan{\E\pgfplots@zmax}{\E\pgfplots@current@point@z}%
						\E\ifpgfmathfloatcomparison
							\E\pgfplots@update@limits@for@one@point@ISCLIPPEDtrue
						\E\fi
					\fi
				\fi
			\fi
		\fi
		%
		%
		%
		% Update limits:
		\E\ifpgfplots@update@limits@for@one@point@ISCLIPPED
		\E\else
			\ifpgfplots@autocompute@xmin
				\ifpgfplots@xislinear
					\E\pgfmathfloatmin@{\E\pgfplots@xmin}{\E\pgfplots@current@point@x}%
					\E\global\E\let\E\pgfplots@xmin=\E\pgfmathresult
				\else
					\E\pgfplotsmathmin{\E\pgfplots@xmin}{\E\pgfplots@current@point@x}%
					\E\global\E\let\E\pgfplots@xmin=\E\pgfmathresult
				\fi
			\fi
			\ifpgfplots@autocompute@xmax
				\ifpgfplots@xislinear
					\E\pgfmathfloatmax@{\E\pgfplots@xmax}{\E\pgfplots@current@point@x}%
					\E\global\E\let\E\pgfplots@xmax=\E\pgfmathresult
				\else
					\E\pgfplotsmathmax{\E\pgfplots@xmax}{\E\pgfplots@current@point@x}%
					\E\global\E\let\E\pgfplots@xmax=\E\pgfmathresult
				\fi
			\fi
			\ifpgfplots@autocompute@ymin
				\ifpgfplots@yislinear
					\E\pgfmathfloatmin@{\E\pgfplots@ymin}{\E\pgfplots@current@point@y}%
					\E\global\E\let\E\pgfplots@ymin=\E\pgfmathresult
				\else
					\E\pgfplotsmathmin{\E\pgfplots@ymin}{\E\pgfplots@current@point@y}%
					\E\global\E\let\E\pgfplots@ymin=\E\pgfmathresult
				\fi
			\fi
			\ifpgfplots@autocompute@ymax
				\ifpgfplots@yislinear
					\E\pgfmathfloatmax@{\E\pgfplots@ymax}{\E\pgfplots@current@point@y}%
					\E\global\E\let\E\pgfplots@ymax=\E\pgfmathresult
				\else
					\E\pgfplotsmathmax{\E\pgfplots@ymax}{\E\pgfplots@current@point@y}%
					\E\global\E\let\E\pgfplots@ymax=\E\pgfmathresult
				\fi
			\fi
			\ifpgfplots@curplot@threedim
				\ifpgfplots@autocompute@zmin
					\ifpgfplots@zislinear
						\E\pgfmathfloatmin@{\E\pgfplots@zmin}{\E\pgfplots@current@point@z}%
						\E\global\E\let\E\pgfplots@zmin=\E\pgfmathresult
					\else
						\E\pgfplotsmathmin{\E\pgfplots@zmin}{\E\pgfplots@current@point@z}%
						\E\global\E\let\E\pgfplots@zmin=\E\pgfmathresult
					\fi
				\fi
				\ifpgfplots@autocompute@zmax
					\ifpgfplots@zislinear
						\E\pgfmathfloatmax@{\E\pgfplots@zmax}{\E\pgfplots@current@point@z}%
						\E\global\E\let\E\pgfplots@zmax=\E\pgfmathresult
					\else
						\E\pgfplotsmathmax{\E\pgfplots@zmax}{\E\pgfplots@current@point@z}%
						\E\global\E\let\E\pgfplots@zmax=\E\pgfmathresult
					\fi
				\fi
			\fi
		\E\fi
		%
		% Compute data range:
		\ifpgfplots@autocompute@all@limits
			% the data range will be acquired simply from the axis
			% range, see below!
		\else
			% Attention: it is only done for linear axis!
			\ifpgfplots@xislinear
				\E\pgfmathfloatmin@{\E\pgfplots@data@xmin}{\E\pgfplots@current@point@x}%
				\E\global\E\let\E\pgfplots@data@xmin=\E\pgfmathresult
				\E\pgfmathfloatmax@{\E\pgfplots@data@xmax}{\E\pgfplots@current@point@x}%
				\E\global\E\let\E\pgfplots@data@xmax=\E\pgfmathresult
			\fi
			\ifpgfplots@yislinear
				\E\pgfmathfloatmin@{\E\pgfplots@data@ymin}{\E\pgfplots@current@point@y}%
				\E\global\E\let\E\pgfplots@data@ymin=\E\pgfmathresult
				\E\pgfmathfloatmax@{\E\pgfplots@data@ymax}{\E\pgfplots@current@point@y}%
				\E\global\E\let\E\pgfplots@data@ymax=\E\pgfmathresult
			\fi
			\ifpgfplots@curplot@threedim
				\ifpgfplots@zislinear
					\E\pgfmathfloatmin@{\E\pgfplots@data@zmin}{\E\pgfplots@current@point@z}%
					\E\global\E\let\E\pgfplots@data@zmin=\E\pgfmathresult
					\E\pgfmathfloatmax@{\E\pgfplots@data@zmax}{\E\pgfplots@current@point@z}%
					\E\global\E\let\E\pgfplots@data@zmax=\E\pgfmathresult
				\fi
			\fi
		\fi
%\E\pgfplots@message{Updated limits: (\E\pgfplots@xmin,\E\pgfplots@ymin) rectangle  (\E\pgfplots@xmax,\E\pgfplots@ymax).}%
%\E\tracingmacros=0\E\tracingcommands=0
	}%
%\message{Assembled update-limits macro to {\meaning\pgfplots@update@limits@for@one@point}}%
	\ifpgfplots@bb@isactive
	\else
		\global\let\pgfplots@update@limits@for@one@point=\relax
	\fi
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%
	% This here is the MAIN code of \pgfplots@process@one@point .
	% It is inserted below into the right, into one of two prepared
	% places.
	\def\pgfplots@loc@TMPa{%
		\ifpgfplots@apply@datatrafo
			\ifpgfplots@datascaletrafo@initialised
				% apply data transformation directly.
				\ifpgfplots@apply@datatrafo@x
					\E\pgfplots@datascaletrafo@x\E\pgfplots@current@point@x
					\E\let\E\pgfplots@current@point@x=\E\pgfmathresult
				\fi
				\ifpgfplots@apply@datatrafo@y
					\E\pgfplots@datascaletrafo@y\E\pgfplots@current@point@y
					\E\let\E\pgfplots@current@point@y=\E\pgfmathresult
				\fi
				\ifpgfplots@curplot@threedim
					\ifpgfplots@apply@datatrafo@z
						\E\pgfplots@datascaletrafo@z\E\pgfplots@current@point@z
						\E\let\E\pgfplots@current@point@z=\E\pgfmathresult
					\fi
				\fi
			\fi
		\fi
		% All following routines (limit updating/stacking/error
		% bars) will use float numerics if necessary (controlled
		% by ifs).
		\ifpgfplots@stackedmode
			\E\pgfplots@stacked@preparepoint@inmacro%
			\ifpgfplots@datascaletrafo@initialised% is also true if there is no scale trafo.
				\E\pgfplots@stacked@finishpoint
			\else
				% the finishpoint routine will be invoked at
				% \endaxis.
			\fi
		\fi
		%
		% Prepare \pgfplots@current@point@meta (see the preparation
		% routine above):
		\E\pgfplots@set@perpointmeta
		%
		% update also axis / data limits:
		% Arguments: \pgfplots@current@point@[xy]
		\E\pgfplots@update@limits@for@one@point
		\ifpgfplots@errorbars@enabled
			% This thing gets the 'current@point@...' context,
			% that means 
			% \pgfplots@current@point@[xy]
			% \pgfplots@current@point@[xy]@error
			% \pgfplots@current@point@[xy]@unfiltered
			\E\pgfplots@process@errorbar@for%
		\fi
		%
		% Store normalized point for list:
		% We need
		% xi,yi,zi,mi;
		% where zi and mi may be empty. mi is the per-point meta
		% information. It is used for per-coordinate marker
		% modifications (like colormaps for scatter plots).
		\E\edef\E\pgfplots@loc@TMPa{\E\pgfplots@current@point@x,\E\pgfplots@current@point@y,\E\pgfplots@current@point@z,\E\pgfplots@current@point@meta;}%
		\E\expandafter\E\pgfplotsapplistXXpushback\E\expandafter{\E\pgfplots@loc@TMPa}%
		%
		\ifpgfplots@collect@firstplot@astick
			\ifnum\pgfplots@numplots=0
				\E\ifx\E\pgfplots@firstplot@coords@x\E\pgfutil@empty
					\E\t@pgfplots@tokc=\E\expandafter{}%
				\E\else
					\E\t@pgfplots@tokc=\E\expandafter{\E\pgfplots@firstplot@coords@x,}%
				\E\fi
				\E\edef\E\pgfplots@firstplot@coords@x{\E\the\E\t@pgfplots@tokc\E\pgfplots@current@point@x}%
				\E\ifx\E\pgfplots@firstplot@coords@y\E\pgfutil@empty
					\E\t@pgfplots@tokc=\E\expandafter{}%
				\E\else
					\E\t@pgfplots@tokc=\E\expandafter{\E\pgfplots@firstplot@coords@y,}%
				\E\fi
				\E\edef\E\pgfplots@firstplot@coords@y{\E\the\E\t@pgfplots@tokc\E\pgfplots@current@point@y}%
				%
				\ifpgfplots@curplot@threedim
					\E\ifx\E\pgfplots@firstplot@coords@z\E\pgfutil@empty
						\E\t@pgfplots@tokc=\E\expandafter{}%
					\E\else
						\E\t@pgfplots@tokc=\E\expandafter{\E\pgfplots@firstplot@coords@z,}%
					\E\fi
					\E\edef\E\pgfplots@firstplot@coords@z{\E\the\E\t@pgfplots@tokc\E\pgfplots@current@point@z}%
				\fi
			\fi
		\fi
	}%
	% The following code assembles the command which is executed for
	% each coordinate.
	%
	% To eliminate all those case distinctions, it is created with
	% 'edef' and a lot of '\noexpand' calls here:
	%
	% Arguments:
	% \pgfplots@current@point@[xyz]
	% \pgfplots@current@point@[xyz]@error (if in argument list)
	\xdef\pgfplots@process@one@point{%
		% These things are necessary for error bars:
		\E\let\E\pgfplots@current@point@x@unfiltered=\E\pgfplots@current@point@x
		\E\let\E\pgfplots@current@point@y@unfiltered=\E\pgfplots@current@point@y
		\ifpgfplots@curplot@threedim
		\E\let\E\pgfplots@current@point@z@unfiltered=\E\pgfplots@current@point@z
		\fi
		%
		\E\pgfplots@prepare@xcoord{\E\pgfplots@current@point@x}%
		\E\expandafter\E\pgfplots@invoke@filter\E\expandafter{\E\pgfmathresult}{x}%
		\E\let\E\pgfplots@current@point@x=\E\pgfmathresult
		%
		\E\pgfplots@prepare@ycoord{\E\pgfplots@current@point@y}%
		\E\expandafter\E\pgfplots@invoke@filter\E\expandafter{\E\pgfmathresult}{y}%
		\E\let\E\pgfplots@current@point@y=\E\pgfmathresult
		%
		\ifpgfplots@xislinear
			\E\ifx\E\pgfplots@current@point@x\E\pgfutil@empty
			\E\else
				\E\pgfmathfloatparsenumber{\E\pgfplots@current@point@x}%
				\E\expandafter\E\pgfmathfloat@decompose@F\E\pgfmathresult\E\relax\E\c@pgf@counta
				\E\ifnum\E\c@pgf@counta>2
					\E\let\E\pgfplots@current@point@x=\E\pgfutil@empty
				\E\else
					\E\let\E\pgfplots@current@point@x=\E\pgfmathresult
				\E\fi
			\E\fi
		\fi
		%
		\ifpgfplots@yislinear
			\E\ifx\E\pgfplots@current@point@y\E\pgfutil@empty
			\E\else
				\E\pgfmathfloatparsenumber{\E\pgfplots@current@point@y}%
				\E\expandafter\E\pgfmathfloat@decompose@F\E\pgfmathresult\E\relax\E\c@pgf@counta
				\E\ifnum\E\c@pgf@counta>2
					\E\let\E\pgfplots@current@point@y=\E\pgfutil@empty
				\E\else
					\E\let\E\pgfplots@current@point@y=\E\pgfmathresult
				\E\fi
			\E\fi
		\fi
		%
		\ifpgfplots@curplot@threedim
			\E\let\E\pgfplots@current@point@z@unfiltered=\E\pgfplots@current@point@z
			\E\pgfplots@prepare@zcoord{\E\pgfplots@current@point@z}%
			\E\expandafter\E\pgfplots@invoke@filter\E\expandafter{\E\pgfmathresult}{z}%
			\E\let\E\pgfplots@current@point@z=\E\pgfmathresult
			%
			\ifpgfplots@zislinear
				\E\ifx\E\pgfplots@current@point@z\E\pgfutil@empty
				\E\else
					\E\pgfmathfloatparsenumber{\E\pgfplots@current@point@z}%
					\E\expandafter\E\pgfmathfloat@decompose@F\E\pgfmathresult\E\relax\E\c@pgf@counta
					\E\ifnum\E\c@pgf@counta>2
						\E\let\E\pgfplots@current@point@z=\E\pgfutil@empty
					\E\else
						\E\let\E\pgfplots@current@point@z=\E\pgfmathresult
					\E\fi
				\E\fi
			\fi
		\fi
		%
		\E\ifx\E\pgfplots@current@point@x\E\pgfutil@empty
			\ifpgfplots@warn@for@filter@discards
				\E\pgfplots@message{NOTE: coordinate (\E\pgfplots@current@point@x@unfiltered,\E\pgfplots@current@point@y@unfiltered\ifpgfplots@curplot@threedim,\E\pgfplots@current@point@z@unfiltered\fi) has been dropped because of the x-coordinate filter.}%
			\fi
		\E\else
			\E\ifx\E\pgfplots@current@point@y\E\pgfutil@empty
				\ifpgfplots@warn@for@filter@discards
					\E\pgfplots@message{NOTE: coordinate (\E\pgfplots@current@point@x@unfiltered,\E\pgfplots@current@point@y@unfiltered\ifpgfplots@curplot@threedim,\E\pgfplots@current@point@z@unfiltered\fi) has been dropped because of the y-coordinate filter.}%
				\fi
			\E\else
				\ifpgfplots@curplot@threedim
					\E\ifx\E\pgfplots@current@point@z\E\pgfutil@empty
						\ifpgfplots@warn@for@filter@discards
							\E\pgfplots@message{NOTE: coordinate (\E\pgfplots@current@point@x@unfiltered,\E\pgfplots@current@point@y@unfiltered,\E\pgfplots@current@point@z@unfiltered) has been dropped because of the z-coordinate filter.}%
						\fi
					\E\else
						% insert the main 3d code here:
						\pgfplots@loc@TMPa
					\E\fi
				\else
					% insert the main 2d code here:
					\pgfplots@loc@TMPa
				\fi
			\E\fi
		\E\fi
		%
		% increase \pgfplots@current@point@coordindex:
		\E\begingroup
		\E\c@pgf@counta=\E\pgfplots@current@point@coordindex
		\E\advance\E\c@pgf@counta by1\E\relax
		\E\edef\E\pgfmathresult{\E\the\E\c@pgf@counta}%
		\E\pgfmath@smuggleone\E\pgfmathresult
		\E\endgroup
		\E\let\E\pgfplots@current@point@coordindex=\E\pgfmathresult
	}%
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\endgroup
%\message{Prepared macro \string\pgfplots@update@limits@for@one@point: {\meaning\pgfplots@update@limits@for@one@point}}%
%\message{Prepared macro \string\pgfplots@process@one@point: {\meaning\pgfplots@process@one@point}}%
	\let\pgfplots@coord@stream@coord@=\pgfplots@process@one@point
	%
	\def\pgfplots@coord@stream@end@{%
		\ifpgfplots@autocompute@all@limits
			\global\let\pgfplots@data@xmin=\pgfplots@xmin
			\global\let\pgfplots@data@xmax=\pgfplots@xmax
			\global\let\pgfplots@data@ymin=\pgfplots@ymin
			\global\let\pgfplots@data@ymax=\pgfplots@ymax
			\global\let\pgfplots@data@zmin=\pgfplots@zmin
			\global\let\pgfplots@data@zmax=\pgfplots@zmax
		\fi
		\ifpgfplots@errorbars@enabled
			\pgfplots@streamerrorbarend
		\fi
		\ifpgfplots@coord@stream@isfirst
			\pgfplots@warning{Empty plot silently dropped.}%
		\else
			\ifpgfplots@stackedmode
				\pgfplots@stacked@endplot
			\fi
			% Idea: use
			%   \scope[plot specification]
			%   <any paths for error bars>
			%   \endscope
			%   \draw plot coordinates {...};
			% to share plot specifications between error bars and plot
			% coordinates. Unfortunately, it is NOT sufficient to use
			% \tikzset{#1}
			\edef\pgfplots@addplot@preoptionsTMP{/pgfplots/every axis plot,/pgfplots/every axis plot no \the\pgfplots@numplots/.try}%
			\expandafter\pgfplots@rememberplotspec\expandafter{\pgfplots@addplot@preoptionsTMP,#1,/pgfplots/every axis plot post}%
			% warning: rememberplotspec calls list macros which
			% overwrite \t@pgfplots@toka
			\t@pgfplots@toka=\expandafter{\pgfplots@addplot@preoptionsTMP,#1,/pgfplots/every axis plot post}%
			\xdef\pgfplots@last@plot@style{\the\t@pgfplots@toka}% store it for \label commands.
			% ATTENTION: do NOT call list macros from here on!
			%
			\ifpgfplots@datascaletrafo@initialised
				\pgfplots@addplot@get@named@startendpoints@command\pgfplots@loc@TMPa
				\t@pgfplots@tokc=\expandafter{\pgfplots@loc@TMPa}%
			\else
				\t@pgfplots@tokc={}%
			\fi
			\ifx\pgfplots@recordederrorbar\pgfutil@empty
				\let\pgfplots@loc@TMPb=\pgfutil@empty%
			\else
				\t@pgfplots@tokb=\expandafter{\pgfplots@recordederrorbar}%
				\def\pgfplots@loc@TMPb{%
					\noexpand\pgfplots@errorbars@finishwithstyleoptions[current plot style]{\the\t@pgfplots@tokb}%
				}%
			\fi
			% assembe a \pgfplots@addplot@enqueue@coords command ...
			% BEGIN HERE ...
			% vvvvvvvvvv
			\xdef\pgfplots@glob@TMPa{%
				\noexpand\pgfplots@addplot@enqueue@coords
				{% precommand(s):
					\expandafter\noexpand\csname pgfplots@curplot@threedim\ifpgfplots@curplot@threedim true\else false\fi\endcsname
					\noexpand\def\noexpand\plotnum{\the\pgfplots@numplots}%
					\noexpand\pgfplots@initzerolevelhandler
					\the\t@pgfplots@tokc% named start/end points (if already available)
					\noexpand\pgfkeysdef{/tikz/current plot style}{\noexpand\pgfkeysalso{\the\t@pgfplots@toka}}%
					\pgfplots@loc@TMPb% error bar commands
					% per-point meta data ranges:
					\noexpand\def\noexpand\pgfplots@metamin{\pgfplots@metamin}%
					\noexpand\def\noexpand\pgfplots@metamax{\pgfplots@metamax}%
					\ifpgfplots@perpointmeta@usesfloat
						\noexpand\pgfplots@perpointmeta@usesfloattrue
					\else
						\noexpand\pgfplots@perpointmeta@usesfloatfalse
					\fi
					\noexpand\def\noexpand\pgfplots@perpointmeta@choice{\pgfplots@perpointmeta@choice}%
					%\noexpand\pgfplots@perpointmeta@preparetrafo
				}%
				{% draw command:
					\noexpand\draw%
				}%
			}%
			\pgfplotsapplistXXlet\pgfplots@coord@stream@recorded
			\pgfplotsapplistXXclear
			\t@pgfplots@tokc=\expandafter{\pgfplots@coord@stream@recorded}%
			\t@pgfplots@tokb={#2;}%
			\t@pgfplots@toka=\expandafter{\pgfplots@glob@TMPa}%
			\xdef\pgfplots@glob@TMPa{%
				\the\t@pgfplots@toka
				{% coordinates which need to be processed in \endaxis:
					normalized coordinates {\the\t@pgfplots@tokc}\the\t@pgfplots@tokb
				}%
				{% postcommand
				}%
			}%
			\pgfplots@glob@TMPa
			%^^^^^^^^^^^^ ... END of \pgfplots@addplot@enqueue@coords HERE
			\pgfplots@end@plot
		\fi
	}%
}%

% Defines the linear transformation macro \pgfplots@perpointmeta@trafo,
%
% phi : [meta_min,meta,max] -> [0,10^k]
%
% which operates on the per-point meta data (if any).
% The trafo will be skipped if there is no such data.
%
% The trafo is expected to prepare meta information before it is used
% as input to \pgfplotscolormapfind. Thus, the 10^k is chosen to be 
% the same as \pgfplotscolormaprange (which is 1000 per default).
%
% If there is now data range (for example because meta information is
% not available or is not of numeric type), the trafo will simply
% copy the input argument symbolically.
\def\pgfplots@perpointmeta@preparetrafo{%
	\ifx\pgfplots@metamax\pgfutil@empty
		\def\pgfplots@perpointmeta@trafo##1{\def\pgfmathresult{##1}}%
		\def\pgfplots@perpointmeta@traforange{0:0}%
	\else
		% The transformation is
		%
		% phi(m) = ( m- meta_min) * 1000/ (meta_max-meta_min).
		%
		% -> precompute the scaling factor!
		\ifpgfplots@perpointmeta@usesfloat
			\edef\pgfplots@loc@TMPa{\pgfplotscolormaprange}%
			\ifnum\pgfplots@loc@TMPa=1000
			\else
				\pgfplots@error{LOGIC ERROR: sorry, I have hard-coded the assumption \string\pgfplotscolormaprange = 1000, but now it is \pgfplots@loc@TMPa.}%
			\fi
			\pgfmathfloatsubtract@{\pgfplots@metamax}{\pgfplots@metamin}%
			\let\pgfplots@loc@TMPa=\pgfmathresult
			\pgfmathfloatcreate{1}{1.0}{3}%
			\expandafter\pgfmathfloatdivide@\expandafter{\pgfmathresult}{\pgfplots@loc@TMPa}%
			\let\pgfplots@perpointmeta@trafo@factor=\pgfmathresult
			%
			% Now, setup the trafo as such.
			% It assigns \pgfmathresult (in fixed point).
			\def\pgfplots@perpointmeta@trafo##1{%
				\pgfmathfloatsubtract@{##1}{\pgfplots@metamin}%
				\expandafter\pgfmathfloatmultiply@\expandafter{\pgfmathresult}{\pgfplots@perpointmeta@trafo@factor}%
				\expandafter\pgfmathfloattofixed@\expandafter{\pgfmathresult}%
			}%
			% Expands to the transformation range as 'a:b':
			\def\pgfplots@perpointmeta@traforange{0:1000}%
		\else
			\pgfplots@error{NOT YET IMPLEMENTED: sorry, per-point meta information is currently not processed for log plots.}%
		\fi
	\fi
}%

% A looping method which applies
% \pgfplots@coord@stream@start
% for each coordinate '(x,y)'  or '(x,y) +- (ex,ey)',
%    assign \pgfplots@current@point@[xyz]
%    assign \pgfplots@current@point@[xyz]@error (if in argument list)
%    assign \pgfplots@current@point@meta
%    call \pgfplots@coord@stream@coord
% \pgfplots@coord@stream@end
%
% #1 a sequence of coordinates of the form 
%   '(x,y)' or '(x,y,z)'
%   or
%   '(x,y[,z]) +- (ex,ey)'
%   or
%   '(x,y) [meta]'
%   or
%   '(x,y) +- (ex,ey) [meta]'
%   separated by white-space.
%
% The per-point meta is not implemented yet.
\long\def\pgfplots@coord@stream@foreach#1{%
	\pgfplots@coord@stream@start
	\let\pgfplots@current@point@meta=\pgfutil@empty
	\pgfplots@foreach@plot@coord@ITERATE#1\pgfplots@EOI%
	\pgfplots@coord@stream@end
}%

% A looping command to loop through plot coordinates.
% For every point, #1{X}{Y} will be invoked.
%
% No scoping is used during this operation, so you can access outer
% variables.
\def\pgfplots@foreach@plot@coord@ITERATE{%
	\pgfutil@ifnextchar\pgfplots@EOI{%
		\pgfplots@foreach@plot@coord@FINISH%
	}{%
		\pgfplots@foreach@plot@coord@NEXT%
	}%
}
\def\pgfplots@foreach@plot@coord@NEXT(#1,#2){%
	\def\pgfplots@current@point@x{#1}%
	\def\pgfplots@current@point@y{#2}%
	\pgfutil@ifnextchar+{%
		\pgfplots@foreach@plot@coord@NEXT@WITH@ERRORRANGE%
	}{%
		\let\pgfplots@current@point@x@error=\pgfutil@empty
		\let\pgfplots@current@point@y@error=\pgfutil@empty
		\pgfutil@ifnextchar[{%
			\pgfplots@foreach@plot@coord@NEXT@meta
		}{%
			\let\pgfplots@current@point@meta=\pgfutil@empty
			\pgfplots@coord@stream@coord
			\pgfplots@foreach@plot@coord@ITERATE
		}%
	}%
}
\def\pgfplots@foreach@plot@coord@NEXT@meta[#1]{%
	\def\pgfplots@current@point@meta{#1}%
	\pgfplots@coord@stream@coord
	\pgfplots@foreach@plot@coord@ITERATE
}%
% processing something like '(x,y) +- (error_x,error_y)'
\def\pgfplots@foreach@plot@coord@NEXT@WITH@ERRORRANGE+-#1({%
	\pgfplots@foreach@plot@coord@NEXT@WITH@ERRORRANGE@%
}
\def\pgfplots@foreach@plot@coord@NEXT@WITH@ERRORRANGE@#1,#2){%
	\def\pgfplots@current@point@x@error{#1}%
	\def\pgfplots@current@point@y@error{#2}%
	\pgfplots@coord@stream@coord
	\pgfplots@foreach@plot@coord@ITERATE
}
\def\pgfplots@foreach@plot@coord@FINISH\pgfplots@EOI{}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5
% The same for three dim coords:
\long\def\pgfplots@coord@stream@foreach@threedim#1{%
	\pgfplots@coord@stream@start
	\let\pgfplots@current@point@meta=\pgfutil@empty
	\pgfplots@foreach@plot@coord@threedim@ITERATE#1\pgfplots@EOI%
	\pgfplots@coord@stream@end
}%
\def\pgfplots@foreach@plot@coord@threedim@ITERATE{%
	\pgfutil@ifnextchar\pgfplots@EOI{%
		\pgfplots@foreach@plot@coord@FINISH%
	}{%
		\pgfplots@foreach@plot@coord@threedim@NEXT%
	}%
}
\def\pgfplots@foreach@plot@coord@threedim@NEXT(#1,#2,#3){%
	\def\pgfplots@current@point@x{#1}%
	\def\pgfplots@current@point@y{#2}%
	\def\pgfplots@current@point@z{#3}%
	\pgfutil@ifnextchar+{%
		\pgfplots@foreach@plot@coord@threedim@NEXT@WITH@ERRORRANGE%
	}{%
		\let\pgfplots@current@point@x@error=\pgfutil@empty
		\let\pgfplots@current@point@y@error=\pgfutil@empty
		\let\pgfplots@current@point@z@error=\pgfutil@empty
		\pgfutil@ifnextchar[{%
			\pgfplots@foreach@plot@coord@threedim@NEXT@meta
		}{%
			\let\pgfplots@current@point@meta=\pgfutil@empty
			\pgfplots@coord@stream@coord
			\pgfplots@foreach@plot@coord@threedim@ITERATE
		}%
	}%
}
\def\pgfplots@foreach@plot@coord@threedim@NEXT@meta[#1]{%
	\def\pgfplots@current@point@meta{#1}%
	\pgfplots@coord@stream@coord
	\pgfplots@foreach@plot@coord@threedim@ITERATE
}%
% processing something like '(x,y) +- (error_x,error_y)'
\def\pgfplots@foreach@plot@coord@threedim@NEXT@WITH@ERRORRANGE+-#1({%
	\pgfplots@foreach@plot@coord@threedim@NEXT@WITH@ERRORRANGE@%
}
\def\pgfplots@foreach@plot@coord@threedim@NEXT@WITH@ERRORRANGE@#1,#2,#3){%
	\def\pgfplots@current@point@x@error{#1}%
	\def\pgfplots@current@point@y@error{#2}%
	\def\pgfplots@current@point@z@error{#3}%
	\pgfplots@coord@stream@coord
	\pgfplots@foreach@plot@coord@threedim@ITERATE
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5
%
% The same in normalized coordinates of the form
%  x1,y1,z1,m1;x2,y2,z2,m2;...;xN,yN,zN,mN;
% if the plot is not threedim, zi is empty.
%
% The mi are Meta Values associated to point coordinates. They are
% usually empty, but can be used to realize per-point marker
% modifications (scatter plots, especially for colormaps).
\long\def\pgfplots@coord@stream@foreach@NORMALIZED#1{%
	\pgfplots@coord@stream@start
	\let\pgfplots@current@point@x@error=\pgfutil@empty
	\let\pgfplots@current@point@y@error=\pgfutil@empty
	\let\pgfplots@current@point@z@error=\pgfutil@empty
	\pgfplots@foreach@plot@coord@NORMALIZED@ITERATE#1\pgfplots@EOI
	\pgfplots@coord@stream@end
}%

% A looping command to loop through plot coordinates.
% For every point, #1{X}{Y} will be invoked.
%
% No scoping is used during this operation, so you can access outer
% variables.
\def\pgfplots@foreach@plot@coord@NORMALIZED@ITERATE{%
	\pgfutil@ifnextchar\pgfplots@EOI{%
		\pgfplots@foreach@plot@coord@FINISH%
	}{%
		\pgfplots@foreach@plot@coord@NORMALIZED@NEXT%
	}%
}
\def\pgfplots@foreach@plot@coord@NORMALIZED@NEXT#1,#2,#3,#4;{%
	\def\pgfplots@current@point@x{#1}%
	\def\pgfplots@current@point@y{#2}%
	\def\pgfplots@current@point@z{#3}%
	\def\pgfplots@current@point@meta{#4}%
	\pgfplots@coord@stream@coord
	\pgfplots@foreach@plot@coord@NORMALIZED@ITERATE
}


\newif\ifpgfplots@curplot@threedim

% The main interface to draw a plot into an axis.
%
% Usage:
% \addplot 
% 	plot coordinates {
% 		(0,0)
% 		(1,1)
% 	};
% 
% or
%
% \addplot[color=blue,mark=*]
% 	plot coordinates {
% 		(0,0)
% 		(1,1)
% 	};
%
% or one of the other input types.
% 
% The first syntax will use the next plot specification in the list
% \autoplotspeclist
% and the first will use blue color and * markers. 
%
% \addplot [<style options>]  plot[<behavior options>]  <input type and args> <post plot path> ;
% \addplot3[<style options>]  plot[<behavior options>]  <input type and args> <post plot path> ;
% 
%
% The linespec. will be used in the legend.
%
% Low-level implementation:
%
% \pgfplots@addplot 
% \pgfplots@addplotimpl
% \pgfplots@start@plot@with@behavioroptions <--- \begingroup
% ...
% ... remember options GLOBALLY
% ... update limits GLOBALLY
% ... \pgfplots@addplot@enqueue@coords GLOBALLY
% ...
% \pgfplots@end@plot <--- \endgroup
\def\pgfplots@addplot{%
	\pgfutil@ifnextchar3{%
		\pgfplots@curplot@threedimtrue
		\pgfplots@addplot@three
	}{%
		\pgfplots@curplot@threedimfalse
		\pgfplots@addplot@
	}%
}
\def\pgfplots@addplot@three3{\pgfplots@addplot@}%
\def\pgfplots@addplot@{%
	\pgfutil@ifnextchar+{%
		\pgfplots@getautoplotspec into\nextplotspec
		\pgfplots@addplotimplAPPEND
	}{%
		\pgfutil@ifnextchar[{%
			\pgfplots@addplotimpl%
		}{%
			\pgfplots@getautoplotspec into\nextplotspec
			% the space after ']' is required here:
			% FIXME: 
			% - \addplot[]plot coordinates is NOT allowed!?
			\expandafter\pgfplots@addplotimpl\expandafter[\nextplotspec]%
		}%
	}%
}

\long\def\pgfplots@addplotimplAPPEND+[{%
	\expandafter\pgfplots@addplotimpl\expandafter[\nextplotspec,
}

\long\def\pgfplots@addplotimpl[#1]{%
	\pgfutil@ifnextchar p{%
		\pgfplots@addplotimpl@plot{#1}%
	}{%
		\pgfplots@addplotimpl@plot{#1}plot
	}%
}

\def\pgfplots@addplotimpl@plot#1plot{%
	\pgfutil@ifnextchar[{%
		\pgfplots@addplotimpl@plot@withoptions{#1}%
	}{%
		\pgfplots@addplotimpl@plot@withoptions{#1}[]%
	}%
}

\def\pgfplots@addplotimpl@plot@withoptions#1[#2]{
	\pgfplots@start@plot@with@behavioroptions{#2}%
	\pgfutil@ifnextchar c{%
		\pgfplots@addplotimpl@coordinates{#1}plot 
	}{%
		\pgfutil@ifnextchar f{%
			\pgfplots@addplotimpl@f{#1}%
		}{%
			\pgfutil@ifnextchar t{%
				\pgfplots@addplotimpl@table{#1}%
			}{%
				\pgfutil@ifnextchar ({%
					\pgfplots@addplotimpl@expression{#1}%
				}{%
					\pgfplots@error{Sorry, the supplied plot command is unknown or unsupported by pgfplots! Ignoring it.}%
					\pgfplots@gobble@until@semicolon
				}%
			}%
		}%
	}%
}

\def\pgfplots@gobble@until@semicolon#1;{}

% Currently, plot expression is really inefficient:
%
% 1. it invokes the math parser to get all coordinates. Ok, that's
% what one expects.
%
% 2. It collects the result into one large list instead of calling
% pgfplots' stream methods. That's because \foreach encapsulates its
% code in at least one TeX-group.
%
% 3. It processes the collected list; applying any floating point
% parser routines - it does NOT know that any numbers are already in
% TeX-precision!
%
\long\def\pgfplots@addplotimpl@expression#1(#2,#3)#4;{%
	\pgfplots@PREPARE@COORD@STREAM{#1}{#4}%
	%
	\pgfplots@gettikzinternal@keyval{variable}{tikz@plot@var}{\x}%
	\pgfplots@gettikzinternal@keyval{samples at}{tikz@plot@samplesat}{-5,-4.6,...,5}%
	%
	\ifpgfplots@curplot@threedim
		\def\pgfplots@addplotimpl@expression@split@yz##1,##2\pgfplots@EOI{%
			\def\pgfplots@addplotimpl@expression@yEXPR{##1}%
			\def\pgfplots@addplotimpl@expression@zEXPR{##2}%
		}%
		\pgfplots@addplotimpl@expression@split@yz#3\pgfplots@EOI%
	\else
		\def\pgfplots@addplotimpl@expression@yEXPR{#3}%
		\def\pgfplots@current@point@z{}%
	\fi
	%
	\edef\pgfplots@plot@data{\noexpand\foreach\expandafter\noexpand\tikz@plot@var in {\tikz@plot@samplesat}}%
	\pgfplotsapplistXXglobalnewempty
	\pgfplots@plot@data{%
		\pgfmathparse{#2}%
		\let\pgfplots@current@point@x=\pgfmathresult
		\pgfmathparse{\pgfplots@addplotimpl@expression@yEXPR}%
		\let\pgfplots@current@point@y=\pgfmathresult
		\ifpgfplots@curplot@threedim
			\pgfmathparse{\pgfplots@addplotimpl@expression@zEXPR}%
			\let\pgfplots@current@point@z=\pgfmathresult
		\fi
		\edef\pgfplots@loc@TMPa{\pgfplots@current@point@x,\pgfplots@current@point@y,\pgfplots@current@point@z,;}%
		\expandafter\pgfplotsapplistXXglobalpushback\expandafter{\pgfplots@loc@TMPa}%
	}%
	\pgfplotsapplistXXgloballet\pgfplots@loc@TMPa
	\pgfplotsapplistXXglobalclear
	% Process the normalized coordinate stream. This invoked the same
	% streaming methods as the unnormalized stream, only the format is
	% slightly different.
	\expandafter\pgfplots@coord@stream@foreach@NORMALIZED\expandafter{\pgfplots@loc@TMPa}%
}%

\def\pgfplots@addplotimpl@f#1f{%
	\pgfutil@ifnextchar i{\pgfplots@addplotimpl@file{#1}}{\pgfplots@addplotimpl@function{#1}}%
}%

\let\pgfplots@backupof@pgfplotxyfile=\pgfplotxyfile

% the following code 
% results finally in
%
% set format "%.7e";; set samples <...>; plot ...
%
% The windows port of gnuplot doesn't run without the second semicolon
% - for whatever reason.
{
  \catcode`\%=12
  \catcode`\"=12
  \xdef\pgfplots@gnuplot@format{set format "%.7e";}
}

% \addplot[<style options>]
% 	plot[<behavior opts>] 
% 	function[<further behavior opts>]
% 	{gnuplot code} 
% 	#3;
% #1: args of \addplot[...]
% #2: gnuplot code to generate coordinates
% #3: trailing path commands until ';'
\def\pgfplots@addplotimpl@function#1unction{%
	\pgfutil@ifnextchar[{%
		\pgfplots@addplotimpl@function@opt{#1}%
	}{%
		\pgfplots@addplotimpl@function@opt{#1}[]%
	}%
}%
\def\pgfplots@addplotimpl@function@opt#1[#2]#3#4;{%
	\def\pgfplots@loc@TMPa{#2}%
	\ifx\pgfplots@loc@TMPa\pgfutil@empty
	\else
		\expandafter\def\expandafter\pgfplots@addplot@nonlegend@options\expandafter{%
			\pgfplots@addplot@nonlegend@options
			#2}%
		\pgfplotsset{#2}%
	\fi
	\pgfplots@gettikzinternal@keyval{prefix}{tikz@plot@prefix}{\jobname.}%
	\pgfplots@gettikzinternal@keyval{id}{tikz@plot@id}{pgf-plot}%
	\pgfplots@gettikzinternal@keyval{samples}{tikz@plot@samples}{25}%
	\pgfplots@gettikzinternal@keyval{domain}{tikz@plot@domain}{-5:5}%
	\pgfplots@gettikzinternal@keyval{raw gnuplot}{iftikz@plot@raw@gnuplot}{\iffalse}%
	\pgfplots@gettikzinternal@keyval{parametric}{iftikz@plot@parametric}{\iffalse}%
	\pgfkeysgetvalue{/pgfplots/y domain}{\pgfplots@plot@ydomain}%
	%
	\def\pgfplots@plot@filename{\tikz@plot@prefix\tikz@plot@id}%  
	\iftikz@plot@raw@gnuplot%
		\def\pgfplots@plot@data{\pgfplotgnuplot[\pgfplots@plot@filename]{#3}}%
	\else%
		\def\pgfplots@plot@data{\pgfplotgnuplot[\pgfplots@plot@filename]{%
			\pgfplots@gnuplot@format;
			set samples \tikz@plot@samples;
			\iftikz@plot@parametric	set parametric;\fi
			\ifpgfplots@curplot@threedim s\fi plot [x=\tikz@plot@domain] \ifpgfplots@curplot@threedim [y=\pgfplots@plot@ydomain]\fi\space #3;}}%
	\fi%
	\def\pgfplotxyfile{\pgfplots@addplotimpl@gnuplotresult{#1}{#4}}%
	\pgfplots@plot@data
	\let\pgfplotxyfile=\pgfplots@backupof@pgfplotxyfile
}%

\def\pgfplots@addplotimpl@gnuplotresult#1#2#3{%
	\begingroup
	\openin1=#3
	\ifeof1
		\pgfplots@error{Sorry, the gnuplot-result file '#3' could not be found. Maybe you need to enable the shell-escape feature? For pdflatex, this is '>> pdflatex -shell-escape'. You can also invoke '>> gnuplot <file>.gnuplot' manually on the respective gnuplot file.}%
		\aftergroup\pgfplots@loop@CONTINUEfalse
	\else
		\aftergroup\pgfplots@loop@CONTINUEtrue
	\fi
	\closein1
	\endgroup
	\ifpgfplots@loop@CONTINUE
		\pgfplots@addplotimpl@file{#1}ile{#3}#2;%
	\fi
}

% #1: arguments to \addplot[...]
% #2: the file name
% #3: any additional path arguments
\def\pgfplots@addplotimpl@file#1ile{%
	\pgfutil@ifnextchar[{%
		\pgfplots@addplotimpl@file@opt{#1}%
	}{%
		\pgfplots@addplotimpl@file@opt{#1}[]%
	}%
}

% \addplot[#1] file[#2] {#3} #4;
\def\pgfplots@addplotimpl@file@opt#1[#2]#3#4;{%
	\begingroup
	\def\pgfplots@loc@TMPa{#2}%
	\ifx\pgfplots@loc@TMPa\pgfutil@empty
	\else
		\pgfqkeys{/pgfplots/plot file}{#2}%
	\fi
	\pgfplots@PREPARE@COORD@STREAM{#1}{#4}%
	\pgfplots@coord@stream@start
	\openin1=#3
	\ifeof1
		\pgfplots@warning{sorry, plot file{#3} could not be opened!?}%
	\else
		\let\pgfplots@current@point@x@error=\pgfutil@empty
		\let\pgfplots@current@point@y@error=\pgfutil@empty
		\let\pgfplots@current@point@z@error=\pgfutil@empty
		\ifpgfplots@curplot@threedim
			\let\pgfplots@addplotimpl@file@parsesingle=\pgfplots@addplotimpl@file@parsesingle@threedim
			\ifnum\pgfplots@perpointmeta@choice=4
				\let\pgfplots@addplotimpl@file@parsesingle=\pgfplots@addplotimpl@file@parsesingle@threedim@andmeta
			\else
				\ifnum\pgfplots@perpointmeta@choice=5
					\let\pgfplots@addplotimpl@file@parsesingle=\pgfplots@addplotimpl@file@parsesingle@threedim@andmeta
				\fi
			\fi
		\else
			\let\pgfplots@addplotimpl@file@parsesingle=\pgfplots@addplotimpl@file@parsesingle@twodim
			\ifnum\pgfplots@perpointmeta@choice=4
				\let\pgfplots@addplotimpl@file@parsesingle=\pgfplots@addplotimpl@file@parsesingle@twodim@andmeta
			\else
				\ifnum\pgfplots@perpointmeta@choice=5
					\let\pgfplots@addplotimpl@file@parsesingle=\pgfplots@addplotimpl@file@parsesingle@twodim@andmeta
				\fi
			\fi
		\fi
		\pgfplots@addplotimpl@file@readall
	\fi
	\pgfplots@coord@stream@end
	\endgroup
}%
\def\pgfplots@addplotimpl@file@readall{%
	\read1 to\pgfplots@file@LINE
	\expandafter\pgfplotstableread@checkspecial@line\pgfplots@file@LINE\pgfplotstable@EOI
	\ifpgfplotstableread@skipline
	\else
		\ifpgfplots@plot@file@skipfirst
			% Silently skip first data row, assuming it is a header.
			\pgfplots@plot@file@skipfirstfalse
		\else
			\expandafter\pgfplots@addplotimpl@file@parsesingle\pgfplots@file@LINE\pgfplots@EOI
		\fi
	\fi
	\ifeof1
	\else
		\expandafter
		\pgfplots@addplotimpl@file@readall
	\fi
}%

\def\pgfplots@addplotimpl@file@parsesingle@threedim#1 #2 #3 #4\pgfplots@EOI{%
	\def\pgfplots@current@point@x{#1}%
	\def\pgfplots@current@point@y{#2}%
	\def\pgfplots@current@point@z{#3}%
	\pgfplots@coord@stream@coord%
}%
\def\pgfplots@addplotimpl@file@parsesingle@twodim#1 #2 #3\pgfplots@EOI{%
	\def\pgfplots@current@point@x{#1}%
	\def\pgfplots@current@point@y{#2}%
	\pgfplots@coord@stream@coord%
}%
\def\pgfplots@addplotimpl@file@parsesingle@threedim@andmeta#1 #2 #3 #4 #5\pgfplots@EOI{%
	\def\pgfplots@current@point@x{#1}%
	\def\pgfplots@current@point@y{#2}%
	\def\pgfplots@current@point@z{#3}%
	\def\pgfplots@current@point@meta{#4}%
	\pgfplots@coord@stream@coord%
}%
\def\pgfplots@addplotimpl@file@parsesingle@twodim@andmeta#1 #2 #3 #4\pgfplots@EOI{%
	\def\pgfplots@current@point@x{#1}%
	\def\pgfplots@current@point@y{#2}%
	\def\pgfplots@current@point@meta{#3}%
	\pgfplots@coord@stream@coord%
}%

\def\pgfplots@addplotimpl@table#1table{%
	\pgfutil@ifnextchar[{%
		\pgfplots@addplotimpl@table@getopts{#1}%
	}{%
		\pgfplots@addplotimpl@table@getopts{#1}[x index=0,y index=1]%
	}%
}%

\def\pgfplots@addplotimpl@table@getopts#1[#2]{%
	\pgfutil@ifnextchar f{%
		\pgfplots@addplotimpl@table@fromstructure{#1}{#2}%
	}{%
		\pgfplots@addplotimpl@table@fromfile{#1}{#2}%
	}%
}

% #1: arguments to \addplot[...]
% #2: arguments to table[...]
% #3: the argument of plot table{...}
% #4: trailing path arguments after plot table{...}#4;
\long\def\pgfplots@addplotimpl@table@fromstructure#1#2from#3#4;{%
	\begingroup
	% FIXME : this thing here has runtime O(N^2) !
	% I fear it is faster to simply reload the data .... !?
	%
	% well, for a lot of columns which are used in different contexts
	% and few rows, this here IS more efficient.
	\pgfplotstableset{#2}%
	\pgfplotstablecopy#3\to\pgfplots@table
	\pgfkeysgetvalue{/pgfplots/table/x}{\pgfplots@plot@tbl@x}%
	\pgfkeysgetvalue{/pgfplots/table/x index}{\pgfplots@plot@tbl@xindex}%
	\pgfkeysgetvalue{/pgfplots/table/y}{\pgfplots@plot@tbl@y}%
	\pgfkeysgetvalue{/pgfplots/table/y index}{\pgfplots@plot@tbl@yindex}%
	\pgfkeysgetvalue{/pgfplots/table/z}{\pgfplots@plot@tbl@z}%
	\pgfkeysgetvalue{/pgfplots/table/z index}{\pgfplots@plot@tbl@zindex}%
	\pgfkeysgetvalue{/pgfplots/table/meta}{\pgfplots@plot@tbl@meta}%
	\pgfkeysgetvalue{/pgfplots/table/meta index}{\pgfplots@plot@tbl@metaindex}%
	\ifx\pgfplots@plot@tbl@x\pgfutil@empty
		\pgfplotstablegetcolumnbyindex\pgfplots@plot@tbl@xindex\of\pgfplots@table\to\addplot@tbl@x
	\else
		\pgfplotstablegetcolumnbyname\pgfplots@plot@tbl@x\of\pgfplots@table\to\addplot@tbl@x
	\fi
	\ifx\pgfplots@plot@tbl@y\pgfutil@empty
		\pgfplotstablegetcolumnbyindex\pgfplots@plot@tbl@yindex\of\pgfplots@table\to\addplot@tbl@y
	\else
		\pgfplotstablegetcolumnbyname\pgfplots@plot@tbl@y\of\pgfplots@table\to\addplot@tbl@y
	\fi
	\ifpgfplots@curplot@threedim
		\ifx\pgfplots@plot@tbl@z\pgfutil@empty
			\pgfplotstablegetcolumnbyindex\pgfplots@plot@tbl@zindex\of\pgfplots@table\to\addplot@tbl@z
		\else
			\pgfplotstablegetcolumnbyname\pgfplots@plot@tbl@z\of\pgfplots@table\to\addplot@tbl@z
		\fi
	\fi
	\let\addplot@tbl@meta=\pgfutil@empty
	\ifx\pgfplots@plot@tbl@meta\pgfutil@empty
		\ifx\pgfplots@plot@tbl@metaindex\pgfutil@empty
		\else
			\pgfplotstablegetcolumnbyindex\pgfplots@plot@tbl@metaindex\of\pgfplots@table\to\addplot@tbl@meta
		\fi
	\else
		\pgfplotstablegetcolumnbyname\pgfplots@plot@tbl@meta\of\pgfplots@table\to\addplot@tbl@meta
	\fi
	%
	\ifpgfplots@errorbars@enabled
		\let\addplot@tbl@error@x=\pgfutil@empty
		\let\addplot@tbl@error@z=\pgfutil@empty
		\pgfkeysgetvalue{/pgfplots/table/x error index}\pgfplots@plot@tbl@error@xindex
		\pgfkeysgetvalue{/pgfplots/table/x error}\pgfplots@plot@tbl@error@x
		\pgfkeysgetvalue{/pgfplots/table/y error index}\pgfplots@plot@tbl@error@yindex
		\pgfkeysgetvalue{/pgfplots/table/y error}\pgfplots@plot@tbl@error@y
		\pgfkeysgetvalue{/pgfplots/table/z error index}\pgfplots@plot@tbl@error@zindex
		\pgfkeysgetvalue{/pgfplots/table/z error}\pgfplots@plot@tbl@error@z
		\ifx\pgfplots@plot@tbl@error@x\pgfutil@empty
			\ifx\pgfplots@plot@tbl@error@xindex\pgfutil@empty
			\else
				\pgfplotstablegetcolumnbyindex\pgfplots@plot@tbl@error@xindex\of\pgfplots@table\to\addplot@tbl@error@x
			\fi
		\else
			\pgfplotstablegetcolumnbyname\pgfplots@plot@tbl@error@x\of\pgfplots@table\to\addplot@tbl@error@x
		\fi
		\ifx\pgfplots@plot@tbl@error@y\pgfutil@empty
			\ifx\pgfplots@plot@tbl@error@yindex\pgfutil@empty
			\else
				\pgfplotstablegetcolumnbyindex\pgfplots@plot@tbl@error@yindex\of\pgfplots@table\to\addplot@tbl@error@y
			\fi
		\else
			\pgfplotstablegetcolumnbyname\pgfplots@plot@tbl@error@y\of\pgfplots@table\to\addplot@tbl@error@y
		\fi
		\ifpgfplots@curplot@threedim
			\ifx\pgfplots@plot@tbl@error@z\pgfutil@empty
				\ifx\pgfplots@plot@tbl@error@zindex\pgfutil@empty
				\else
					\pgfplotstablegetcolumnbyindex\pgfplots@plot@tbl@error@zindex\of\pgfplots@table\to\addplot@tbl@error@z
				\fi
			\else
				\pgfplotstablegetcolumnbyname\pgfplots@plot@tbl@error@z\of\pgfplots@table\to\addplot@tbl@error@z
			\fi
		\fi
	\fi
	%
	\ifpgfplots@errorbars@enabled
	\else
		\let\pgfplots@current@point@x@error=\pgfutil@empty
		\let\pgfplots@current@point@y@error=\pgfutil@empty
		\let\pgfplots@current@point@z@error=\pgfutil@empty
	\fi
	\let\pgfplots@current@point@meta=\pgfutil@empty
	\pgfplots@PREPARE@COORD@STREAM{#1}{#4}%
	\pgfplots@coord@stream@start
	\pgfutil@loop
	\pgfplotslistcheckempty\addplot@tbl@x
	\ifpgfplotslistempty
		\pgfplots@loop@CONTINUEfalse
	\else
		% This here is just for sanity checking: if the 'y' column is 
		% - for whatever reasons - invalid; provide good error
		%   recovery.
		\pgfplotslistcheckempty\addplot@tbl@y
		\ifpgfplotslistempty
			\pgfplots@loop@CONTINUEfalse
		\else
			\pgfplots@loop@CONTINUEtrue
		\fi
	\fi
	\ifpgfplots@loop@CONTINUE
		\pgfplotslistpopfront\addplot@tbl@x\to\pgfplots@current@point@x
		\pgfplotslistpopfront\addplot@tbl@y\to\pgfplots@current@point@y
		\ifpgfplots@curplot@threedim
			\pgfplotslistpopfront\addplot@tbl@z\to\pgfplots@current@point@z
		\fi
		\ifx\addplot@tbl@meta\pgfutil@empty
		\else
			\pgfplotslistpopfront\addplot@tbl@meta\to\pgfplots@current@point@meta
		\fi
		\ifpgfplots@errorbars@enabled
			\ifx\addplot@tbl@error@x\pgfutil@empty
				\let\pgfplots@current@point@x@error=\pgfutil@empty
			\else
				\pgfplotslistpopfront\addplot@tbl@error@x\to\pgfplots@current@point@x@error
			\fi
			\ifx\addplot@tbl@error@y\pgfutil@empty
				\let\pgfplots@current@point@y@error=\pgfutil@empty
			\else
				\pgfplotslistpopfront\addplot@tbl@error@y\to\pgfplots@current@point@y@error
			\fi
			\ifpgfplots@errorbars@enabled
				\ifx\addplot@tbl@error@z\pgfutil@empty
					\let\pgfplots@current@point@z@error=\pgfutil@empty
				\else
					\pgfplotslistpopfront\addplot@tbl@error@z\to\pgfplots@current@point@z@error
				\fi
			\fi
			\pgfplots@coord@stream@coord
		\else
			\pgfplots@coord@stream@coord
		\fi
	\pgfutil@repeat
	\pgfplots@coord@stream@end
	\endgroup
}


% #1: arguments to \addplot[...]
% #2: arguments to table[...]
% #3: the argument of plot table{...}
% #4: trailing path arguments after plot table{...}#4;
\long\def\pgfplots@addplotimpl@table@fromfile#1#2#3#4;{%
	%--------------------------------------------------
	% \begingroup
	% \pgfplotstableset{#2}%
	% \pgfplotstableread{#3}\pgfplots@table
	% \pgfplots@addplotimpl@table@fromstructure{#1}{}from{\pgfplots@table}{#4};%
	% \endgroup
	%-------------------------------------------------- 
	\pgfplotsapplistXXglobalnewempty
	\begingroup
	\pgfplotstableset{#2}%
	\pgfkeysgetvalue{/pgfplots/table/x}{\pgfplots@plot@tbl@x}%
	\pgfkeysgetvalue{/pgfplots/table/x index}{\pgfplots@plot@tbl@xindex}%
	\pgfkeysgetvalue{/pgfplots/table/y}{\pgfplots@plot@tbl@y}%
	\pgfkeysgetvalue{/pgfplots/table/y index}{\pgfplots@plot@tbl@yindex}%
	\pgfkeysgetvalue{/pgfplots/table/z}{\pgfplots@plot@tbl@z}%
	\pgfkeysgetvalue{/pgfplots/table/z index}{\pgfplots@plot@tbl@zindex}%
	\pgfkeysgetvalue{/pgfplots/table/meta}{\pgfplots@plot@tbl@meta}%
	\pgfkeysgetvalue{/pgfplots/table/meta index}{\pgfplots@plot@tbl@metaindex}%
	\let\pgfplots@table@PTR@x=\pgfutil@empty
	\let\pgfplots@table@PTR@y=\pgfutil@empty
	\let\pgfplots@table@PTR@z=\pgfutil@empty
	\let\pgfplots@table@PTR@meta=\pgfutil@empty
	\let\pgfplots@current@point@meta=\pgfutil@empty
	\ifpgfplots@errorbars@enabled
		\let\pgfplots@table@ERRPTR@x=\pgfutil@empty
		\let\pgfplots@table@ERRPTR@y=\pgfutil@empty
		\let\pgfplots@table@ERRPTR@z=\pgfutil@empty
		\pgfkeysgetvalue{/pgfplots/table/x error index}\pgfplots@plot@tbl@error@xindex
		\pgfkeysgetvalue{/pgfplots/table/x error}\pgfplots@plot@tbl@error@x
		\pgfkeysgetvalue{/pgfplots/table/y error index}\pgfplots@plot@tbl@error@yindex
		\pgfkeysgetvalue{/pgfplots/table/y error}\pgfplots@plot@tbl@error@y
		\pgfkeysgetvalue{/pgfplots/table/z error index}\pgfplots@plot@tbl@error@zindex
		\pgfkeysgetvalue{/pgfplots/table/z error}\pgfplots@plot@tbl@error@z
		\pgfplotstableread{#3} to listener\pgfplots@addplotimpl@table@fromfile@listener@witherrors
	\else
		\pgfplotstableread{#3} to listener\pgfplots@addplotimpl@table@fromfile@listener
	\fi
	\endgroup
	%
	\pgfplots@PREPARE@COORD@STREAM{#1}{#4}%
	\pgfplotsapplistXXgloballet\pgfplots@coordlist
	\pgfplotsapplistXXglobalclear
	% FIXME : isn't there a faster way!?
	\ifpgfplots@curplot@threedim
		\expandafter\pgfplots@coord@stream@foreach@threedim\expandafter{\pgfplots@coordlist}%%
	\else
		\expandafter\pgfplots@coord@stream@foreach\expandafter{\pgfplots@coordlist}%%
	\fi
}
\def\pgfplots@addplotimpl@table@fromfile@listener{%
	\pgfplots@addplotimpl@table@fromfile@listener@
	\edef\pgfplots@current@point{%
		(\pgfplots@current@point@x,%
		 \pgfplots@current@point@y%
		 \ifpgfplots@curplot@threedim,\pgfplots@current@point@z\fi%
		)%	
		 \ifx\pgfplots@current@point@meta\pgfutil@empty\else[\pgfplots@current@point@meta]\fi%
	}%
	\expandafter\pgfplotsapplistXXglobalpushback\expandafter{\pgfplots@current@point}%
}
\def\pgfplots@addplotimpl@table@fromfile@listener@{%
	\ifx\pgfplots@table@PTR@x\pgfutil@empty
		% this here is only evaluated ONCE.
		\ifx\pgfplots@plot@tbl@x\pgfutil@empty
			\pgfplotstablereadgetptrtocolindex{\pgfplots@plot@tbl@xindex}{\pgfplots@table@PTR@x}%
		\else
			\pgfplotstablereadgetptrtocolname{\pgfplots@plot@tbl@x}{\pgfplots@table@PTR@x}%
		\fi
		\ifx\pgfplots@plot@tbl@y\pgfutil@empty
			\pgfplotstablereadgetptrtocolindex{\pgfplots@plot@tbl@yindex}{\pgfplots@table@PTR@y}%
		\else
			\pgfplotstablereadgetptrtocolname{\pgfplots@plot@tbl@y}{\pgfplots@table@PTR@y}%
		\fi
		\ifpgfplots@curplot@threedim
			\ifx\pgfplots@plot@tbl@z\pgfutil@empty
				\pgfplotstablereadgetptrtocolindex{\pgfplots@plot@tbl@zindex}{\pgfplots@table@PTR@z}%
			\else
				\pgfplotstablereadgetptrtocolname{\pgfplots@plot@tbl@z}{\pgfplots@table@PTR@z}%
			\fi
		\fi
		\ifx\pgfplots@plot@tbl@meta\pgfutil@empty
			\ifx\pgfplots@plot@tbl@metaindex\pgfutil@empty
			\else
				\pgfplotstablereadgetptrtocolindex{\pgfplots@plot@tbl@metaindex}{\pgfplots@table@PTR@meta}%
			\fi
		\else
			\pgfplotstablereadgetptrtocolname{\pgfplots@plot@tbl@meta}{\pgfplots@table@PTR@meta}%
		\fi
	\fi
	\pgfplotstablereadevalptr\pgfplots@table@PTR@x\pgfplots@current@point@x
	\pgfplotstablereadevalptr\pgfplots@table@PTR@y\pgfplots@current@point@y
	\ifpgfplots@curplot@threedim
		\pgfplotstablereadevalptr\pgfplots@table@PTR@z\pgfplots@current@point@z
	\fi
	\ifx\pgfplots@table@PTR@meta\pgfutil@empty
	\else
		\pgfplotstablereadevalptr\pgfplots@table@PTR@meta\pgfplots@current@point@meta
	\fi
}%
\def\pgfplots@addplotimpl@table@fromfile@listener@witherrors{%
	\pgfplots@addplotimpl@table@fromfile@listener@
	%
	\ifx\pgfplots@table@ERRPTR@x\pgfutil@empty
		% this here is only evaluated ONCE.
		\ifx\pgfplots@plot@tbl@error@x\pgfutil@empty
			\ifx\pgfplots@plot@tbl@error@xindex\pgfutil@empty
				\let\pgfplots@table@ERRPTR@x=\relax%
			\else
				\pgfplotstablereadgetptrtocolindex{\pgfplots@plot@tbl@error@xindex}{\pgfplots@table@ERRPTR@x}%
			\fi
		\else
			\pgfplotstablereadgetptrtocolname{\pgfplots@plot@tbl@error@x}{\pgfplots@table@ERRPTR@x}%
		\fi
		\ifx\pgfplots@plot@tbl@error@y\pgfutil@empty
			\ifx\pgfplots@plot@tbl@error@yindex\pgfutil@empty
				\let\pgfplots@table@ERRPTR@y=\relax%
			\else
				\pgfplotstablereadgetptrtocolindex{\pgfplots@plot@tbl@error@yindex}{\pgfplots@table@ERRPTR@y}%
			\fi
		\else
			\pgfplotstablereadgetptrtocolname{\pgfplots@plot@tbl@error@y}{\pgfplots@table@ERRPTR@y}%
		\fi
		\ifpgfplots@curplot@threedim
			\ifx\pgfplots@plot@tbl@error@z\pgfutil@empty
				\ifx\pgfplots@plot@tbl@error@zindex\pgfutil@empty
					\let\pgfplots@table@ERRPTR@z=\relax%
				\else
					\pgfplotstablereadgetptrtocolindex{\pgfplots@plot@tbl@error@zindex}{\pgfplots@table@ERRPTR@z}%
				\fi
			\else
				\pgfplotstablereadgetptrtocolname{\pgfplots@plot@tbl@error@z}{\pgfplots@table@ERRPTR@z}%
			\fi
		\fi
	\fi
	\ifx\relax\pgfplots@table@ERRPTR@x
		\let\pgfplots@current@point@x@error=\pgfutil@empty
	\else
		\pgfplotstablereadevalptr\pgfplots@table@ERRPTR@x\pgfplots@current@point@x@error
	\fi
	\ifx\relax\pgfplots@table@ERRPTR@y
		\let\pgfplots@current@point@y@error=\pgfutil@empty
	\else
		\pgfplotstablereadevalptr\pgfplots@table@ERRPTR@y\pgfplots@current@point@y@error
	\fi
	\ifpgfplots@curplot@threedim
		\ifx\relax\pgfplots@table@ERRPTR@z
			\let\pgfplots@current@point@z@error=\pgfutil@empty
		\else
			\pgfplotstablereadevalptr\pgfplots@table@ERRPTR@z\pgfplots@current@point@z@error
		\fi
		\edef\pgfplots@current@point{(\pgfplots@current@point@x,\pgfplots@current@point@y,\pgfplots@current@point@z)+-(\pgfplots@current@point@x@error,\pgfplots@current@point@y@error,\pgfplots@current@point@z@error)}%
	\else
		\edef\pgfplots@current@point{(\pgfplots@current@point@x,\pgfplots@current@point@y)+-(\pgfplots@current@point@x@error,\pgfplots@current@point@y@error)}%
	\fi
	\expandafter\pgfplotsapplistXXglobalpushback\expandafter{\pgfplots@current@point}%
}%

% #1:  arguments to \addplot plot[#1]
%   -> these are called 'behavior' options in the manual; they are set
%   immediately.
\def\pgfplots@start@plot@with@behavioroptions#1{%
	\begingroup
	\def\pgfplots@current@point@coordindex{0}% can be used inside of coordinate filters.
	\def\coordindex{\pgfplots@current@point@coordindex}% valid inside of \addplot
	\ifx\pgfplots@execute@at@begin@plot\pgfutil@empty
	\else
		\pgfplots@execute@at@begin@plot
	\fi
	\def\pgfplots@addplot@nonlegend@options{#1}%
	\ifx\pgfplots@addplot@nonlegend@options\pgfutil@empty
	\else
		\pgfplotsset{#1}%
	\fi
	% these styles may contain behavior options (error bars,
	% samples,... ) activate them!
	\pgfplotsset{/pgfplots/every axis plot,/pgfplots/every axis plot no \the\pgfplots@numplots/.try}%
}

\def\pgfplots@end@plot{%
	\global\advance\pgfplots@numplots by1\relax%
	\ifx\pgfplots@execute@at@end@plot\pgfutil@empty
	\else
		\pgfplots@execute@at@end@plot
	\fi
	\global\let\pgfplots@glob@TMPa=\relax
	\ifpgfplots@collect@firstplot@astick
		\ifnum\pgfplots@numplots=1\relax
			\t@pgfplots@toka=\expandafter{\pgfplots@firstplot@coords@x}%
			\t@pgfplots@tokb=\expandafter{\pgfplots@firstplot@coords@y}%
			\xdef\pgfplots@glob@TMPa{%
				\noexpand\def\noexpand\pgfplots@firstplot@coords@x{\the\t@pgfplots@toka}%
				\noexpand\def\noexpand\pgfplots@firstplot@coords@y{\the\t@pgfplots@tokb}%
			}%
		\fi
	\fi
	\endgroup
	\pgfplots@glob@TMPa% see above
}

% #1: arguments to \addplot[...]
% #2: the plot coordinates
% #3: any trailing path command before the final ';'. It will be used as-is.
\long\def\pgfplots@addplotimpl@coordinates#1plot coordinates#2#3;{%
%\tracingmacros=2\tracingcommands=2
%\pgfplots@message{processing plots coords with trailing path '#3'}%
	\pgfplots@PREPARE@COORD@STREAM{#1}{#3}%
	\ifpgfplots@curplot@threedim
		\pgfplots@coord@stream@foreach@threedim{#2}%
	\else
		\pgfplots@coord@stream@foreach{#2}%
	\fi
}%

\newif\ifpgfplots@update@limits@for@one@point@ISCLIPPED
\def\pgfplots@math@ONE{1.0}%

\def\pgfplots@streamerrorbarstart{%
}%
\def\pgfplots@streamerrorbarend{%
}%
\def\pgfplots@streamerrorbarcoords#1#2{%
}%

\def\pgfplots@streamerrorbar@recordto#1{%
	\def\pgfplots@streamerrorbarstart{%
		\pgfplotsapplistXnewempty\pgfplots@streamerrorbar@recordto@@
	}%
	\def\pgfplots@streamerrorbarend{%
		\pgfplotsapplistXlet#1=\pgfplots@streamerrorbar@recordto@@
		\pgfplotsapplistXnewempty\pgfplots@streamerrorbar@recordto@@% clear
	}%
	\def\pgfplots@streamerrorbarcoords##1##2{%
		\pgfplotsapplistXpushback{\pgfplots@errorbar@draw{##1}{##2}}\to\pgfplots@streamerrorbar@recordto@@
	}%
}
\def\pgfplots@streamerrorbar@directdraw{%
	\def\pgfplots@streamerrorbarstart{}%
	\def\pgfplots@streamerrorbarend{}%
	\def\pgfplots@streamerrorbarcoords##1##2{%
		\pgfplots@errorbar@draw{##1}{##2}%
	}%
}
	
\def\pgfplots@invoke@filter#1#2{%
	\pgfkeysvalueof{/pgfplots/#2 filter/.@cmd}#1\pgfeov%
}%

% this is a convenience macro to save storage in the long coordinate
% lists.
\def\pgfplots@stream#1#2{\pgfplotstreampoint{\pgfqpoint{#1}{#2}}}
\def\pgfplots@stream@withmeta#1#2#3{\def\pgfplots@current@point@meta{#3}\pgfplotstreampoint{\pgfqpoint{#1}{#2}}}

\newif\ifpgfplots@record@marker@stream
% Takes a sequence of PREPARED coordinates which are given in floating
% point representation and applies the data scaling trafo (if
% necessary).
%
% Any coordinate will be plotted with the selected PGF plot handler.
%
% This stream is designed to be done at the end of an axis.
% See \pgfplots@coord@stream@finalize@storedcoords@START
%
% #1 : a macro which will be filled with a pgf plot stream for the
% marker points.
\def\pgfplots@coord@stream@INIT@finalize@storedcoords#1{%
	%
	% Init the plot handlers:
	\pgfplots@getcurrent@plothandler\pgfplots@basiclevel@plothandler
	\pgfplots@gettikzinternal@keyval{mark}{tikz@plot@mark}{}%
	%
	\ifx\tikz@plot@mark\pgfutil@empty
		% mark=none : no need to waste time collecting marker
		% positions.
		\pgfplots@record@marker@streamfalse
	\else
		\ifx\pgfplots@basiclevel@plothandler\pgfplothandlerdiscard
			\ifpgfplots@clip@marker@paths
				% only marks: draw markers directly; no need for the
				% two-pass-approach.
				\let\pgfplots@basiclevel@plothandler=\relax
				\pgfplots@install@plotmark@handler
				\pgfplots@record@marker@streamfalse
			\else
				% collect mark positions... they will be drawn after
				% the clipped axis range. Clipping will only be
				% applied to their *positions*, not their paths.
				\pgfplots@record@marker@streamtrue
			\fi
		\else
			% ok, mark!=none and we also have a plot handler.
			% So, collect mark positions!
			\pgfplots@record@marker@streamtrue
		\fi
	\fi
	\gdef#1{}%
	%
	% Now, set up coordinate streams.
	\def\pgfplots@coord@stream@start@{%
		\ifpgfplots@apply@datatrafo
			\ifpgfplots@stackedmode
				\pgfplots@stacked@beginplot
			\fi
		\fi
		\pgfplots@basiclevel@plothandler
		\pgfplotstreamstart
		\let\pgfplots@data@scaletrafo@result=\pgfutil@empty
		\ifpgfplots@record@marker@stream
			\pgfplotsapplistXXnewempty
			\pgfplotsapplistXXpushback{\pgfplotstreamstart}%
			%\gdef#1{\pgfplotstreamstart}%
		\fi
		% Define \pgfplots@process@perpointmeta properly:
		\ifnum\pgfplots@perpointmeta@choice=0
			% disabled.
			\def\pgfplots@process@perpointmeta{%	
				\let\pgfplots@current@point@meta=\pgfutil@empty
			}%
		\else
		\fi
	}%
	\def\pgfplots@coord@stream@end@{%
		\ifpgfplots@apply@datatrafo
			\ifpgfplots@stackedmode
				\pgfplots@stacked@endplot
			\fi
			\pgfplots@addplot@get@named@startendpoints@command\pgfplots@loc@TMPa
			\pgfplots@loc@TMPa
		\fi
		\pgfplotstreamend
		\ifpgfplots@record@marker@stream
			\pgfplotsapplistXXpushback{\pgfplotstreamend}%
			\pgfplotsapplistXXflushbuffers%
			\global\let#1=\pgfplotsapplistXX
			\pgfplotsapplistXXclear
			%\expandafter\gdef\expandafter#1\expandafter{#1\pgfplotstreamend}%
		\fi
	}%
	\begingroup
	\let\E=\noexpand
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\pgfplots@coord@stream@INIT@finalize@storedcoords@prepare@scaletrafomacro
	%
	% Will be inserted in one of two possible places below:
	\def\pgfplots@loc@TMPa{%
		\ifnum\pgfplots@perpointmeta@choice=0
			% we don't have per-point meta data. Nothing special to
			% do:
			\E\edef\E\pgfmathresult{\E\noexpand\E\pgfplots@stream{\E\the\E\pgf@x}{\E\the\E\pgf@y}}%
			\E\expandafter\E\pgfplotsapplistXXpushback\E\expandafter{\E\pgfmathresult}%
		\else
			% Ok, then we need to process the meta data as well:
			\E\edef\E\pgfmathresult{\E\noexpand\E\pgfplots@stream@withmeta{\E\the\E\pgf@x}{\E\the\E\pgf@y}{\E\pgfplots@current@point@meta}}%
			\E\expandafter\E\pgfplotsapplistXXpushback\E\expandafter{\E\pgfmathresult}%
		\fi
	}%
	% This finalize command maps the logical coordinate into PGF's
	% point space. Furthermore, it collects marker coordinates
	% (properly clipped by position) if markers are required (see
	% above).
	%
	% It is prepared here to eliminate if's.
	\xdef\pgfplots@coord@stream@finalize@currentpt{%
		\ifpgfplots@curplot@threedim
			\E\pgfplotsqpointxyz{\E\pgfplots@current@point@x}{\E\pgfplots@current@point@y}{\E\pgfplots@current@point@z}%
		\else
			\ifpgfplots@threedim
				\E\pgfplotsqpointxyz{\E\pgfplots@current@point@x}{\E\pgfplots@current@point@y}{0.0}%
			\else
				\E\pgfplotsqpointxy{\E\pgfplots@current@point@x}{\E\pgfplots@current@point@y}%
			\fi
		\fi
		\ifpgfplots@record@marker@stream
			\E\pgf@xa=\E\pgfplots@current@point@x pt % FIXME : SCOPE REGISTERS!?
			\E\pgf@ya=\E\pgfplots@current@point@y pt %
			\ifpgfplots@curplot@threedim
				\E\pgf@yb=\E\pgfplots@current@point@z pt %
			\fi
			\E\ifdim\E\pgf@xa<\E\pgfplots@xmin@reg
			\E\else
				\E\ifdim\E\pgf@xa>\E\pgfplots@xmax@reg
				\E\else
					\E\ifdim\E\pgf@ya<\E\pgfplots@ymin@reg
					\E\else
						\E\ifdim\E\pgf@ya>\E\pgfplots@ymax@reg
						\E\else
							\ifpgfplots@curplot@threedim
								\E\ifdim\E\pgf@yb<\E\pgfplots@zmin@reg
								\E\else
									\E\ifdim\E\pgf@yb>\E\pgfplots@zmax@reg
									\E\else
										\pgfplots@loc@TMPa
									\E\fi
								\E\fi
							\else
								\pgfplots@loc@TMPa
							\fi
						\E\fi
					\E\fi
				\E\fi
			\E\fi
		\fi
		\E\pgfplotstreampoint{}% it will simply take \pgf@x and \pgf@y!
	}%
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\endgroup
%
%\message{Prepared macro	\string \pgfplots@apply@data@scaletrafo@to@one@point {\meaning\pgfplots@apply@data@scaletrafo@to@one@point}}%
%\message{Prepared macro	\string \pgfplots@coord@stream@finalize@currentpt {\meaning\pgfplots@coord@stream@finalize@currentpt}}%
	\ifpgfplots@apply@datatrafo
		\def\pgfplots@coord@stream@coord@{%
			\pgfplots@apply@data@scaletrafo@to@one@point%
			\pgfplots@coord@stream@finalize@currentpt
		}%
	\else
		\def\pgfplots@coord@stream@coord@{%
			\pgfplots@coord@stream@finalize@currentpt
		}%
	\fi
	%
}

% Defines an optimized and matching \pgfplots@apply@data@scaletrafo@to@one@point 
% during the coordinate finalization step in \end{axis}.
\def\pgfplots@coord@stream@INIT@finalize@storedcoords@prepare@scaletrafomacro{%
	\begingroup
	\let\E=\noexpand
	% The command which is called for every non-yet-finished point.
	%
	% It is prepared here to eliminate if's.
	%
	% Arguments:
	% \pgfplots@current@point@[xyz]
	% \pgfplots@current@point@[xyz]@error (if in argument list)
	\xdef\pgfplots@apply@data@scaletrafo@to@one@point{%
		\ifpgfplots@apply@datatrafo@x
			\E\pgfplots@datascaletrafo@x{\E\pgfplots@current@point@x}%
			\E\let\E\pgfplots@current@point@x=\E\pgfmathresult
		\fi
		\ifpgfplots@apply@datatrafo@y
			\E\pgfplots@datascaletrafo@y{\E\pgfplots@current@point@y}%
			\E\let\E\pgfplots@current@point@y=\E\pgfmathresult
		\fi
		\ifpgfplots@curplot@threedim
			\ifpgfplots@apply@datatrafo@z
				\E\pgfplots@datascaletrafo@z{\E\pgfplots@current@point@z}%
				\E\let\E\pgfplots@current@point@z=\E\pgfmathresult
			\fi
		\fi
		\ifpgfplots@stackedmode
			% all these calls work with pgfmath; no more floating point
			% arithmetics are applied.
			\E\pgfplots@stacked@getnextzerolevelpoint
			\E\pgfplots@stacked@finishpoint%
			\E\pgfplots@stacked@rememberzerolevelpoint@for@next@plot{(\E\pgfplots@current@point@x,\E\pgfplots@current@point@y)}%
		\fi
	%	\t@pgfplots@tokc=\expandafter{\pgfplots@data@scaletrafo@result}%
	%	\edef\pgfplots@data@scaletrafo@result{\the\t@pgfplots@tokc(\pgfplots@current@point@x,\pgfplots@current@point@y)}%
	}%
	%
	\endgroup
}

\def\pgfplots@addplot@get@named@startendpoints@command#1{%
	\edef#1{%
		\noexpand\pgfcoordinate{current plot begin}{\noexpand\pgfplotsqpointxy{\pgfplots@currentplot@firstcoord@x}{\pgfplots@currentplot@firstcoord@y}}%
		\noexpand\pgfcoordinate{current plot end}{\noexpand\pgfplotsqpointxy{\pgfplots@currentplot@lastcoord@x}{\pgfplots@currentplot@lastcoord@y}}%
	}%
}%

% INPUT: 
% 	either floating point or fixed point coordinates (depending on the
% 	state of the \ifpgfplots@apply@datatrafo boolean)
%
\long\def\pgfplots@coord@stream@finalize@storedcoords@START normalized coordinates #1#2;\pgfplots@EOI{%
	\pgfplots@assert@tikzinternal@exists{tikz@make@last@position}%
	\pgfplots@stored@current@cmd[current plot style]
	\pgfextra
	\tikzset{every plot/.try}%
	\pgfplots@coord@stream@INIT@finalize@storedcoords\pgfplots@recorded@marker@stream%
	\pgfplots@coord@stream@foreach@NORMALIZED{#1}%
	\tikz@make@last@position{\pgfplotlastpoint}%  
	\endpgfextra
	#2;
	\ifx\pgfplots@recorded@marker@stream\pgfutil@empty
	\else
		\ifpgfplots@clip@marker@paths
			% Draw markers on top of the plot lines:
			%
			% FIXME: inefficient! Use \scope to set variables of 'current plot style' !?
			\pgfplots@stored@current@cmd[current plot style]
			\pgfextra 
				\pgfplots@install@plotmark@handler
				\pgfplots@recorded@marker@stream 
			\endpgfextra
			;
		\else
			% sigh... ok, store the marker list (once more again).
			% They need to be drawn after the clipped area.
			\pgfplots@stored@REMEMBER@MARK@COMMAND
		\fi
	\fi
	\gdef\pgfplots@recorded@marker@stream{}% clear
}%

% This method MUST be called while \pgfplots@stored@plotlist is
% evaluated, that means
% - \pgfplots@stored@* commands need to be valid,
% - the precommand has already been invoked.
% - pgfplots@recorded@marker@stream exists
% - current plot style is valid
\def\pgfplots@stored@REMEMBER@MARK@COMMAND{%
	\pgfkeysgetvalue{/tikz/current plot style/.@cmd}{\pgfplots@loc@TMPa}%
	\t@pgfplots@toka=\expandafter{\pgfplots@loc@TMPa\pgfeov}%
	\t@pgfplots@tokb=\expandafter{\pgfplots@stored@current@cmd[current plot style]}%
	\t@pgfplots@tokc=\expandafter{\pgfplots@recorded@marker@stream}%
	\edef\pgfplots@loc@TMPa{%
		\noexpand\pgfkeysdef{/tikz/current plot style}{\the\t@pgfplots@toka}%
		%
		\noexpand\def\noexpand\pgfplots@metamin{\pgfplots@metamin}%
		\noexpand\def\noexpand\pgfplots@metamax{\pgfplots@metamax}%
		\ifpgfplots@perpointmeta@usesfloat
			\noexpand\pgfplots@perpointmeta@usesfloattrue
		\else
			\noexpand\pgfplots@perpointmeta@usesfloatfalse
		\fi
		\noexpand\def\noexpand\pgfplots@perpointmeta@choice{\pgfplots@perpointmeta@choice}%
		\noexpand\pgfplots@perpointmeta@preparetrafo
		%
		\the\t@pgfplots@tokb
		\noexpand\pgfextra
		\noexpand\pgfplots@install@plotmark@handler
		\the\t@pgfplots@tokc
		\noexpand\endpgfextra
		;}%
	\expandafter\pgfplotslistpushbackglobal\expandafter{\pgfplots@loc@TMPa}\to\pgfplots@stored@markerlist
}%

\def\pgfplots@install@plotmark@handler{%
	\pgfplots@assert@tikzinternal@exists{tikz@options}%
	% note: I can't check on tikz@transform because it can be
	% '\relax'.
	\pgfplots@gettikzinternal@keyval{mark indices}{tikz@mark@list}{}%
	\pgfplots@gettikzinternal@keyval{mark}{tikz@plot@mark}{}%
	%
	% do not reset \tikz@options: draw color may be acquired
	% from 'current plot style'
	%\let\tikz@options=\pgfutil@empty%
	\let\tikz@transform=\pgfutil@empty%
	\tikzset{every plot/.try,every mark}%
	\tikz@options
	% this here is the MAIN marker code.
	% It may be modified if scatter plot is enabled, see below.
	\def\pgfplots@loc@TMPa{\tikz@transform\pgfuseplotmark{\tikz@plot@mark}}
	\ifpgfplots@scatterplotenabled
		% Scatter plots work like this:
		%
		% <compute per-point meta info>
		% /pgfplots/scatter plot/@pre marker code
		% <marker code, lowlevel>
		% /pgfplots/scatter plot/@post marker code
		%
		% -> that's all. The Rest is configurable with style which
		%  (re)define '@pre marker code' and '@post marker code' (see
		%  the docs for details).
		%
		% Prepare arguments for '@pre/@post' macros:
		\edef\pgfplotspointmetarange{\pgfplots@metamin:\pgfplots@metamax}%
		\edef\pgfplotspointmetatransformedrange{\pgfplots@perpointmeta@traforange}%
		\t@pgfplots@toka={%
			\begingroup
			\pgfutil@ifundefined{pgfplots@current@point@meta}{%
				\pgfplots@error{'scatter plot' could not access its data source. Maybe you need to add '\string\addplot\space plot[scatter src=y]' or something like that?}%
				\pgfmathfloatcreate{1}{1.0}{0}%
				\def\pgfplotspointmetatransformed{1.0}%
			}{%
				% prepare arguments:
				\let\pgfplotspointmeta=\pgfplots@current@point@meta
				\pgfplots@perpointmeta@trafo{\pgfplotspointmeta}%
				\let\pgfplotspointmetatransformed=\pgfmathresult
			}%
			\pgfkeysvalueof{/pgfplots/scatter plot/@pre marker code/.@cmd}\pgfeov
		}%
		\t@pgfplots@tokb=\expandafter{\pgfplots@loc@TMPa}%
		\t@pgfplots@tokc={%
			\pgfkeysvalueof{/pgfplots/scatter plot/@post marker code/.@cmd}\pgfeov
			\endgroup
		}%
		\edef\pgfplots@loc@TMPa{%
			\the\t@pgfplots@toka
			\the\t@pgfplots@tokb
			\the\t@pgfplots@tokc
		}%
	\fi
	\ifx\tikz@mark@list\pgfutil@empty%
		\expandafter\pgfplothandlermark\expandafter{\pgfplots@loc@TMPa}%
	\else
		\expandafter\pgfplothandlermarklisted\expandafter{\pgfplots@loc@TMPa}{\tikz@mark@list}%
	\fi
}%

	
% This thing here shall draw all error bar commands listed in '#2'.
%
% It will be invoked when any plotting commands take effect (that
% means all limits are computed; the axis has been drawn,
% transformations are set up...)
\def\pgfplots@errorbars@finishwithstyleoptions[#1]#2{%
	\scope[/pgfplots/.cd,#1,/pgfplots/every error bar]% it used the /pgfplots/.unknown
	#2%
	\endscope
}

\def\pgfplots@errorbar@draw@float(#1,#2)(#3,#4){%
	\ifpgfplots@apply@datatrafo@x
		\pgfplots@datascaletrafo@x{#1}%
		\let\pgfplots@xarg=\pgfmathresult%
		\pgfplots@datascaletrafo@x{#3}%
		\let\pgfplots@error@xarg=\pgfmathresult%
	\else
		\def\pgfplots@xarg{#1}%
		\def\pgfplots@error@xarg{#3}%
	\fi
	\ifpgfplots@apply@datatrafo@y
		\pgfplots@datascaletrafo@y{#2}%
		\let\pgfplots@yarg=\pgfmathresult%
		\pgfplots@datascaletrafo@y{#4}%
		\let\pgfplots@error@yarg=\pgfmathresult%
	\else
		\def\pgfplots@yarg{#2}%
		\def\pgfplots@error@yarg{#4}%
	\fi
	\edef\pgfplots@loc@TMPa{{(\pgfplots@xarg,\pgfplots@yarg)}{(\pgfplots@error@xarg,\pgfplots@error@yarg)}}%
	\def\pgfplots@loc@TMPb{\pgfkeysvalueof{/pgfplots/error bars/draw error bar/.@cmd}}%
	\expandafter\pgfplots@loc@TMPb\pgfplots@loc@TMPa\pgfeov
}

\def\pgfplots@errorbar@draw#1#2{%
	\begingroup
	\ifpgfplots@apply@datatrafo
		\pgfplots@errorbar@draw@float#1#2
	\else
		\pgfkeysvalueof{/pgfplots/error bars/draw error bar/.@cmd}{#1}{#2}\pgfeov%
	\fi
	\endgroup
}%

% Arguments:
% \pgfplots@current@point@[xyz]
% \pgfplots@current@point@[xyz]@unfiltered
% \pgfplots@current@point@[xyz]@error (if in argument list)
% Also provides UNFILTERED arguments x and y . These are use
% in case of logplots, because we may need to compute log( x + e_x )
% or log( y + e_y ).
\def\pgfplots@process@errorbar@for{%
%	\begingroup
	\edef\pgfplots@xarg{\pgfplots@current@point@x}%
	\edef\pgfplots@yarg{\pgfplots@current@point@y}%
	\let\pgfplots@xarg@unfiltered\pgfplots@current@point@x@unfiltered%
	\let\pgfplots@yarg@unfiltered\pgfplots@current@point@y@unfiltered%
	\edef\pgfplots@error@xarg{\pgfplots@current@point@x@error}%
	\edef\pgfplots@error@yarg{\pgfplots@current@point@y@error}%
	\def\pgfplots@loc@TMPa{0}%
	\ifx\pgfplots@loc@TMPa\pgfplots@error@xarg
		\let\pgfplots@error@xarg=\pgfutil@empty
	\fi
	\ifx\pgfplots@loc@TMPa\pgfplots@error@yarg
		\let\pgfplots@error@yarg=\pgfutil@empty
	\fi
	%  FIXME : INEFFICIENT! This code here does every computation 
	%  multiple times!
	\ifcase\pgfplots@errorbars@xdirection
	\or
		\pgfplots@process@errorbar@@for{x}{+}1%
	\or
		\pgfplots@process@errorbar@@for{x}{-}2%
	\or
		\pgfplots@process@errorbar@@for{x}{+}1%
		\pgfplots@process@errorbar@@for{x}{-}2%
	\fi
	\ifcase\pgfplots@errorbars@ydirection
	\or
		\pgfplots@process@errorbar@@for{y}{+}1%
	\or
		\pgfplots@process@errorbar@@for{y}{-}2%
	\or
		\pgfplots@process@errorbar@@for{y}{+}1%
		\pgfplots@process@errorbar@@for{y}{-}2%
	\fi
	% Restore macros which may have been overwritten:
	\let\pgfplots@current@point@x=\pgfplots@xarg
	\let\pgfplots@current@point@y=\pgfplots@yarg
%	\endgroup
}

% #1: either 'x' or 'y'
% #2: either '+' or '-'
% #3: an integer representing the argument #2. It is '1' if #2='+'
%     and '2' is #2 = '-'.
\def\pgfplots@process@errorbar@@for#1#2#3{%
	\csname ifpgfplots@#1islinear\endcsname
		\edef\pgfplots@error@src{\csname pgfplots@#1arg\endcsname}%
		\ifcase\csname pgfplots@errorbars@#1mode\endcsname
			% fixed absolute error.
			\edef\pgfplots@error@coord{\csname pgfplots@errorbars@#1fixed\endcsname}%
			\pgfmathfloatparsenumber{\pgfplots@error@coord}%
			\let\pgfplots@error@coord=\pgfmathresult
			\ifnum#3=1
				\pgfmathfloatadd@{\pgfplots@error@src}{\pgfplots@error@coord}%
			\else
				\pgfmathfloatsubtract@{\pgfplots@error@src}{\pgfplots@error@coord}%
			\fi
			\let\pgfplots@error@coord=\pgfmathresult
		\or% fixed relative error:
			\pgfmathparse{(1#2\csname pgfplots@errorbars@#1rel\endcsname)}%
			\let\pgfplots@error@coord=\pgfmathresult
			\pgfmathfloatmultiplyfixed@{\pgfplots@error@src}{\pgfplots@error@coord}%
			\let\pgfplots@error@coord=\pgfmathresult
		\or% explicit absolute:
			\edef\pgfplots@error@coord{\csname pgfplots@error@#1arg\endcsname}%
			\ifx\pgfplots@error@coord\pgfutil@empty
			\else
				\pgfmathfloatparsenumber{\pgfplots@error@coord}%
				\let\pgfplots@error@coord=\pgfmathresult
				\ifnum#3=1
					\pgfmathfloatadd@{\pgfplots@error@src}{\pgfplots@error@coord}%
				\else
					\pgfmathfloatsubtract@{\pgfplots@error@src}{\pgfplots@error@coord}%
				\fi
				\let\pgfplots@error@coord=\pgfmathresult
			\fi
		\or% explicit relative:
			\edef\pgfplots@error@coord{\csname pgfplots@error@#1arg\endcsname}%
			\ifx\pgfplots@error@coord\pgfutil@empty
			\else
				\pgfmathparse{(1#2\pgfplots@error@coord)}%
				\let\pgfplots@error@coord=\pgfmathresult
				\pgfmathfloatmultiplyfixed@{\pgfplots@error@src}{\pgfplots@error@coord}%
				\let\pgfplots@error@coord=\pgfmathresult
			\fi
		\fi
	\else
		% LOGARITHMIC scaling. All errors are interpreted as 
		%   log(x +- e_x)
		% or
		%   log( x*(1+-e_x) )
		\ifcase\csname pgfplots@errorbars@#1mode\endcsname
			% fixed absolute, log( x +- e_x )
			\edef\pgfplots@error@src{\csname pgfplots@#1arg@unfiltered\endcsname}%
			\edef\pgfplots@error@coord{\csname pgfplots@errorbars@#1fixed\endcsname}%
			\pgfmathfloatparsenumber{\pgfplots@error@coord}%
			\let\pgfplots@error@coord=\pgfmathresult
			\pgfmathfloatparsenumber{\pgfplots@error@src}%
			\let\pgfplots@error@src=\pgfmathresult
			\ifnum#3=1
				\pgfmathfloatadd@{\pgfplots@error@src}{\pgfplots@error@coord}%
			\else
				\pgfmathfloatsubtract@{\pgfplots@error@src}{\pgfplots@error@coord}%
			\fi
			\pgfmathlog@float{\pgfmathresult}%
			\let\pgfplots@error@coord=\pgfmathresult
		\or% fixed relative, log( x ( 1+-e_x ) ) = log(x) + log(1+-e_x)
			\edef\pgfplots@error@src{\csname pgfplots@#1arg\endcsname}%
			\pgfmathparse{\pgfplots@error@src + ln(1#2\csname pgfplots@errorbars@#1rel\endcsname)}%
			\let\pgfplots@error@coord=\pgfmathresult%
		\or% explicit absolute
			\edef\pgfplots@error@src{\csname pgfplots@#1arg@unfiltered\endcsname}%
			\edef\pgfplots@error@coord{\csname pgfplots@error@#1arg\endcsname}%
			\ifx\pgfplots@error@coord\pgfutil@empty
			\else
				\pgfmathfloatparsenumber{\pgfplots@error@coord}%
				\let\pgfplots@error@coord=\pgfmathresult
				\pgfmathfloatparsenumber{\pgfplots@error@src}%
				\let\pgfplots@error@src=\pgfmathresult
				\ifnum#3=1
					\pgfmathfloatadd@{\pgfplots@error@src}{\pgfplots@error@coord}%
				\else
					\pgfmathfloatsubtract@{\pgfplots@error@src}{\pgfplots@error@coord}%
				\fi
				\pgfmathlog@float{\pgfmathresult}%
				\let\pgfplots@error@coord=\pgfmathresult
			\fi
		\or% explicit relative:
			\edef\pgfplots@error@src{\csname pgfplots@#1arg\endcsname}%
			\edef\pgfplots@error@coord{\csname pgfplots@error@#1arg\endcsname}%
			\ifx\pgfplots@error@coord\pgfutil@empty
			\else
				\pgfmathparse{\pgfplots@error@src + ln(1#2 \pgfplots@error@coord)}%
				\let\pgfplots@error@coord=\pgfmathresult%
			\fi
		\fi
	\fi
	\ifx\pgfplots@error@coord\pgfutil@empty
	\else
		\def\pgfplots@loc@TMPa{#1}%
		\def\pgfplots@loc@TMPb{x}%
		\ifx\pgfplots@loc@TMPa\pgfplots@loc@TMPb
			\let\pgfplots@current@point@x=\pgfplots@error@coord
			\let\pgfplots@current@point@y=\pgfplots@yarg
			\pgfplots@update@limits@for@one@point
			\edef\pgfplots@loc@TMPa{%
				{(\pgfplots@xarg,\pgfplots@yarg)}%
				{(\pgfplots@error@coord,\pgfplots@yarg)}%
			}%
		\else
			\let\pgfplots@current@point@x=\pgfplots@xarg
			\let\pgfplots@current@point@y=\pgfplots@error@coord
			\pgfplots@update@limits@for@one@point
			\edef\pgfplots@loc@TMPa{%
				{(\pgfplots@xarg,\pgfplots@yarg)}%
				{(\pgfplots@xarg,\pgfplots@error@coord)}%
			}%
		\fi
		\expandafter\pgfplots@streamerrorbarcoords\pgfplots@loc@TMPa
	\fi
}
% This routine is called at the begin of every plot.
% It initialised a zero level stream.
%
% The default is to use '0' as zero level streams.
%
% This method is called as "precommand"; before any Tikz drawing
% commands have been started.
\def\pgfplots@initzerolevelhandler{%
	\ifpgfplots@stackedmode
		% ATTENTION: this thing here says:
		%    "draw zero level coordinates from list XYZ."
		% But at the time of this initialisation, the list will be EMPTY!
		%
		% It will be filled later. That's ok, because 
		% \pgfplots@initzerolevelhandler will be
		% used as 'precommand', that means before Tikz sees any
		% coordinates.
		\pgfplots@stacked@initzerolevelhandler
	\else
		\pgfplotxzerolevelstreamconstant{\pgfplots@ZERO@x}%
		\pgfplotyzerolevelstreamconstant{\pgfplots@ZERO@y}%
	\fi
}

% This code is mainly interesting for bar plots.
%
% It precomputes x = 0 and y = 0 - which is not necessarily
% trivial in case of data scaling. Furthermore, it applies
% coordinate clipping to the resulting values and multiplies them
% with x- and y scale vectors.
\def\pgfplots@prepare@ZERO@coordinates{%
	\ifpgfplots@xislinear
		\ifpgfplots@apply@datatrafo@x
			\pgfplots@datascaletrafo@fromfixed@x{0}%
			\global\let\pgfplots@logical@ZERO@x=\pgfmathresult
		\else
			\gdef\pgfplots@logical@ZERO@x{0}%
		\fi
		\pgfplotsmathmax{\pgfplots@logical@ZERO@x}{\pgfplots@xmin}%
		\global\let\pgfplots@logical@ZERO@x=\pgfmathresult
	\else
		\global\let\pgfplots@logical@ZERO@x=\pgfplots@xmin%
	\fi
	%
	\ifpgfplots@yislinear
		\ifpgfplots@apply@datatrafo@y
			\pgfplots@datascaletrafo@fromfixed@y{0}%
			\global\let\pgfplots@logical@ZERO@y=\pgfmathresult
		\else
			\gdef\pgfplots@logical@ZERO@y{0}%
		\fi
		\pgfplotsmathmax{\pgfplots@logical@ZERO@y}{\pgfplots@ymin}%
		\global\let\pgfplots@logical@ZERO@y=\pgfmathresult
	\else
		\global\let\pgfplots@logical@ZERO@y=\pgfplots@ymin%
	\fi
	%
	\ifpgfplots@threedim
		\ifpgfplots@zislinear
			\ifpgfplots@apply@datatrafo@z
				\pgfplots@datascaletrafo@fromfixed@z{0}%
				\global\let\pgfplots@logical@ZERO@z=\pgfmathresult
			\else
				\gdef\pgfplots@logical@ZERO@z{0}%
			\fi
			\pgfplotsmathmax{\pgfplots@logical@ZERO@z}{\pgfplots@zmin}%
			\global\let\pgfplots@logical@ZERO@z=\pgfmathresult
		\else
			\global\let\pgfplots@logical@ZERO@z=\pgfplots@zmin%
		\fi
	\fi
	%
	%
	\pgfinterruptboundingbox%
	\ifpgfplots@threedim
		\pgfplotsqpointxyz{\pgfplots@logical@ZERO@x}{\pgfplots@logical@ZERO@y}{\pgfplots@logical@ZERO@z}%
	\else
		\pgfplotsqpointxy{\pgfplots@logical@ZERO@x}{\pgfplots@logical@ZERO@y}%
	\fi
	\xdef\pgfplots@ZERO@x{\the\pgf@x}%
	\xdef\pgfplots@ZERO@y{\the\pgf@y}%
	\endpgfinterruptboundingbox%
}%

