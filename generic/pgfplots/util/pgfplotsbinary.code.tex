%--------------------------------------------
% $Header: /cvsroot/pgfplots/pgfplots/generic/pgfplots/util/pgfplotsbinary.code.tex,v 1.11 2009/04/01 18:10:40 ludewich Exp $
%
% Package pgfplots
%
% Provides a user-friendly interface to create function plots (normal
% plots, semi-logplots and double-logplots).
% 
% It is based on Till Tantau's PGF package.
%
% Copyright 2007/2008 by Christian Feuers√§nger.
%
% This program is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program.  If not, see <http://www.gnu.org/licenses/>.
%
%--------------------------------------------

% This file provides a self-contained package which does only need
% pgfkeys.
%
% It provides a method to convert TeX numbers (integers and
% dimensions) into binary format (macros with catcode 12).
%

\edef\pgfplotsbinaryatcode{\the\catcode`\@ }
\catcode`\@=11

% this command loads the central implementation of this package into
% TeX memory and invokes '#1' afterwards.
% This idea is that '#1' contains code such that this 'lazy' check
% occurs just one time.
%
% No need to load the 256 additional macros in case they are never used.
\def\pgfplotsbinary@lazy@loadpackage{%
	\input pgfplotsbinary.def
}%

\def\pgfplotsbinary@apphighorderbytes@BIGENDIAN#1{\xdef\pgfplotsbinaryresult{#1\pgfplotsbinaryresult}}%
\def\pgfplotsbinary@apphighorderbytes@LITTLEENDIAN#1{\xdef\pgfplotsbinaryresult{\pgfplotsbinaryresult#1}}%

\def\pgfplotsbinaryencode@badic@unsigned@PAD@LITTLEENDIAN{%
	% pad with zeros:
	\ifcase\c@pgfplotsbin@byteno
		% ok.
	\or
		% one byte missing.
		\pgfplotsbinary@apphighorderbytes{\pgfplotsbinary@ZERO@HIGHEST}%
	\or
		% two bytes missing.
		\pgfplotsbinary@apphighorderbytes{\pgfplotsbinary@ZERO\pgfplotsbinary@ZERO@HIGHEST}%
	\or
		\pgfplotsbinary@apphighorderbytes{\pgfplotsbinary@ZERO\pgfplotsbinary@ZERO\pgfplotsbinary@ZERO@HIGHEST}%
	\or
		\pgfplotsbinary@apphighorderbytes{\pgfplotsbinary@ZERO\pgfplotsbinary@ZERO\pgfplotsbinary@ZERO\pgfplotsbinary@ZERO@HIGHEST}%
	\or
		\pgfplotsbinary@apphighorderbytes{\pgfplotsbinary@ZERO\pgfplotsbinary@ZERO\pgfplotsbinary@ZERO\pgfplotsbinary@ZERO\pgfplotsbinary@ZERO@HIGHEST}%
	\or
		\pgfplotsbinary@apphighorderbytes{\pgfplotsbinary@ZERO\pgfplotsbinary@ZERO\pgfplotsbinary@ZERO\pgfplotsbinary@ZERO\pgfplotsbinary@ZERO\pgfplotsbinary@ZERO@HIGHEST}%
	\or
		\pgfplotsbinary@apphighorderbytes{\pgfplotsbinary@ZERO\pgfplotsbinary@ZERO\pgfplotsbinary@ZERO\pgfplotsbinary@ZERO\pgfplotsbinary@ZERO\pgfplotsbinary@ZERO\pgfplotsbinary@ZERO@HIGHEST}%
	\or
		\pgfplotsbinary@apphighorderbytes{\pgfplotsbinary@ZERO\pgfplotsbinary@ZERO\pgfplotsbinary@ZERO\pgfplotsbinary@ZERO\pgfplotsbinary@ZERO\pgfplotsbinary@ZERO\pgfplotsbinary@ZERO\pgfplotsbinary@ZERO@HIGHEST}%
	\else
		\pgfplots@error{Sorry, I can't process byte no \the\c@pgfplotsbin@byteno... you may need to change bytes=\pgfplotsbinary@bytes.}%
	\fi
}%
\def\pgfplotsbinaryencode@badic@unsigned@PAD@BIGENDIAN{%
	% pad with zeros:
	\ifcase\c@pgfplotsbin@byteno
		% ok.
	\or
		% one byte missing.
		\pgfplotsbinary@apphighorderbytes{\pgfplotsbinary@ZERO@HIGHEST}%
	\or
		% two bytes missing.
		\pgfplotsbinary@apphighorderbytes{\pgfplotsbinary@ZERO@HIGHEST\pgfplotsbinary@ZERO}%
	\or
		\pgfplotsbinary@apphighorderbytes{\pgfplotsbinary@ZERO@HIGHEST\pgfplotsbinary@ZERO\pgfplotsbinary@ZERO}%
	\or
		\pgfplotsbinary@apphighorderbytes{\pgfplotsbinary@ZERO@HIGHEST\pgfplotsbinary@ZERO\pgfplotsbinary@ZERO\pgfplotsbinary@ZERO}%
	\or
		\pgfplotsbinary@apphighorderbytes{\pgfplotsbinary@ZERO@HIGHEST\pgfplotsbinary@ZERO\pgfplotsbinary@ZERO\pgfplotsbinary@ZERO\pgfplotsbinary@ZERO}%
	\or
		\pgfplotsbinary@apphighorderbytes{\pgfplotsbinary@ZERO@HIGHEST\pgfplotsbinary@ZERO\pgfplotsbinary@ZERO\pgfplotsbinary@ZERO\pgfplotsbinary@ZERO\pgfplotsbinary@ZERO}%
	\or
		\pgfplotsbinary@apphighorderbytes{\pgfplotsbinary@ZERO@HIGHEST\pgfplotsbinary@ZERO\pgfplotsbinary@ZERO\pgfplotsbinary@ZERO\pgfplotsbinary@ZERO\pgfplotsbinary@ZERO\pgfplotsbinary@ZERO}%
	\or
		\pgfplotsbinary@apphighorderbytes{\pgfplotsbinary@ZERO@HIGHEST\pgfplotsbinary@ZERO\pgfplotsbinary@ZERO\pgfplotsbinary@ZERO\pgfplotsbinary@ZERO\pgfplotsbinary@ZERO\pgfplotsbinary@ZERO\pgfplotsbinary@ZERO}%
	\else
		\pgfplots@error{Sorry, I can't process byte no \the\c@pgfplotsbin@byteno... you may need to change bytes=\pgfplotsbinary@bytes.}%
	\fi
}%

\expandafter\def\csname pgfplotsbinarysetbytes@1\endcsname{%
	\def\pgfplotsbinary@add@signed@largest@absolute{\advance\c@pgfplotsbin@input by 127 }%
	\def\pgfplotsbinary@dimen@scale{16909320}% ~= (2^31-1) /  (2^(8*1-1) -1)
}%
\expandafter\def\csname pgfplotsbinarysetbytes@2\endcsname{%
	\def\pgfplotsbinary@add@signed@largest@absolute{\advance\c@pgfplotsbin@input by 32767 }%
	\def\pgfplotsbinary@dimen@scale{65538}% ~= (2^31-1) /  (2^(8*2-1) -1)
}%
\expandafter\def\csname pgfplotsbinarysetbytes@3\endcsname{%
	\def\pgfplotsbinary@add@signed@largest@absolute{\advance\c@pgfplotsbin@input by 8388607 }%
	\def\pgfplotsbinary@dimen@scale{256}% ~= (2^31-1) /  (2^(8*3-1) -1)
}%
\expandafter\def\csname pgfplotsbinarysetbytes@4\endcsname{%
	\def\pgfplotsbinary@add@signed@largest@absolute{%
		\advance\c@pgfplotsbin@input by 2147483647 % this is the *absolute* largest int that TeX can handle.
	}%
	\def\pgfplotsbinary@dimen@scale{1}% ~= (2^31-1) /  (2^(8*4-1) -1)
}%
\def\pgfplotsbinarysetbytes@@{%
	\def\pgfplotsbinary@add@signed@largest@absolute{%
		\pgfplots@error{Sorry, but I can't perform \string\pgfplotsbinaryencodesignedmaplinearly\space for bytes=\pgfplotsbinary@bytes\space yet... bytes=4 is the maximum.}%
	}%
}%
\expandafter\let\csname pgfplotsbinary@bytes@5\endcsname=\pgfplotsbinarysetbytes@@
\expandafter\let\csname pgfplotsbinary@bytes@6\endcsname=\pgfplotsbinarysetbytes@@
\expandafter\let\csname pgfplotsbinary@bytes@7\endcsname=\pgfplotsbinarysetbytes@@
\expandafter\let\csname pgfplotsbinary@bytes@8\endcsname=\pgfplotsbinarysetbytes@@

\def\pgfplotsbinarysetbytes#1{%
	\pgfutil@ifundefined{pgfplotsbinarysetbytes@#1}{%
		\pgfplots@error{Sorry, I can't write binary output with '#1' bytes yet...}%
	}{%
		\def\pgfplotsbinary@bytes{#1}%
		\csname pgfplotsbinarysetbytes@#1\endcsname
	}%
}%

\pgfqkeys{/pgfplots/bin}{%
	bytes/.code={\pgfplotsbinarysetbytes{#1}},%
	bytes=4,
	% ordering not yet implemented; uses always BIG ENDIAN.
	ordering/.is choice,%
	ordering/big endian/.code={%
		\def\pgfplotsbinary@byteorder{0}%
		\let\pgfplotsbinary@apphighorderbytes=\pgfplotsbinary@apphighorderbytes@BIGENDIAN
		\let\pgfplotsbinaryencode@badic@unsigned@PAD=\pgfplotsbinaryencode@badic@unsigned@PAD@BIGENDIAN
	},%
	ordering/net/.style={/pgfplots/bin/ordering/big endian},%
	ordering/little endian/.code={%
		\def\pgfplotsbinary@byteorder{1}%
		\let\pgfplotsbinary@apphighorderbytes=\pgfplotsbinary@apphighorderbytes@LITTLEENDIAN
		\let\pgfplotsbinaryencode@badic@unsigned@PAD=\pgfplotsbinaryencode@badic@unsigned@PAD@LITTLEENDIAN
	},
	ordering/big endian,%
	%
	% Irreversibly change to VERBATIM output for debugging:
	debug mode/.code={%
		\let\pgfplotsbinary@apphighorderbytes@ORIG=\pgfplotsbinary@apphighorderbytes
		\def\pgfplotsbinary@ZERO{[Pad-0]}%
		\let\pgfplotsbinary@ZERO@HIGHEST=\pgfplotsbinary@ZERO
		\def\pgfplotsbinary@ZERO@LINEARMAP{[Pad-128]}%
		\def\pgfplotsbinary@apphighorderbytes##1{%
			\pgfutil@ifnextchar\csname{%
				\pgfplotsbinary@apphighorderbytes@DEBUG@csname
			}{%
				\pgfplotsbinary@apphighorderbytes@DEBUG@normal
			}%
			##1\relax
		}%
	},%
	% Write pdf objects in binary form:
	% debug to pdf={\pgfplotsbinaryencodeunsigned}{1,2,3,...,16}
	%
	% works only with pdftex
	debug to pdf/.code 2 args={%
		\foreach \num in {#2} {%
			#1{\num}%
			\immediate \pdfobj stream attr {
				/Decimal \num\space
				/Routine (\string#1)
			} {%
				\pgfplotsbinaryresult
			}%
		}%
	},%
}



\expandafter\let\expandafter\pgfplotsbinary@ZERO\csname pgfp@bin@0\endcsname
\expandafter\let\expandafter\pgfplotsbinary@ZERO@LINEARMAP\csname pgfp@bin@128\endcsname
\let\pgfplotsbinary@ZERO@HIGHEST=\pgfplotsbinary@ZERO
\let\pgfplotsbinary@hook=\relax

\def\pgfplotsbinary@hook@signed@linearmap{%
	\ifnum\c@pgfplotsbin@byteno=0
		\advance\c@pgfplotsbin@input by128
		\ifnum\c@pgfplotsbin@input>255
			\pgfplots@error{Sorry, there are not enough bytes to store the current number. I tried to write \the\c@pgfplotsbin@input...}%
		\fi
	\fi
}%

\def\pgfplotsbinary@apphighorderbytes@DEBUG@csname \csname pgfp@bin@#1\endcsname\relax{%
	\pgfplotsbinary@apphighorderbytes@ORIG{[#1]}%
}%
\def\pgfplotsbinary@apphighorderbytes@DEBUG@normal#1\relax{%
	\pgfplotsbinary@apphighorderbytes@ORIG{#1}%
}%

%\pgfkeys{/pgfplots/bin/debug mode}


\countdef\c@pgfplotsbin@input=0
\countdef\c@pgfplotsbin@tmpa=1
\countdef\c@pgfplotsbin@tmpb=2
\countdef\c@pgfplotsbin@byteno=3
\def\pgfplotsbinaryempty{}

%--------------------------------------------------
% input:    unsigned int x, b, n;
% output:   unsigned int y[n];
% for (i=0; i<n; i++) y[i] = 0;
% i=0;
% while (x > 0)
% { y[i] = x % b; /* entspricht x mod b   */
%  x = x / b;    /* ganzzahlige Division */
%  i++;
%  }
%-------------------------------------------------- 
% with x = #1
% b = 256
% will store stuff into \pgfplotsbinaryresult in binary format
%
% PRECONDITION:
% - \pgfplotsbinaryresult= empty!
% - \c@pgfplotsbin@byteno=\pgfplotsbinary@bytes
\def\pgfplotsbinaryencode@badic@unsigned@{%
	% this implementation is invoked one time.
	% Afterwards, only \pgfplotsbinaryencode@badic@unsigned@@ will be
	% used. This saves TeX memory.
	\pgfplotsbinary@lazy@loadpackage
	\global\let\pgfplotsbinaryencode@badic@unsigned@=\pgfplotsbinaryencode@badic@unsigned@@%
	\pgfplotsbinaryencode@badic@unsigned@
}%
\def\pgfplotsbinaryencode@badic@unsigned@@{%
	\ifnum\c@pgfplotsbin@input>0
		\c@pgfplotsbin@tmpa=\c@pgfplotsbin@input
		\divide\c@pgfplotsbin@tmpa by256
		\c@pgfplotsbin@tmpb=\c@pgfplotsbin@tmpa\relax
		\multiply\c@pgfplotsbin@tmpa by256
		\advance\c@pgfplotsbin@input by -\c@pgfplotsbin@tmpa\relax
		\advance\c@pgfplotsbin@byteno by-1
		\pgfplotsbinary@hook% hooks for modifications.
		\pgfplotsbinary@apphighorderbytes{\csname pgfp@bin@\the\c@pgfplotsbin@input\endcsname}%
		\c@pgfplotsbin@input=\c@pgfplotsbin@tmpb
%\message{RESULT SO FAR byte no \the\c@pgfplotsbin@byteno: \pgfplotsbinaryresult}%
		\expandafter\pgfplotsbinaryencode@badic@unsigned@
	\else
		\pgfplotsbinaryencode@badic@unsigned@PAD
%\message{RESULT SO FAR byte no \the\c@pgfplotsbin@byteno: \pgfplotsbinaryresult}%
	\fi
}%


% Defines \pgfplotsbinaryresult to be the binary representation of an
% unsigned integer.
%
% The representation will use unsigned dual number representation.
%
% The assignment to \pgfplotsbinaryresult will be globally.
% #1: an unsigned integer .
%
% FIXME : fix  > 2^30
\def\pgfplotsbinaryencodeunsigned#1{%
	\begingroup
	\global\let\pgfplotsbinaryresult=\pgfplotsbinaryempty
	\c@pgfplotsbin@input=#1 %
	\c@pgfplotsbin@byteno=\pgfplotsbinary@bytes\relax
	\pgfplotsbinaryencode@badic@unsigned@%
	\endgroup
}%

% An implementation for signed integers which maps the signed integer linearly into 
% the unsigned data range before it proceeds.
%
% The idea is thus, to first introduce a linear mapping
%
% phi : [- smallest_possible, +largest_possible ] -> [0, 256^bytes-1 ]
%
% A signed integer in TeX is in [ - (2^31-1), 2^31-1 ].
% Thus, we should map
%
% phi : [  -(2^31-1), 2^31-1 ] -> [ 0, 2^32-1 ].
%
% A simpler case is to employ the symmetry in TeX's registers and
% leave one out, i.e. to map to 2^32-2:
%
% phi : [  -(2^31-1), 2^31-1 ] -> [ 0, 2^32-2 ].
%
% Then,
%
% phi(x) = ( x + 2^31 -1 ) / (2^31-1 + 2^31-1) * (2^32-2) = x+ 2^31-1.
%
% The same map phi(x) = x + 2^31 -1 whith target space  [0, 2^32-1 ]
% could be realized with the input space [- (2^31-1), 2^31 ].
%
% I am using this encoding procedure, phi(x) = x + 2^31 -1.
%
% As a consequence, the binary pattern FF FF FF FF does never occur as
% result of the mapping.
%
% To invert the mapping (i.e. to decode the result), set up the unique
% linear map
%
% psi : [ 0, 2^32-1 ] -> [ -(2^31-1), 2^31 ].
%
% Then, psi( phi(x) ) = x and the decoding procedure is correct.
%
% This doesn't need TeX register arithmetics on the whole range.
%
% ATTENTION: only bytes=4 is implemented for this technique currently!
\def\pgfplotsbinaryencodesignedmaplinearly#1{%
	\begingroup
	\global\let\pgfplotsbinaryresult=\pgfplotsbinaryempty
	\c@pgfplotsbin@input=#1 %
	\c@pgfplotsbin@byteno=\pgfplotsbinary@bytes\relax
	\ifnum\c@pgfplotsbin@input<0
		% compute + 2^31 - 1
		\pgfplotsbinary@add@signed@largest@absolute
	\else
		% change zero padding such that positive numbers
		% to get the effect of + 2^31.
		\let\pgfplotsbinary@ZERO@HIGHEST=\pgfplotsbinary@ZERO@LINEARMAP
		\let\pgfplotsbinary@hook=\pgfplotsbinary@hook@signed@linearmap
		% and compute the -1 explicitly here:
		\advance\c@pgfplotsbin@input by-1
	\fi
	\pgfplotsbinaryencode@badic@unsigned@%
	\endgroup
}%


% Encodes a dimen (like 1pt or \dimen0) in binary form.
%
% The encoding works by mapping #1 linearly into the allowed integer
% range using a quantization technique to respect the (possibly)
% restricted number of bytes.
%
% The implementation is very fast and uses only integer arithmetics.
% It relies on \pgfplotsbinaryencodesignedmaplinearly and a scale.
%
% So, what we do is to setup a linear map into binary range with k
% bytes. The range of a TeX dimen is precisely (in units of pt)
%  [ -(2^30-1) / 2^16, (2^30 -1) / 2^16 ] = [-16383.99998, 16383.99998]
%
% Thus, for an input dimen x, we set up the mapping
% 	phi(x) = 2^16 * x * 2
% which maps 
%  phi: [ -(2^30-1) / 2^16, (2^30-1) / 2^16 ] -> [-(2^31 -2), 2^31-2].
%
% I simply use the \pgfplotsbinaryencodesignedmaplinearly to process
% this further. Do simplify the computation, I simply compute
%   phi_signed( phi(x) ), 
% where phi_signed denotes an application of
% \pgfplotsbinaryencodesignedmaplinearly:
%   phi_signed( y ) = y +2^31 -1,
%   phi_signed( phi(x) ) = 2^16 * 2 * x + 2^31 - 1.
% This is NOT a linear map to [0,2^32-1] as promised. 
% But, we can setup an inverse transformation PHI (which is linear) anyway
% such that
%   PHI( phi_signed(phi(x)) ) = x
% and that's all I want. Do do that, we use the unique linear decoder map 
%   PHI : [ 0,2^32-1 ] -> [ -16383.999992, 16384 ].
%
% This is not exacty the input range of before, but using it results
% in a proper decoder. The difference is due to the non-unique zero
% representation in TeX's arithmetics.
% 
%
% ATTENTION: only bytes=4 is implemented for this technique currently!
	%
	%% DEBUG NOTE: This mapping appears to work correctly according to
	%% my tests.
	%% For bc -l test codes: 
	%% ibase=16; 
	%% -4000 +  809658FA. / (2^20) * 8000
\def\pgfplotsbinaryencodedimenmaplinearly#1{%
	\begingroup
	\dimen0=#1\relax
	\c@pgfplotsbin@input=\dimen0
	\multiply\c@pgfplotsbin@input by2
%	\divide\c@pgfplotsbin@input by\pgfplotsbinary@dimen@scale\relax
%\message{LOWLEVEL ENCODING '\the\c@pgfplotsbin@input' with linear map}%
	\pgfplotsbinaryencodesignedmaplinearly\c@pgfplotsbin@input
	\endgroup
}%

\catcode`\@=\pgfplotsbinaryatcode
\endinput
