%--------------------------------------------
%
% Package pgfplots
%
% Provides a user-friendly interface to create function plots (normal
% plots, semi-logplots and double-logplots).
% 
% It is based on Till Tantau's PGF package.
%
% Copyright 2007/2008 by Christian Feuers√§nger.
%
% This program is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program.  If not, see <http://www.gnu.org/licenses/>.
%
%--------------------------------------------

\def\pgfplots@error#1{\PackageError{pgfplots}{#1}{}}%
\def\pgfplots@warning#1{\pgfplots@message{! Package pgfplots Warning: #1}}%
\def\pgfplots@message#1{%
	\immediate\write16{#1}%
}%


\pgfutil@ifundefined{pgfkeys}{%
	\pgfplots@error{It seems your version of PGF/Tikz is older than 2.00. Unfortunately, pgfplots requires at least version 2.00 ... you may need to update your TeX-Distribution or install PGF manually, sorry}%
}{\relax}

\def\pgfplots@EOI{\pgfplots@EOI}%

\newif\ifpgfplots@loc@tmp
\newtoks\t@pgfplots@toka
\newtoks\t@pgfplots@tokb
\newtoks\t@pgfplots@tokc
\newdimen\pgfplots@tmpa

% use these macros for GLOBAL temporary assignments.
% you can NEVER rely on their values unless you know exactly what you are doing.
\gdef\pgfplots@glob@TMPa{}%
\gdef\pgfplots@glob@TMPb{}%
\gdef\pgfplots@glob@TMPc{}%

% use these macros for LOCAL temporary assigments.
% you can NEVER rely on their values unless you know exactly what you are doing.
\def\pgfplots@loc@TMPa{}%
\def\pgfplots@loc@TMPb{}%
\def\pgfplots@loc@TMPc{}%

% Produces an \aftergroup statement for each single token in #1.
%
% ATTENTION: you *can't* use braces inside of '#1'!
\def\pgfplotsqaftergroupeach#1{%
	\pgfplotsqaftergroupeach@#1\pgfplots@EOI
}
\def\pgfplotsqaftergroupeach@#1{%
	\gdef\pgfplots@TMP{#1}%
	\ifx\pgfplots@TMP\pgfplots@EOI
	\else
		\aftergroup#1%
		\expandafter\pgfplotsqaftergroupeach@
	\fi
}

\def\pgfplotsaftergroupcollectinto#1#2\pgfplots@EOI{%
	\def#1{#2}%
}%

% Assigns list contents #2 to a list macro #1.
%
% The list contents may be provided in one of two formats:
% a) in the (deprecated) list format 'first\\second\\thirst\\'
% or
% b) in the PGF foreach list format 'first,second,third'.
\def\pgfplots@assign@list#1#2{%
	\def\pgfplots@TMP{#2}%
	\ifx\pgfplots@TMP\pgfutil@empty
		\pgfplotslistnewempty#1%
	\else
		\pgfplots@check@backwards@compatible@list@format #2\\\pgfplots@EOI
		\ifpgfplots@is@old@list@format
			\pgfplotslistnew#1{#2}%
		\else
			\pgfplots@foreach@to@list{#2}\to#1
		\fi
	\fi
}%

% Sets the boolean \ifpgfplots@is@old@list@format  to true if and only
% if the input is a list in the format '{first\\second\\}'.
%
% This format is deprecated, but is still provided for backwards
% compatibility.
%
% Usage:
% \pgfplots@check@backwards@compatible@list@format <argument>'\\'\pgfplots@EOI
% you NEED to append '\\\pgfplots@EOI' at the end.
\def\pgfplots@check@backwards@compatible@list@format#1\\#2\pgfplots@EOI{%
	\def\pgfplots@TMP{#2}%
	\ifx\pgfplots@TMP\pgfutil@empty
		\pgfplots@is@old@list@formatfalse
	\else
		\pgfplots@is@old@list@formattrue
	\fi
}%

% Issues an error message if the **LaTeX** package '#1' is not loaded
% (An error is also raised if the document is not a LaTeX document).
% #1: the required LaTeX package
% #2: the feature which requires this package
\def\pgfplots@assert@LaTeX@package@loaded#1#2{%
	\pgfutil@ifundefined{@ifpackageloaded}{%
		\pgfplots@error{Sorry, #2 only works with LaTeX (it relies on the LaTeX package #1)}%
	}{%
		\pgfutil@ifundefined{ver@#1.sty}% this here has been extracted from ltclass.dtx. \@ifpackageloaded is only usable in preamble.
			{\pgfplots@error{Sorry, use need \string\usepackage{#1} in your preamble for '#2'}}%
			{\relax}%
	}%
}%
\def\pgfplots@assert@tikzinternal@exists#1{%
	\pgfutil@ifundefined{#1}{%
		\pgfplots@error{Sorry, pgfplots relies on the existance of the tikz internal macro '#1'.
		 Unfortunately, this does no longer exist ... you will need to get an updated version of pgfplots to fix this problem.}%
		\expandafter\let\csname #1\endcsname=\pgfutil@empty
	}{}%
}%


% A future-version compatibility method which checks whether the
% macro '#2' exists.
%
% We assume that '#2' usually contains the value of the tikz key '#1'.
% Example:
% /tikz/variable is usually stored into '\tikz@plot@var'.
%
% However, this may change in future versions.
%
% So, we do the following:
% 1. check whether '#2' exists, if yet: ok.
% 2. if not, check whether the value is stored directly into '/tikz/#1'.
% 3. if not, check whether the value is stored directly into '/pgf/#1'.
% 4. If everything fails, provide an error message.
%
% #1: a tikz key without key prefix (/tikz/ and /pgf/ will be prepended).
% #2: a macro name WITHOUT backslash.
% #3: the default value if everything fails.
\def\pgfplots@gettikzinternal@keyval#1#2#3{%
	\pgfutil@ifundefined{#2}{%
		\pgfkeysifdefined{/tikz/#1}{%
			\pgfkeysgetvalue{/tikz/#1}\pgfplots@TMP
			\expandafter\let\csname #1\endcsname=\pgfplots@TMP
		}{%
			\pgfkeysifdefined{/pgf/#1}{%
				\pgfkeysgetvalue{/pgf/#1}\pgfplots@TMP
				\expandafter\let\csname #1\endcsname=\pgfplots@TMP
			}{%
				\expandafter\def\csname #1\endcsname{#3}%
				{\t@pgfplots@tokc={#3}%
				\pgfplots@warning{Sorry, could not find value of '/tikz/#1'. Assuming '\the\t@pgfplots@tokc'.}%
				}%
			}%
		}%
	}{}%
}%

\def\pgfplots@getcurrent@plothandler#1{%
	\pgfutil@ifundefined{tikz@plot@handler}{%
		\pgfplots@error{Sorry, can't get the current plot handler. It appears that tikz and pgfplots is no longer compatible!? You will need to get a newer version of pgfplots.}%
		\let#1=\pgfplothandlerlineto
	}{%
		\let#1=\tikz@plot@handler
	}%
}%


% Converts an arbitrary command to a string in which all characters
% have category 12.
%
% #1: a macro name (which takes no arguments)
% #2: a macro name which will be assigned to '#1' converted to string.
%
% This uses '\meaning#1' hackery.
\def\pgfplots@command@to@string#1#2{%
	\expandafter\pgfplots@command@to@string@@\meaning#1\pgfplots@EOI{#2}%
}%
{
\let\CATCODE=\catcode
\CATCODE`\:=12
\CATCODE`\-=12
\CATCODE`\>=12
\CATCODE`\m=12
\CATCODE`\a=12
\CATCODE`\c=12
\CATCODE`\r=12
\CATCODE`\o=12
\xdef\pgfplts@glb@TMP{macro:->}%
}
\expandafter\def\expandafter\pgfplots@command@to@string@@\pgfplts@glb@TMP#1\pgfplots@EOI#2{%
	\def#2{#1}%
}%

{
\catcode`\%=12
\gdef\pgfplots@PERCENT@TEXT{%}
}

% Usage:
% \pgfplots@if{pgfplots@scaled@ticks}{true-code}{false-code}
%
% it is to be used if the tex boolean is only known as string, not as
% macro.
\def\pgfplots@if#1#2#3{%
	\csname if#1\endcsname
		#2%
	\else
		#3%
	\fi
}%

\def\pgfplotsmathmin#1#2{%
	\ifdim#1 pt<#2 pt
		\edef\pgfmathresult{#1}%
	\else
		\edef\pgfmathresult{#2}%
	\fi
}%
\def\pgfplotsmathmax#1#2{%
	\ifdim#1 pt>#2 pt
		\edef\pgfmathresult{#1}%
	\else
		\edef\pgfmathresult{#2}%
	\fi
}%
\def\pgfplotsmathlessthan#1#2{\ifdim#1 pt<#2 pt \pgfmathfloatcomparisontrue\else\pgfmathfloatcomparisonfalse\fi}

% Defines \pgfmathresult to be #1 * 10^{#2}.
%
% #1 a macro without unit suffix.
% #2 an integer number (may be a register)
\def\pgfplotsmathmultiplypowten@#1#2{%
	\begingroup
	\pgf@xa=#1pt
	\ifnum#2<0
		\ifcase-#2
		\or\divide\pgf@xa by10
		\or\divide\pgf@xa by100
		\or\divide\pgf@xa by1000
		\or\divide\pgf@xa by10000
		\or\divide\pgf@xa by100000
		\fi
	\else
		\ifcase#2
		\or\multiply\pgf@xa by10
		\or\multiply\pgf@xa by100
		\or\multiply\pgf@xa by1000
		\or\multiply\pgf@xa by10000
		\or\multiply\pgf@xa by100000
		\fi
	\fi
	\edef\pgfmathresult{\pgf@sys@tonumber{\pgf@xa}}%
	\pgfmath@smuggleone\pgfmathresult
	\endgroup
}%


% converts a comma-separated list (PGF foreach)  to my internal list
% structure.
\long\def\pgfplots@foreach@to@list#1\to#2{%
	\global\pgfplotslistnewempty\pgfplots@glob@TMPa
	\begingroup
	\foreach \pgfplots@i in {#1} {%
		\expandafter\pgfplotslistpushbackglobal\pgfplots@i\to\pgfplots@glob@TMPa
	}%
	\endgroup
	\pgfplotslistcopy\pgfplots@glob@TMPa\to#2\relax
}

% Simply invokes the code of PGF key #1 with value #2, that means
% #1#2\pgfeov
\def\pgfplots@invoke@pgfkeyscode#1#2{%
	\pgfkeysgetvalue{#1}\pgfplots@invoke@pgfkeyscode@CODE
	\pgfplots@invoke@pgfkeyscode@CODE#2\pgfeov
}


% Usage:
% \pgfplots@letcsname pgfplots@xtick={pgfplots@kram@x}
% -> invokes \csname ... \endcsname for both args.
\def\pgfplots@letcsname#1=#2{%
	\expandafter\let\expandafter\pgfplots@loc@TMPc\csname #2\endcsname
	\expandafter\let\csname #1\endcsname=\pgfplots@loc@TMPc
}%

% I have introduced this macro to allow optimizations of (x,y)
% coordinate processing. Use it for everything which is directly plot
% related.
%
% @see \pgfplotsqpointxy@orthogonal
\let\pgfplotsqpointxy=\pgfqpointxy
\let\pgfplotsqpointxyz=\pgfqpointxyz

% A "quick" quick variant of \pgfqpointxy which assumes that 
% the X unit vector is ( e_xx,0 )^T  and the Y unit vector is ( 0,
% e_yy)^T.
%
% In words, the unit vectors are orthogonal. This is the usual case
% for two-dimensional plots and shall be optimized.
\def\pgfplotsqpointxy@orthogonal#1#2{%
	\pgf@x=#1\pgf@xx%
	\pgf@y=#2\pgf@yy}


% Takes a domain as input and generates a foreach argument which
% samples from the domain.
% Writes the result to \pgfplotslocretval
\def\pgfplots@domain@to@foreach#1:#2\relax{%
	\pgfplots@gettikzinternal@keyval{samples}{tikz@plot@samples}{25}%
	\pgfmathparse{#1}%
	\let\pgfplots@loc@TMPa=\pgfmathresult%
	\pgfmathparse{#2}%
	\let\pgfplots@loc@TMPb=\pgfmathresult%
	\pgfmathparse{\pgfplots@loc@TMPa+(\pgfplots@loc@TMPb-\pgfplots@loc@TMPa)/\tikz@plot@samples}%
	\edef\pgfplotslocretval{\pgfplots@loc@TMPa,\pgfmathresult,...,\pgfplots@loc@TMPb}%
}

{
	\catcode`\;=\active
	\catcode`\:=\active
	\gdef\pgfplots@activesemicolon{;}%
	\gdef\pgfplots@activecolon{:}%
}

% checks whether ';' is active and replaces a sequence of commands
% accordingly.
%
% @see \pgfplots@appendto@activesemicolon@switcher
\def\pgfplots@checkandpreparefor@active@semicolon{%
	\ifnum\the\catcode`\;=\active\relax
		\pgfplots@checkandpreparefor@active@semicolon@
	\fi
}%
\def\pgfplots@checkandpreparefor@active@semicolon@{}%

% Adds all commands '#1' to the sequence of commands which will be
% issued in case ';' is active.
\def\pgfplots@appendto@activesemicolon@switcher#1{%
	\expandafter\def\expandafter\pgfplots@checkandpreparefor@active@semicolon@\expandafter{%
		\pgfplots@checkandpreparefor@active@semicolon@
		#1%
	}%
}%


% Usage:
% \pgfplotsforeachentryinCSV{\value}{1,2,3,4.5,6.7,10}{The value is \value\par}
%
% The loop is ungrouped.
\long\def\pgfplotsforeachentryinCSV#1#2#3{%
	\def\pgfplotsforeachentryinCSV@{#1}%
	\long\def\pgfplotsforeachentryinCSV@@{#3}%
	\pgfplotsforeachentryinCSV@loop#2,\pgfplots@EOI
}%
% A variant of \pgfplotsforeachentryinCSV where a trailing comma
% indicates the end of input.
% Example:
%
% \pgfplotsforeachentryinCSV{\value}{1,2,3,4.5,6.7,10,}{The value is \value\par}
%                                                    ^
%
% It is permissable to provide an empty list (without trailing comma)
\long\def\pgfplotsforeachentryinCSVisterminated#1#2#3{%
	\def\pgfplotsforeachentryinCSV@{#1}%
	\long\def\pgfplotsforeachentryinCSV@@{#3}%
	\pgfplotsforeachentryinCSV@loop#2\pgfplots@EOI
}%
\def\pgfplotsforeachentryinCSV@loop{%
	\pgfutil@ifnextchar\pgfplots@EOI{%
		\pgfutil@gobble
	}{%
		\pgfplotsforeachentryinCSV@next
	}%
}%
\def\pgfplotsforeachentryinCSV@next#1,{%
	\expandafter\def\pgfplotsforeachentryinCSV@{#1}%
	\pgfplotsforeachentryinCSV@@
	\pgfplotsforeachentryinCSV@loop
}%


% A (simple) replacement for \foreach which 
% 1. does NOT scope the argument
% 2. allows to use PGF Math routines for loops ( '...' notation)
% instead of TeX registers.
%
% Usage:
% \pgfplotsforeachungrouped \x in {1,2,3,4,5} {<code>}
% 
% Some details:
% - If #2 is a UNIFORM SAMPLING RANGE, the algorithm is supposed to be
%   most effective.
% - If \pgfmathadd@ is the standard PGF math version of \pgfmathadd@,
%   we use fast TeX dimensions for any loops. Otherwise, \pgfmathadd@
%   is used (assuming it has been replaced and should be used.
%
\def\pgfplotsforeachungrouped#1{\pgfplotsforeachungrouped@{#1}}%
\long\def\pgfplotsforeachungrouped@#1in #2#3{%
	\pgfplotsforeachungrouped@isuniform{#2}%
	\ifpgfplots@loc@tmp
		\pgfplotsforeachungroupeduniform@#1{#2}{#3}%
	\else
		\pgfplotsforeachungroupednonuniform@#1{#2}{#3}%
	\fi
}
\let\pgfplots@original@pgfmathadd@=\pgfmathadd@

\long\def\pgfplotsforeachungroupeduniform@#1#2#3{%
	\pgfplotsforeachungroupeduniform@@{#1}#2\relax{#3}%
}
\long\def\pgfplotsforeachungroupeduniform@@#1#2,#3,...,#4\relax#5{%
	% Compute mesh width!
	\pgfmathparse{#2}%
	\let\pgfplots@foreach@loc@TMPa=\pgfmathresult
	\pgfmathparse{#3}%
	\let\pgfplots@foreach@loc@TMPb=\pgfmathresult
	\pgfmathsubtract@{\pgfplots@foreach@loc@TMPb}{\pgfplots@foreach@loc@TMPa}%
	\ifx\pgfmathadd@\pgfplots@original@pgfmathadd@
		% perform manual restoration of local variables:
		\edef\pgfplots@foreach@loc@TMPd{%
			\noexpand\pgf@xa=\the\pgf@xa\noexpand\relax
			\noexpand\pgf@xb=\the\pgf@xb\noexpand\relax
			\noexpand\pgf@ya=\the\pgf@ya\noexpand\relax
		}%
		% mesh width:
		\pgf@ya=\pgfmathresult pt
		% the loop will run while ( NOT <cur> \pgfplots@foreach@loc@cmp  <last> )
		\ifdim\pgf@ya<0pt
			\def\pgfplots@foreach@loc@cmp{<}%
		\else
			\def\pgfplots@foreach@loc@cmp{>}%
		\fi
		%
		\pgfmathparse{#4}%
		\let\pgfplots@foreach@loc@TMPb=\pgfmathresult
		\pgf@xa=\pgfplots@foreach@loc@TMPa pt
		\pgf@xb=\pgfplots@foreach@loc@TMPb pt
		\long\def\pgfplots@foreach@loc@TMPc{#5}%
		%
		\pgfutil@loop
		\ifdim\pgf@xa \pgfplots@foreach@loc@cmp \pgf@xb\relax
			\pgfplots@loc@tmpfalse
		\else
			\pgfplots@loc@tmptrue
		\fi
		\ifpgfplots@loc@tmp
			\edef#1{\pgf@sys@tonumber{\pgf@xa}}%
			\pgfplots@foreach@loc@TMPc\relax
			\advance\pgf@xa by\pgf@ya\relax
		\pgfutil@repeat
		% ok, restore them:
		\pgfplots@foreach@loc@TMPd
	\else
		% Use \pgfmath engine for the loop:
		\edef\pgfplots@foreach@loc@TMPd{%
			\noexpand\pgf@xa=\the\pgf@xa\noexpand\relax
		}%
		% mesh width:
		\let\pgfplots@foreach@loc@meshwidth=\pgfmathresult
		\pgfmathlessthan@{\pgfplots@foreach@loc@meshwidth}{0}%
		\pgf@xa=\pgfmathresult pt
		% the loop will run while ( NOT \pgfplots@foreach@loc@cmp{<cur>}{<last>} )
		\ifdim\pgf@xa=1pt
			\let\pgfplots@foreach@loc@cmp=\pgfmathlessthan@
		\else
			\let\pgfplots@foreach@loc@cmp=\pgfmathgreaterthan@
		\fi
		%
		\pgfmathparse{#4}%
		\let\pgfplots@foreach@loc@TMPb=\pgfmathresult
		\long\def\pgfplots@foreach@loc@TMPc{#5}%
		%
		\pgfutil@loop
		\pgfplots@foreach@loc@cmp{\pgfplots@foreach@loc@TMPa}{\pgfplots@foreach@loc@TMPb}%
		\pgf@xa=\pgfmathresult pt
		\ifdim\pgf@xa=0pt
			\let#1=\pgfplots@foreach@loc@TMPa%
			\pgfplots@foreach@loc@TMPc\relax
			\pgfmathadd@{\pgfplots@foreach@loc@TMPa}{\pgfplots@foreach@loc@meshwidth}%
			\let\pgfplots@foreach@loc@TMPa=\pgfmathresult
		\pgfutil@repeat
		% ok, restore them:
		\pgfplots@foreach@loc@TMPd
	\fi
}%
\long\def\pgfplotsforeachungroupednonuniform@#1#2#3{%
	\pgfplotsapplistXXglobalnewempty
	\foreach\pgfplots@foreach@loc@TMPa in {#2} {%
		\expandafter\pgfplotsapplistXXglobalpushback\expandafter{\pgfplots@foreach@loc@TMPa,}%
	}%
	\pgfplotsapplistXXgloballet\pgfplots@foreach@loc@TMPa
	\pgfplotsapplistXXglobalclear
	\expandafter\pgfplotsforeachentryinCSVisterminated\expandafter\pgfplots@foreach@loc@TMPa\expandafter{\pgfplots@foreach@loc@TMPa}{%
		\let#1=\pgfplots@foreach@loc@TMPa
		#3%
	}%
}

% Sets \ifpgfplots@loc@tmp to something true if and only if '#1' is of the form
% #1 = <number1>,<number2>,...,<number3>.
\def\pgfplotsforeachungrouped@isuniform#1{%
	\edef\pgfplots@foreach@loc@TMPa{#1}%
	\expandafter\pgfplotsforeachungrouped@isuniform@\pgfplots@foreach@loc@TMPa,,,,\relax
}%
\def\pgfplotsforeachungrouped@isuniform@#1,#2,#3,#4,#5\relax{%
	\def\pgfplots@foreach@loc@TMPa{#5}%
	\def\pgfplots@foreach@loc@TMPb{,,,}%
	\pgfplots@loc@tmpfalse
	\ifx\pgfplots@foreach@loc@TMPa\pgfplots@foreach@loc@TMPb
		\def\pgfplots@foreach@loc@TMPa{#3}%
		\def\pgfplots@foreach@loc@TMPb{...}%
		\ifx\pgfplots@foreach@loc@TMPa\pgfplots@foreach@loc@TMPb
			\pgfutil@in@,{#4}%
			\ifpgfutil@in@
			\else
				% ok, we REALLY have a uniform range!
				\pgfplots@loc@tmptrue
			\fi
		\fi
	\fi
}%

\input pgfplotsliststructure.code.tex
\input pgfplotsliststructureext.code.tex
\input pgfplotsarray.code.tex
\input pgfplotstable.code.tex

\endinput
