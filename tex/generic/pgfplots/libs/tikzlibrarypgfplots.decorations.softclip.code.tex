%--------------------------------------------
%
% Package pgfplots
%
% Provides a user-friendly interface to create function plots (normal
% plots, semi-logplots and double-logplots).
% 
% It is based on Till Tantau's PGF package.
%
% Copyright 2013 by Christian Feuersaenger
%
% This program is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program.  If not, see <http://www.gnu.org/licenses/>.
%
%--------------------------------------------
%
% This library adds support for a "soft clip" decoration. It applies
% clipping to an input path, but rather than simply instructing the
% display driver to clip the path, it computes a new clip path from
% the input.

\usetikzlibrary{intersections}

\pgfplots@iffileexists{pgflibraryfillbetween.code.tex}{%
	\usepgflibrary{fillbetween}
}{%
	\pgfplotsusecompatibilityfile{pgflibraryfillbetween.code.tex}%
}%

\pgfutil@IfUndefined{pgfintersectiongetsolutiontimes}{%
	\pgfplotsusecompatibilityfile{pgflibraryintersections.code.tex}%
}{}%


\pgfkeys{
	% soft clip={(axis cs:0,0) rectangle (axis cs:1,1)}
	/pgf/decoration/soft clip path/.code={%
		\pgfplotslibfillbetween@softclip{d}#1\pgfplots@EOI
	},
}
\let\pgf@decoration@soft@clip=\pgfutil@empty
\pgfdeclaredecoration{soft clip}{replace}{

	\state{replace}[width=\pgfdecoratedpathlength]{%
		\pgfpathcomputesoftclippath{\pgfdecoratedpath}{\pgf@decoration@soft@clip}%
		\pgfsetpath{\pgfretval}%
	}
}

% ---------------------------------------------------------------------------------
%
%  SOFT-CLIPPING.
%
%  "softclip" means to get rid of those parts of a path which are
%  outside of a clip path. 
%
%  An example is to trim at the beginning and/or end of a
%  path as part of fill-between ("poor-mans-clipping").
%
%  The difference to "real" clipping is that it is applied to the
%  path, not to the viewer -- the path can still be drawn with any
%  decorations, line widths, etc.
%
%  Another difference is that this feature is (considerably) less sophisticated.
%
%  #1: the input path
%  #2: the clip path (if it is empty, no clipping will be applied)
% OUTPUT:
%  \pgfretval is #1 with modifications
\def\pgfpathcomputesoftclippath#1#2{%
	\ifx#2\pgfutil@empty
		\let\pgfretval=#1%
	\else
		\begingroup
		\pgfprocessround{#1}{#1}%
		\pgfprocessround{#2}{#2}%
		%
		%
		\pgfpathcomputesoftclippath@is@first@outside@of@path{#1}{#2}%
		\let\b@pgffill@is@outside@clip=\pgfretval
		%
%\message{computing soft clip path for ^^J\meaning#1 and ^^J\meaning#2^^J  first point of input is outside of clip path=\b@pgffill@is@outside@clip^^J}%
		%
		\pgf@intersect@sortfalse
		\pgfintersectionofpaths%
			{%
				\pgfsetpath#1%
			}%
			{%
				\pgfsetpath#2%
			}%
		%
		%
		\ifnum\pgfintersectionsolutions=0 %
			\if1\b@pgffill@is@outside@clip
				% entiry path is outside of the clipped area.
				\let\pgfretval=\pgfutil@empty
			\else
				\let\pgfretval=#1%
			\fi
		\else
			% split the first involved path into the
			% segments induced by the intersection points:
			\pgf@insert@intersections@in@path{1}%
			\let\pgfpathfilled@a@segments=\pgfretval
			%
			% Now, create a new path which contains only those
			% segments which are INSIDE of the clip path.
			%
			% I assume that I can rely on "even/odd" matching: if the
			% first is inside, the second is outside, the third
			% inside, etc.
			\pgfapplistnewempty{pgfretval@tmp}%
			\def\c@pgfpathfilled@counter{0}%
			\pgfmathloop
			\ifnum\c@pgfpathfilled@counter<\pgfpathfilled@a@segments\relax
				\if0\b@pgffill@is@outside@clip
					\expandafter\let\expandafter\pgf@loc@path@a\csname pgf@intersect@path@split@a@\c@pgfpathfilled@counter\endcsname
					\expandafter\pgfapplistpushback\pgf@loc@path@a\to{pgfretval@tmp}%
				\fi
				\pgfpathfillbetween@negate\b@pgffill@is@outside@clip
				%
				\pgfutil@advancestringcounter\c@pgfpathfilled@counter
			\repeatpgfmathloop
			\pgfapplistlet\pgfretval={pgfretval@tmp}%
		\fi
		%
		\global\let\pgf@glob@TMPa=\pgfretval%
		\endgroup
		\let\pgfretval=\pgf@glob@TMPa
	\fi
}

% Defines "\def\pgfretval{1}" if (the first point of #1 is outside of the path #2)
% Defines "\def\pgfretval{0}" if (the first point of #1 is inside  of the path #2)
\def\pgfpathcomputesoftclippath@is@first@outside@of@path#1#2{%
	% APPROACH: should a line starting at the first coordinate of the
	% first path through "the middle of #2". Then make an even/odd
	% check on the number of intersections.
	\begingroup
	\expandafter\pgfpathfillbetween@get@first@coord#1\pgf@stop
	\let\pgfpathfilled@a@firstcoord=\pgfretval%
	%
	% Get some point "in the middle of #2":
	\pgfpathcomputesoftclippath@accum@pseudo@mean#2%
	\edef\pgfpathfilled@b@center{\noexpand\pgfqpoint\pgfretval}%
	%
	% We have to shoot *through* #2, not just into the middle of #2.
	% Consequently, we need to know how big #2 is:
	\pgfpathcomputesoftclippath@is@first@outside@of@path@getBB#2%
	\let\pgf@size@hint=\pgfretval
	%
	% Now, compute a target point such that our shot goes through it:
	\pgfqpointscale{%
		\pgf@size@hint
	}{%
		\pgfpointnormalised{%
			\pgfpointdiff%
				{\expandafter\pgfqpoint\pgfpathfilled@a@firstcoord}%
				{\pgfpathfilled@b@center}%
		}%
	}%
	% collect intermediate results as \pgf@xa/\pgf@ya are overwritten:
	\edef\pgf@direction@vector{\noexpand\pgfqpoint{\the\pgf@x}{\the\pgf@y}}%
	\pgfpointadd{\pgfpathfilled@b@center}{\pgf@direction@vector}%
	\edef\pgfpathfilled@shoot@line@trg{{\the\pgf@x}{\the\pgf@y}}%
	%
	% this here is our path!
	\edef\pgf@direction@path{%
		\noexpand\pgfsyssoftpath@movetotoken\pgfpathfilled@a@firstcoord
		\noexpand\pgfsyssoftpath@linetotoken\pgfpathfilled@shoot@line@trg
	}%
	%
	% ... ok, compute intersections. This should be fairly fast as
	% our second path has just 1 segment, i.e. it will be O(N) where N
	% is the number of segments in #2.
	\pgf@intersect@sortfalse
	\pgfintersectionofpaths%
		{%
			\pgfsetpath#2%
		}%
		{%
			\pgfsetpath\pgf@direction@path%
		}%
	%
	\ifnum\pgfintersectionsolutions=0 %
		% this must not happen! We have taken great care such that we
		% *have* at intersection points!
		\pgferror{Illegal state encountered: the computation of a softpath failed. The failure occurred while computing whether the first input coordinate is inside of the clip path (found no intersections)}%
	\fi
	%
	\ifodd\pgfintersectionsolutions\relax%
		\def\pgfretval{0}%
	\else
		\def\pgfretval{1}%
	\fi
	\pgfmath@smuggleone\pgfretval
	\endgroup
}

% Defines \pgfretval to be a *scalar* "size indicator" (1-norm) of the bounding
% box of #1.
%
% #1: a macro containing a softpath.
\def\pgfpathcomputesoftclippath@is@first@outside@of@path@getBB#1{%
	\begingroup
	\pgf@getpathsizes\pgf@interrupt@pathsizes
	% we only need the path size here:
	\pgf@relevantforpicturesizefalse
	\expandafter\pgfsetpath@protocolsizes@loop#1\pgf@stop
	\pgfpointdiff
		{\pgfqpoint\pgf@pathminx\pgf@pathminy}%
		{\pgfqpoint\pgf@pathmaxx\pgf@pathmaxy}%
	% compute |v|_1 = x + y (both components are non-negative anyway):
	\pgf@xa=\pgf@x
	\advance\pgf@xa by\pgf@y
	\xdef\pgf@glob@TMPa{\pgf@sys@tonumber\pgf@xa}%
	\pgf@setpathsizes\pgf@interrupt@pathsizes
	\endgroup
	\let\pgfretval=\pgf@glob@TMPa
}%

% Defines \pgfretval to be of a "pseudo" mean of path #1.
%
% Here, "pseudo" refers to the fact that the mean will only be
% accumulated over the "first couple of coordinates" to avoid numeric
% overflows in TeX's math engine.
\def\pgfpathcomputesoftclippath@accum@pseudo@mean#1{%
	\begingroup
	\let\pgfsyssoftpath@movetotoken\pgfpathcomputesoftclippath@accum@pseudo@mean@
	\let\pgfsyssoftpath@linetotoken\pgfpathcomputesoftclippath@accum@pseudo@mean@
	\let\pgfsyssoftpath@closepathtoken\pgfpathcomputesoftclippath@accum@pseudo@mean@
	\let\pgfsyssoftpath@curvetotoken\pgfpathcomputesoftclippath@accum@pseudo@mean@
	\let\pgfsyssoftpath@curvetosupportatoken\pgfpathcomputesoftclippath@accum@pseudo@mean@relax
	\let\pgfsyssoftpath@curvetosupportbtoken\pgfpathcomputesoftclippath@accum@pseudo@mean@relax
	\c@pgf@countc=0 %
	\pgf@xa=0pt %
	\pgf@ya=0pt %
	#1%
	\divide\pgf@xa by\c@pgf@countc
	\divide\pgf@ya by\c@pgf@countc
	\edef\pgfretval{{\the\pgf@xa}{\the\pgf@ya}}%
	\pgfmath@smuggleone\pgfretval
	\endgroup
}%
\def\pgfpathcomputesoftclippath@accum@pseudo@mean@relax#1#2{}
\def\pgfpathcomputesoftclippath@accum@pseudo@mean@#1#2{%
	\ifnum\c@pgf@countc<4
		% avoid overflows. 4 must be sufficient for now.
		\advance\pgf@xa by#1\relax
		\advance\pgf@ya by#2\relax
		\advance\c@pgf@countc by1 %
	\fi
}


% #1: of the form '{<x>}{<y>}'
% #2: of the form '{<x>}{<y>}'
\def\pgfpathfillbetween@check@x@less@than#1#2{%
	\edef\pgf@temp{#1#2}%
	\expandafter\pgfpathfillbetween@check@x@less@than@\pgf@temp
}%

% #1: x1
% #2: y1
% #3: x2
% #4: y2
\def\pgfpathfillbetween@check@x@less@than@#1#2#3#4{%
	\ifdim#1>#3\relax
		% <=
		\def\pgfretval{0}%
	\else
		\def\pgfretval{1}%
	\fi
}%

\def\pgfpathfillbetween@negate#1{%
	\if0#1%
		\def#1{1}%
	\else
		\def#1{0}%
	\fi
}

% #1: a macro containing the clip path. More precisely, it is supposed to be a return value of \pgfgetpath.
\def\pgffillbetweensetsoftclippathfirst#1{%
	\let\pgfpathfillbetween@softclip@A=#1%
}%

% #1: a macro containing the clip path. More precisely, it is supposed to be a return value of \pgfgetpath.
\def\pgffillbetweensetsoftclippathsecond#1{%
	\let\pgfpathfillbetween@softclip@B=#1%
}%

% Default: no clip paths
\pgffillbetweensetsoftclippathfirst{\pgfutil@empty}
\pgffillbetweensetsoftclippathsecond{\pgfutil@empty}

\def\pgfplotslibfillbetween@softclip#1{%
	\def\pgfplotslibfillbetween@softclip@trg{#1}%
	\tikz@scan@one@point\pgfplotslibfillbetween@softclip@bb@scan@a
}%

\def\pgfplotslibfillbetween@softclip@bb@scan@a#1{%
	\def\pgfplotslibfillbetween@softclip@bb@a{#1}%
	\pgfutil@ifnextchar r{%
		\pgfplotslibfillbetween@softclip@bb@scan@rectangle
	}{%
		\pgfplotslibfillbetween@softclip@@error
	}%
}%

\def\pgfplotslibfillbetween@softclip@bb@scan@rectangle rectangle{%
	\tikz@scan@one@point\pgfplotslibfillbetween@softclip@bb@scan@b
}%

\def\pgfplotslibfillbetween@softclip@bb@scan@b#1{%
	\def\pgfplotslibfillbetween@softclip@bb@b{#1}%
	\pgfutil@ifnextchar \pgfplots@EOI{%
		\pgfplotslibfillbetween@softclip@@activate
		\pgfplots@gobble@until@EOI
	}{%
		\pgfplotslibfillbetween@softclip@@error
	}%
}%

\def\pgfplotslibfillbetween@softclip@@error#1\pgfplots@EOI{%
	\def\pgfplots@loc@TMPa{#1}%
	\pgfplots@command@to@string\pgfplots@loc@TMPa\pgfplots@loc@TMPb
	\pgfplotsthrow{invalid argument}
		{\pgfplots@loc@TMPa}%
		{fill between: the argument of 'soft clip' has an unexpected format near '\pgfplots@loc@TMPb'; expected '(<pt>) rectangle (<pt>)'}%
		\pgfeov
}%

% INPUT:
%  - two PGF points \pgfplotslibfillbetween@softclip@bb@a and \pgfplotslibfillbetween@softclip@bb@b.
%  - \pgfplotslibfillbetween@softclip@trg (one of 'a' or 'b' the target path)
%
% POSTCONDITION: one of \pgffillbetweensetsoftclippathfirst or
% \pgffillbetweensetsoftclippathsecond is invoked with a suitable path.
\def\pgfplotslibfillbetween@softclip@@activate{%
	% Expand points to {<x>}{<y>} ...
	\pgf@process{\pgfplotslibfillbetween@softclip@bb@a}%
	\edef\pgfplotslibfillbetween@softclip@bb@a{{\the\pgf@x}{\the\pgf@y}}%
	\pgf@process{\pgfplotslibfillbetween@softclip@bb@b}%
	\edef\pgfplotslibfillbetween@softclip@bb@b{{\the\pgf@x}{\the\pgf@y}}%
	%
	\pgfinterruptpath
	\pgf@relevantforpicturesizefalse%
	\expandafter\pgfqpoint\pgfplotslibfillbetween@softclip@bb@a
	\pgf@xa=\pgf@x
	\pgf@ya=\pgf@y
	\expandafter\pgfqpoint\pgfplotslibfillbetween@softclip@bb@b
	\pgf@xb=\pgf@x
	\pgf@yb=\pgf@y
	%
	\pgfpathmoveto{\pgfqpoint{\pgf@xa}{\pgf@ya}}%
	\pgfpathlineto{\pgfqpoint{\pgf@xa}{\pgf@yb}}%
	\pgfpathlineto{\pgfqpoint{\pgf@xb}{\pgf@yb}}%
	\pgfpathlineto{\pgfqpoint{\pgf@xb}{\pgf@ya}}%
	\pgfpathclose
	\pgfgetpath\pgfplots@loc@TMPa
	\global\let\pgfplots@glob@TMPa=\pgfplots@loc@TMPa
	\endpgfinterruptpath
	%
	\if a\pgfplotslibfillbetween@softclip@trg
		\pgffillbetweensetsoftclippathfirst{\pgfplots@glob@TMPa}%
	\else
		\if b\pgfplotslibfillbetween@softclip@trg
			\pgffillbetweensetsoftclippathsecond{\pgfplots@glob@TMPa}%
		\else
			\if c\pgfplotslibfillbetween@softclip@trg
				\pgffillbetweensetsoftclippathfirst{\pgfplots@glob@TMPa}%
				\pgffillbetweensetsoftclippathsecond{\pgfplots@glob@TMPa}%
			\else
				\if d\pgfplotslibfillbetween@softclip@trg
					\let\pgf@decoration@soft@clip=\pgfplots@glob@TMPa%
				\else
				\fi
			\fi
		\fi
	\fi
}%
% ---------------------------------------------------------------------------------
