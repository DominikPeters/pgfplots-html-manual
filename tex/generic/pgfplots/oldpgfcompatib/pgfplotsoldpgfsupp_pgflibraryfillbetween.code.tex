%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% This file is a copy of some part of PGF/Tikz.
%%% It has been copied here to provide :
%%%  - compatibility with older PGF versions
%%%  - availability of PGF contributions by Christian Feuersaenger
%%%    which are necessary or helpful for pgfplots.
%%%
%%% For reasons of simplicity, I have copied the whole file, including own contributions AND
%%% PGF parts. The copyrights are as they appear in PGF.
%%%
%%% Note that pgfplots has compatible licenses.
%%% 
%%% This copy has been modified in the following ways:
%%%  - nested \input commands have been updated
%%%  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Date of this copy: Sa 7. Dez 23:35:39 CET 2013 %%%



% Copyright 2013 by Christian Feuersaenger
%
% This file may be distributed and/or modified
%
% 1. under the LaTeX Project Public License and/or
% 2. under the GNU Free Documentation License.
%
% See the file doc/generic/pgf/licenses/LICENSE for more details.


\usepgflibrary{intersections}
%\usepgfmodule{decorations}

\newif\ifpgfpathfillbetween@split

\pgfkeys{%
	/pgf/fill between/reverse/.is choice,
	/pgf/fill between/reverse/false/.code=\def\pgfpathfillbetween@reverse@mode{0},%
	/pgf/fill between/reverse/true/.code=\def\pgfpathfillbetween@reverse@mode{1},%
	%
	% checks the coordinates of the first two path instructions as heuristics:
	/pgf/fill between/reverse/auto/.code=\def\pgfpathfillbetween@reverse@mode{2},%
	/pgf/fill between/reverse/auto,
	%
	% split=true allows to generate individual result paths for every
	% region induced by the intersection points. Example: 
	% "color positive region in red and negative region in green".
	% The case split=false results in just one output path
	% (simpler+faster, but of course less powerful).
	/pgf/fill between/split/.is if=pgfpathfillbetween@split,
	/pgf/fill between/split/.default=true,
	%
	% Used to report results. This is mainly useful in conjunction
	% with split=true: each result segment will be streamed.
	%
	% Results are reported in the sequence
	%   begin
	%     next ready
	%     next ready
	%     ...
	%   end
	%
	% 'begin' has no arguments.
	/pgf/fill between/result stream/begin/.code=,%
	%
	% 'next ready' has macro arguments, but the macro \pgfretval
	% contains the lowlevel path as result (i.e. you can write
	% \pgfsetpath\pgfretval to activate it).
	/pgf/fill between/result stream/next ready/.code={
		% prepend to any previous path elements:
		\pgfgetpath\pgf@temp
		\t@pgf@tokc=\expandafter{\pgf@temp}%
		\t@pgf@toka=\expandafter{\pgfretval}%
		\edef\pgfretval{\the\t@pgf@tokc\the\t@pgf@toka}%
		\pgfsetpath{\pgfretval}%
	},%
	%
	% 'end' has no arguments.
	/pgf/fill between/result stream/end/.code=,%
}%

% \pgfpathfillbetween[<options>]{<first path>}{<second path>}
%
% Generates a new path consisting of the "fill between" of the two arguments.
% #1: optional arguments with /pgf/fill between prefix
% #2: a macro containing the first path. More precisely, it is supposed to be a return value of \pgfgetpath.
% #3: a macro containing the second path (in a format understood by \pgfsetpath). It is supposed to be a return value of \pgfgetpath.
\def\pgfpathfillbetween{\pgfutil@ifnextchar[{\pgfpathfillbetween@opt}{\pgfpathfillbetween@opt[]}}%
\def\pgfpathfillbetween@opt[#1]#2#3{%
	\begingroup
	\pgfqkeys{/pgf/fill between}{#1}%
	%
	% remove any special round-corner-tokens:
	\pgfprocessround{#2}{#2}%
	\pgfprocessround{#3}{#3}%
	%
	\if2\pgfpathfillbetween@reverse@mode
		% reverse=auto
		\expandafter\pgfpathfillbetween@heuristics@get@direction#2\pgf@stop
		\let\pgfpath@filled@dir@first=\pgfretval
		\expandafter\pgfpathfillbetween@heuristics@get@direction#3\pgf@stop
		\let\pgfpath@filled@dir@second=\pgfretval
		%
\message{reverse=auto: comparing \pgfpath@filled@dir@first\space with \pgfpath@filled@dir@second^^J}%
		\ifx\pgfpath@filled@dir@first\pgfpath@filled@dir@second
			% Ok, they (seem to) have the same direction. Reverse one of them:
			\def\pgfpathfillbetween@reverse@mode{1}%
		\fi
	\fi
	%
	\pgfpathfillbetween@invoke{result stream/begin}%
	%
	\ifpgfpathfillbetween@split
		\pgfpathfillbetween@compute@splitted{#2}{#3}%
	\else
		\pgfpathfillbetween@compute{#2}{#3}%
		\pgfpathfillbetween@invoke{result stream/next ready}%
	\fi
	%
	\pgfpathfillbetween@invoke{result stream/end}%
	%
	\endgroup
}%

\def\pgfpathfillbetween@invoke#1{\pgfkeysvalueof{/pgf/fill between/#1/.@cmd}\pgfeov}

\def\pgfpathfillbetween@replace@first@moveto#1#2\pgf@stop{%
	\ifx#1\pgfsyssoftpath@movetotoken
		\def\pgfretval{\pgfsyssoftpath@linetotoken #2}%
	\else
		\def\pgfretval{#1#2}%
	\fi
}%

\def\pgfpathfillbetween@compute@splitted#1#2{%
	% 1. compute intersection points:
	\pgfintersectionofpaths%
		{%
			\pgfsetpath#1%
		}%
		{%
			\pgfsetpath#2%
		}%
	% FIXME : computing the intersections is fine... but it would be
	% even finer to report the resulting points back to tikz!
	%
	% 2.  split the first involved path into the
	% segments induced by the intersection points:
	\pgf@insert@intersections@in@path{1}%
	\let\pgfpathfilled@a@segments=\pgfretval
	% 2. split the second involved path into the
	% segments induced by the intersection points:
	\pgf@insert@intersections@in@path{2}%
	\let\pgfpathfilled@b@segments=\pgfretval
	%
	\ifnum\pgfpathfilled@a@segments=\pgfpathfilled@b@segments\relax
	\else
		\pgferror{Illegal internal state encountered: the number segments induced by the intersection points of the two paths DIFFER between the first and the second path: first path has \pgfpathfilled@a@segments\space whereas the second has \pgfpathfilled@b@segments.}%
	\fi
	%
	% Recombine the pairs of segments (a_i, b_i), i = 0,..., N-1 in a
	% filled way:
	\def\c@pgfpathfilled@counter{0}%
	\pgfmathloop
	\ifnum\c@pgfpathfilled@counter<\pgfpathfilled@a@segments\relax
		\expandafter\let\expandafter\pgf@loc@path@a\csname pgf@intersect@path@split@a@\c@pgfpathfilled@counter\endcsname
		\expandafter\let\expandafter\pgf@loc@path@b\csname pgf@intersect@path@split@b@\c@pgfpathfilled@counter\endcsname
		%
		\pgfpathfillbetween@compute{\pgf@loc@path@a}{\pgf@loc@path@b}%
		% report to the result stream. It knows how to deal with it:
		\pgfpathfillbetween@invoke{result stream/next ready}%
		%
		\pgfutil@advancestringcounter\c@pgfpathfilled@counter
	\repeatpgfmathloop
}

\def\pgfpathfillbetween@compute#1#2{%
\message{Combination of \meaning#1\space and \meaning#2...^^J}%
	%
	\if1\pgfpathfillbetween@reverse@mode
		% reverse=true
		%
		% Ok, then reverse one of the path. We choose the second one as that is easier to debug.
		% FIXME : might make sense to determine which one is shorter...
		\pgf@reverse@path{#2}%
		\let#2=\pgfretval
	\fi
	%
	\expandafter\pgfpathfillbetween@replace@first@moveto#2\pgf@stop
	\let#2=\pgfretval
	% 
	\t@pgf@toka=\expandafter{#1}%
	\t@pgf@tokb=\expandafter{#2}%
	\edef\pgfretval{\the\t@pgf@toka\the\t@pgf@tokb}%
	%
	\expandafter\pgflibraryfillbetween@protocolsizes@loop\pgfretval\pgf@stop
	%
\pgf@getpathsizes\SIZES \message{   = \meaning\pgfretval\space SIZES=\meaning\SIZES^^J}%
	% that's it.
}

\def\pgfpathfillbetween@heuristics@get@direction#1#2#3{%
	\pgfutil@ifnextchar\pgf@stop{%
		% wow. it has just one path element... we can do nothing.
		\def\pgfretval{++}%
		\pgfutil@gobble
	}{%
		\pgfpathfillbetween@heuristics@get@direction@{#1}{#2}{#3}%
	}%
}%

% example: \pgfsyssoftpath@linetotoken{#2}{#3}\pgfsyssoftpath@linetotoken{#5}{#6}#7\pgf@stop
\def\pgfpathfillbetween@heuristics@get@direction@#1#2#3#4#5#6#7\pgf@stop{%
	\edef\pgfretval{%
		\ifdim #2<#5\space
			+%
		\else 
			\ifdim #3=#5\space
				\ifdim #3<#6\space
					+%
				\else
					-%
				\fi
			\else
				-%
			\fi
		\fi
	}%
}%

\def\pgflibraryfillbetween@protocolsizes@loop#1{%
	\ifx#1\pgf@stop%
		\let\pgflibfilled@protocolsizesnext=\relax%
	\else%
		\ifx#1\pgfsyssoftpath@movetotoken%
			\let\pgflibfilled@protocolsizesnext=\pgflibfilled@protocolsizestoken@simple%
		\else%
			\ifx#1\pgfsyssoftpath@linetotoken%
				\let\pgflibfilled@protocolsizesnext=\pgflibfilled@protocolsizestoken@simple%
			\else%
				\ifx#1\pgfsyssoftpath@closepathtoken%
					\let\pgflibfilled@protocolsizesnext=\pgflibfilled@protocolsizestoken@simple%
				\else%
					\ifx#1\pgfsyssoftpath@curvetosupportatoken%
						\let\pgflibfilled@protocolsizesnext=\pgflibfilled@protocolsizestoken@curveto%
					\else%
						\ifx#1\pgfsyssoftpath@rectcornertoken%
							\let\pgflibfilled@protocolsizesnext=\pgflibfilled@protocolsizestoken@rect%
						\fi%
					\fi%
				\fi%
			\fi%
		\fi%
	\fi%
	\pgflibfilled@protocolsizesnext}

\def\pgflibfilled@protocolsizestoken@simple#1#2{%
	\pgf@protocolsizes{#1}{#2}%
	\pgflibraryfillbetween@protocolsizes@loop%
}

\def\pgflibfilled@protocolsizestoken@curveto#1#2\pgfsyssoftpath@curvetosupportbtoken#3#4\pgfsyssoftpath@curvetotoken#5#6{%
	\pgf@protocolsizes{#1}{#2}%
	\pgf@protocolsizes{#3}{#4}%
	\pgf@protocolsizes{#5}{#6}%
	\pgflibraryfillbetween@protocolsizes@loop
}

\def\pgflibfilled@protocolsizestoken@rect#1#2\pgfsyssoftpath@rectsizetoken#3#4{%
	\pgf@protocolsizes{#1}{#2}%
	\pgf@xa=#1\relax%
	\advance\pgf@xa by#3\relax%
	\pgf@ya=#2\relax%
	\advance\pgf@ya by#4\relax%
	\pgf@protocolsizes{\pgf@xa}{\pgf@ya}%
	\pgflibraryfillbetween@protocolsizes@loop
}%

% Defines \pgfretval to be the reversed path of #1.
%
% #1 is supposed to be a macro containing a path without rounding specials (i.e. a result
% of \pgfprocessround)
\def\pgf@reverse@path#1{%
	% ATTENTION: this here is a special implementation which
	% operates directly on softpaths. It does not make use of \pgf@decorate@inputsegmentobjects@reverse (reverse path decoration)
	% because (a) decorations require their own special format and (b)
	% this implementation is faster (both with respect to runtime asymptotics and runtime constant).
	\def\pgf@reverse@first@type{}%
	\def\pgf@reverse@last@pt{}%
	\pgfprependlistnewempty{pgfretval}%
	\let\pgfreverse@iterate=\pgfreverse@checkfirst@then
	\expandafter\pgf@reverse@loop#1\pgf@stop
	%
	\if 0\b@pgf@reversepath@last@is@close%
		\expandafter\pgfreverse@prepend@last\expandafter{\pgf@reverse@first@type}{x}{x}%
	\else
		% as soon as a closepathtoken is encountered, the associated
		% moveto is processed right away.
		%
		% FIXME : I doubt that the implementation works if more than
		% one closepathtoken is in here ...
	\fi
	\pgfprependlistlet\pgfretval={pgfretval}%
	%
}%

\def\pgf@reverse@loop#1{%
	\ifx#1\pgf@stop%
		\let\pgfreverse@next=\relax%
	\else%
		\def\b@pgf@reversepath@last@is@close{0}%
		\ifx#1\pgfsyssoftpath@movetotoken%
			\let\pgfreverse@next=\pgfreverse@token@moveto%
		\else%
			\ifx#1\pgfsyssoftpath@linetotoken%
				\let\pgfreverse@next=\pgfreverse@token@lineto%
			\else%
				\ifx#1\pgfsyssoftpath@closepathtoken%
					\let\pgfreverse@next=\pgfreverse@token@close%
				\else%
					\ifx#1\pgfsyssoftpath@curvetosupportatoken%
						\let\pgfreverse@next=\pgfreverse@token@curveto%
					\else%
						\ifx#1\pgfsyssoftpath@rectcornertoken%
							\let\pgfreverse@next=\pgfreverse@token@rect%
						\fi%
					\fi%
				\fi%
			\fi%
		\fi%
	\fi%
	\pgfreverse@next}

\def\pgfreverse@checkfirst@then#1{%
	\def\pgf@reverse@first@type{#1}%
	\let\pgfreverse@iterate=\pgfutil@gobble
}%

\def\pgfreverse@prepend@last#1#2#3{%
	\ifx\pgf@reverse@last@pt\pgfutil@empty
	\else
		\t@pgf@toka={#1}%
		\t@pgf@tokb=\expandafter{\pgf@reverse@last@pt}%
		\edef\pgf@marshal{\the\t@pgf@toka\the\t@pgf@tokb}%
		\expandafter\pgfprependlistpushfront\pgf@marshal\to{pgfretval}%
	\fi
	\def\pgf@reverse@last@pt{{#2}{#3}}%
}%

\def\pgfreverse@token@moveto#1#2{%
	\pgfreverse@iterate{\pgfsyssoftpath@movetotoken}%
	\pgfreverse@prepend@last\pgfsyssoftpath@movetotoken{#1}{#2}%
	\pgf@reverse@loop%
}

\def\pgfreverse@token@lineto#1#2{%
	\pgfreverse@iterate{\pgfsyssoftpath@linetotoken}%
	\pgfreverse@prepend@last\pgfsyssoftpath@linetotoken{#1}{#2}%
	\pgf@reverse@loop
}
\def\pgfreverse@token@close#1#2{%
	% close tokens are complicated: they always correspond to the most
	% recent moveto token.
	%
	% First: remember that the last encountered token was 'close': if
	% this is the lastmost token, we must not insert a final moveto.
	\def\b@pgf@reversepath@last@is@close{1}%
	%
	% Second: *append*
	% \pgfsyssoftpath@closepathtoken{<lastx>}{<lasty>}.
	%
	% Appending is unsupported by the prepend-list, so we have to
	% terminate it, append, and reinitialize it with the result:
	\pgfprependlistlet\pgfretval={pgfretval}%
	\t@pgf@toka=\expandafter{\pgfretval}%
	\t@pgf@tokb={\pgfsyssoftpath@closepathtoken}%
	\t@pgf@tokc=\expandafter{\pgf@reverse@last@pt}%
	\edef\pgf@marshal{\the\t@pgf@toka\the\t@pgf@tokb\the\t@pgf@tokc}%
	%
	% ... create a new list with the result:
	\pgfprependlistnewempty{pgfretval}%
	\expandafter\pgfprependlistpushfront\pgf@marshal\to{pgfretval}%
	%
	% and prepend a moveto.
	\pgfreverse@prepend@last\pgfsyssoftpath@movetotoken{#1}{#2}%
	%
	\pgf@reverse@loop
}

\def\pgfreverse@token@curveto#1#2\pgfsyssoftpath@curvetosupportbtoken#3#4\pgfsyssoftpath@curvetotoken#5#6{%
	\pgfreverse@iterate{\pgfsyssoftpath@curvetosupportatoken{#1}{#2}\pgfsyssoftpath@curvetosupportbtoken{#3}{#4}\pgfsyssoftpath@curvetotoken}%
	\pgfreverse@prepend@last{\pgfsyssoftpath@curvetosupportatoken{#3}{#4}\pgfsyssoftpath@curvetosupportbtoken{#1}{#2}\pgfsyssoftpath@curvetotoken}{#5}{#6}%
	\pgf@reverse@loop
}

\def\pgfreverse@token@rect#1#2\pgfsyssoftpath@rectsizetoken#3#4{%
	% FIXME: UNTESTED
	\pgf@xa=#1\relax%
	\advance\pgf@xa by#3\relax%
	\pgf@ya=#2\relax%
	\advance\pgf@ya by#4\relax%
	\edef\pgf@marshal{%
		\noexpand\pgfsyssoftpath@movetotoken
		{%
			{#1}{#2}%
			\noexpand\pgfsyssoftpath@linetotoken{\the\pgf@xa}{#2}%
			\noexpand\pgfsyssoftpath@linetotoken{\the\pgf@xa}{\the\pgf@ya}%
			\noexpand\pgfsyssoftpath@linetotoken{#1}{\the\pgf@ya}%
			\noexpand\pgfsyssoftpath@closepathtoken{#1}{#2}%
		}%
	}%
	\pgfreverse@iterate\pgfsyssoftpath@movetotoken
	\edef\pgf@reverse@last@pt{{#1}{#2}}%
	\expandafter\pgf@reverse@loop\pgf@marshal%
}

% ----------------------------------------

% Defines \pgfretval to contain a modified path including the
% intersections of a preceding call to \pgfintersectionofpaths.
%
% However, it does not only insert the intersection points into the
% path. It also splits the path into the segments induced by the
% intersection points.
%
% #1 : should be '1' if the FIRST argument of
% \pgfintersectionofpaths should be used and '2' the SECOND
% argument of \pgfintersectionofpaths should be used on input.
%
%  On output, there will be a number of individual path segments. The
%  number is stored into \pgfretval.
%  The resulting path segments will be available as
%      \csname pgf@intersect@path@split@a@[0....N-1]\endcsname
%   provided that '#1 = 1' or
%
%      \csname pgf@intersect@path@split@b@[0....N-1]\endcsname
%
%   in the case '#1 = 2'.
%
% EXAMPLE:
%
%   	\def\inputValue{%
%   		\pgfsyssoftpath@movetotoken {56.90549pt}{0.0pt}%
%   		\pgfsyssoftpath@linetotoken {85.35823pt}{28.45274pt}%
%   		\pgfsyssoftpath@linetotoken {113.81097pt}{0.0pt}%
%   		\pgfsyssoftpath@linetotoken {142.26372pt}{28.45274pt}%
%   		\pgfsyssoftpath@linetotoken {170.71646pt}{0.0pt}%
%   	}
%
%   	\pgfpointintersectionsolution{1}%
%   	\pgfplotsassertequalstok{\the\pgf@x, \the\pgf@y}{71.13918pt, 14.2278pt}{solution 1}
%   	\pgfpointintersectionsolution{2}%
%   	\pgfplotsassertequalstok{\the\pgf@x, \the\pgf@y}{99.59497pt, 14.2278pt}{solution 2}
%   	\pgfpointintersectionsolution{3}%
%   	\pgfplotsassertequalstok{\the\pgf@x, \the\pgf@y}{128.05057pt, 14.2278pt}{solution 3}
%   	\pgfpointintersectionsolution{4}%
%   	\pgfplotsassertequalstok{\the\pgf@x, \the\pgf@y}{156.50636pt, 14.2278pt}{solution 4}
%   	
%   
%   	\pgf@insert@intersections@in@path{1}%
%   
%   	\message{OUTPUT: \meaning\pgfretval^^J}%
%   	\expandafter\def\csname expected@a@0\endcsname{%
%   		\pgfsyssoftpath@movetotoken {56.90549pt}{0.0pt}%
%   \pgfsyssoftpath@linetotoken{71.13918pt}{14.2278pt}%
%   	}
%   	\expandafter\def\csname expected@a@1\endcsname{%
%   		\pgfsyssoftpath@movetotoken{71.13918pt}{14.2278pt}%
%   		\pgfsyssoftpath@linetotoken {85.35823pt}{28.45274pt}%
%   \pgfsyssoftpath@linetotoken{99.59497pt}{14.2278pt}%
%   	}
%   	\expandafter\def\csname expected@a@2\endcsname{%
%   		\pgfsyssoftpath@movetotoken{99.59497pt}{14.2278pt}%
%   		\pgfsyssoftpath@linetotoken {113.81097pt}{0.0pt}%
%   \pgfsyssoftpath@linetotoken{128.05057pt}{14.2278pt}%
%   	}
%   	\expandafter\def\csname expected@a@3\endcsname{%
%   		\pgfsyssoftpath@movetotoken{128.05057pt}{14.2278pt}%
%   		\pgfsyssoftpath@linetotoken {142.26372pt}{28.45274pt}%
%   \pgfsyssoftpath@linetotoken{156.50636pt}{14.2278pt}%
%   	}
%   	\expandafter\def\csname expected@a@4\endcsname{%
%   		\pgfsyssoftpath@movetotoken{156.50636pt}{14.2278pt}%
%   		\pgfsyssoftpath@linetotoken {170.71646pt}{0.0pt}%
%   	}
%   % 
\def\pgf@insert@intersections@in@path#1{%
	\ifcase#1\relax
		% 0
		\pgferror{illegal argument supplied.}
	\or
		\def\pgf@insert@intersections@src{a}%
	\or
		\def\pgf@insert@intersections@src{b}%
	\else
		\pgferror{illegal argument supplied.}
	\fi
	\ifnum\pgfintersectionsolutions=0 %
		\pgfutil@namelet{pgf@intersect@path@split@\pgf@insert@intersections@src @0}{pgf@intersect@path@\pgf@insert@intersections@src}%
	\else
		\pgfapplistnewempty{pgfretval@tmp}%
		\def\pgf@insert@cursolution{1}%
		\def\c@pgf@path@result{0}%
		\let\c@pgf@path@segment=\c@pgf@countd
		\let\c@pgf@path@segment@trg=\c@pgf@countc
		\c@pgf@path@segment=0 %
		\c@pgf@path@segment@trg=\csname pgf@intersect@solution@segment@\pgf@insert@intersections@src @\pgf@insert@cursolution\endcsname
		%
		\pgfutil@namelet{pgf@loc@TMPa}{pgf@intersect@path@\pgf@insert@intersections@src}%
		\expandafter\pgf@insert@intersections@loop\pgf@loc@TMPa\pgf@stop
		%
		\pgfapplistlet\pgf@loc@TMPa={pgfretval@tmp}%
		\expandafter\let\csname pgf@intersect@path@split@\pgf@insert@intersections@src @\c@pgf@path@result\endcsname=\pgf@loc@TMPa%
		\pgfutil@advancestringcounter\c@pgf@path@result%
		\let\pgfretval=\c@pgf@path@result%
	\fi
}%

\def\pgf@insert@intersections@in@path@@{%
\message{processing segment \the\c@pgf@path@segment\space (current solution \pgf@insert@cursolution; target segment \the\c@pgf@path@segment@trg)^^J}%
	\pgfmathloop
	% we need to loop: it is fully acceptable if more than one
	% solution is on the same segment.
	\ifnum\c@pgf@path@segment=\c@pgf@path@segment@trg
		%
		\csname pgfpoint@intersect@solution@\pgf@insert@cursolution\endcsname%
		% FIXME : experimental: add support for other path operations!
		\edef\pgf@loc@TMPa{\noexpand\pgfsyssoftpath@linetotoken{\the\pgf@x}{\the\pgf@y}}%
		\expandafter\pgfapplistpushback\pgf@loc@TMPa\to{pgfretval@tmp}%
		%
		%
		% report the current result segment!
		\pgfapplistlet\pgf@loc@TMPa={pgfretval@tmp}%
		\expandafter\let\csname pgf@intersect@path@split@\pgf@insert@intersections@src @\c@pgf@path@result\endcsname=\pgf@loc@TMPa%
		\pgfutil@advancestringcounter\c@pgf@path@result%
		% ... and start a new result segment. Keep in mind that it
		% should start with a moveto:
		\pgfapplistnewempty{pgfretval@tmp}%
		\edef\pgf@loc@TMPa{\noexpand\pgfsyssoftpath@movetotoken{\the\pgf@x}{\the\pgf@y}}%
		\expandafter\pgfapplistpushback\pgf@loc@TMPa\to{pgfretval@tmp}%
		%
		%
		% OK, iterate:
		\ifnum\pgf@insert@cursolution=\pgfintersectionsolutions\relax
			% collect all remaining ones:
			\c@pgf@path@segment@trg=10000000 %
		\else
			\pgfutil@advancestringcounter\pgf@insert@cursolution
			\c@pgf@path@segment@trg=\csname pgf@intersect@solution@segment@\pgf@insert@intersections@src @\pgf@insert@cursolution\endcsname
		\fi
	\repeatpgfmathloop
	\expandafter\pgfapplistpushback\pgfinsert@intersect@tok\to{pgfretval@tmp}%
	\advance\c@pgf@path@segment by1 %
}%


\def\pgf@insert@intersections@loop#1{%
	\ifx#1\pgf@stop%
		\def\pgfinsert@intersect@tok{}%
		\pgf@insert@intersections@in@path@@%
		\let\pgfinsert@intersect@next=\relax%
	\else%
		\ifx#1\pgfsyssoftpath@movetotoken%
			\let\pgfinsert@intersect@next=\pgfinsert@intersect@token@moveto%
		\else%
			\ifx#1\pgfsyssoftpath@linetotoken%
				\let\pgfinsert@intersect@next=\pgfinsert@intersect@token@lineto%
			\else%
				\ifx#1\pgfsyssoftpath@closepathtoken%
					\let\pgfinsert@intersect@next=\pgfinsert@intersect@token@close%
				\else%
					\ifx#1\pgfsyssoftpath@curvetosupportatoken%
						\let\pgfinsert@intersect@next=\pgfinsert@intersect@token@curveto%
					\else%
						\ifx#1\pgfsyssoftpath@rectcornertoken%
							\let\pgfinsert@intersect@next=\pgfinsert@intersect@token@rect%
						\fi%
					\fi%
				\fi%
			\fi%
		\fi%
	\fi%
	\pgfinsert@intersect@next}

\def\pgfinsert@intersect@token@moveto#1#2{%
	\def\pgfinsert@intersect@tok{\pgfsyssoftpath@movetotoken{#1}{#2}}%
	\expandafter\pgfapplistpushback\pgfinsert@intersect@tok\to{pgfretval@tmp}%
	\def\pgfpointinsert@intersect@start{\pgfqpoint{#1}{#2}}%
	\pgf@insert@intersections@loop%
}

\def\pgfinsert@intersect@token@lineto#1#2{%
	\def\pgfinsert@intersect@tok{\pgfsyssoftpath@linetotoken{#1}{#2}}%
	\pgf@insert@intersections@in@path@@%
	\pgf@insert@intersections@loop
}
\def\pgfinsert@intersect@token@close#1#2{%
	\def\pgfinsert@intersect@tok{\pgfsyssoftpath@closepathtoken{#1}{#2}}%
	\pgf@insert@intersections@in@path@@%
	\pgf@insert@intersections@loop
}

\def\pgfinsert@intersect@token@curveto#1#2\pgfsyssoftpath@curvetosupportbtoken#3#4\pgfsyssoftpath@curvetotoken#5#6{%
	\def\pgfinsert@intersect@tok{\pgfsyssoftpath@curvetosupportatoken{#1}{#2}\pgfsyssoftpath@curvetosupportbtoken{#3}{#4}{#5}{#6}}%
	\def\pgfpointinsert@intersect@firstsupport{\pgfqpoint{#1}{#2}}%
	\def\pgfpointinsert@intersect@secondsupport{\pgfqpoint{#3}{#4}}%
	\pgf@insert@intersections@in@path@@%
	\pgf@insert@intersections@loop
}

\def\pgfinsert@intersect@token@rect#1#2\pgfsyssoftpath@rectsizetoken#3#4{%
	\pgf@xa=#1\relax%
	\advance\pgf@xa by#3\relax%
	\pgf@ya=#2\relax%
	\advance\pgf@ya by#4\relax%
	\edef\pgf@marshal{%
		\noexpand\pgfsyssoftpath@movetotoken{#1}{#2}%
		\noexpand\pgfsyssoftpath@linetotoken{#1}{\the\pgf@ya}%
		\noexpand\pgfsyssoftpath@linetotoken{\the\pgf@xa}{\the\pgf@ya}%
		\noexpand\pgfsyssoftpath@linetotoken{\the\pgf@xa}{#2}%
		\noexpand\pgfsyssoftpath@closepathtoken{#1}{#2}%
	}%
	\expandafter\pgf@insert@intersections@loop\pgf@marshal%
}
\endinput
