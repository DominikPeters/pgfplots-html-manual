%--------------------------------------------
%
% Package pgfplots
%
% Provides a user-friendly interface to create function plots (normal
% plots, semi-logplots and double-logplots).
% 
% It is based on Till Tantau's PGF package.
%
% Copyright 2007-2013 by Christian Feuers√§nger.
%
% This program is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program.  If not, see <http://www.gnu.org/licenses/>.
%
%--------------------------------------------
	
\def\pgfplots@markers@visphase@after@axis@prepare{%
	\global\pgfplotslistnewempty\pgfplots@stored@markerlist
}

% Draw any markers for which drawing has been postponed.
%
% The motivation here is that markers should be drawn on top of
% their plots, and AFTER the clip path.
%
\def\pgfplots@markers@visphase@after@axis{%
	% If the plotting logic added serialized marker streams to
	% \pgfplots@stored@markerlist, these markers will be plotted here.
	%
	% Note that this list will be EMPTY if
	% \ifpgfplots@clip@marker@paths is true.
	%
	% whats the better sequence for \ifpgfplots@axis@on@top and \ifpgfplots@clip@marker@paths !? 
	% This here looks better, I think... markers should not be obscured by descriptions.
	\pgfplotslistforeach\pgfplots@stored@markerlist\as\pgfplots@loc@TMPa{%
%\message{Executing marker stuff: \meaning\pgfplots@loc@TMPa]]]]]}%
%\tracingmacros=2\tracingcommands=2
		\pgfplots@loc@TMPa
	}%
	\global\pgfplotslistnewempty\pgfplots@stored@markerlist% clear.
}

\def\pgfplots@markers@visphase@directlyafterpath{%
	\ifx\pgfplots@recorded@marker@stream\pgfutil@empty
	\else
		\pgfkeysgetvalue{/pgfplots/mark layer}\pgfplots@loc@TMPa
		\ifx\pgfplots@loc@TMPa\pgfutil@empty
			\ifpgfplots@clip@marker@paths
				% Draw markers on top of the plot lines:
				%
				\pgfplots@stored@current@cmd%[current plot style] <--- options are already set
				\pgfextra 
					\pgfplots@markers@install@plotmark@handler
					\pgfplots@recorded@marker@stream 
				\endpgfextra
				;
			\else
				% sigh... ok, store the marker list (once more again).
				% They need to be drawn after the clipped area.
				%
				% fortunately, the serialization is not expensive.
				\pgfplots@markers@stored@REMEMBER@MARK@COMMAND
			\fi
		\else
			% oh - we need a mark layer!
			\pgfplotsonlayer{\pgfkeysvalueof{/pgfplots/mark layer}}{mark layer}%
			\pgfplots@markers@serialize@mark@command
			\pgfplotsretval
			\endpgfplotsonlayer
		\fi
	\fi
	\gdef\pgfplots@recorded@marker@stream{}% clear
}%

% This method MUST be called while \pgfplots@stored@plotlist is
% evaluated, that means
% - \pgfplots@stored@* commands need to be valid,
% - the precommand has already been invoked.
% - pgfplots@recorded@marker@stream exists
% - current plot style is valid
\def\pgfplots@markers@stored@REMEMBER@MARK@COMMAND{%
	\pgfplots@markers@serialize@mark@command
	\ifpgfplots@clip
		\if2\pgfplots@clipmode
			% clip mode=individual:
			\global\let\pgfplots@stored@markerlist@last=\pgfplotsretval
		\else
			% clip mode=global
			\expandafter\pgfplotslistpushbackglobal\expandafter{\pgfplotsretval}\to\pgfplots@stored@markerlist
		\fi
	\fi
}%

\def\pgfplots@execute@at@begin@plot@visualization@internal{%
	\global\let\pgfplots@stored@markerlist@last=\relax
}%

\def\pgfplots@execute@at@end@plot@visualization@internal{%
	\ifpgfplots@clip
		\if2\pgfplots@clipmode
			% clip=true and 'clip mode=individually'
			\pgfplots@stored@markerlist@last
			\global\let\pgfplots@stored@markerlist@last=\relax
		\fi
	\fi
}%

\def\pgfplots@markers@serialize@mark@command{%
	\pgfkeysgetvalue{/tikz/current plot style/.@cmd}{\pgfplots@loc@TMPa}%
	\t@pgfplots@toka=\expandafter{\pgfplots@loc@TMPa\pgfeov}%
	\t@pgfplots@tokb=\expandafter{\pgfplots@stored@current@cmd[current plot style]}%
	\t@pgfplots@tokc=\expandafter{\pgfplots@recorded@marker@stream}%
	\edef\pgfplots@loc@TMPa{%
		\noexpand\pgfkeysvalueof{/pgfplots/execute at begin plot visualization}%
		\noexpand\def\noexpand\tikz@plot@mark{\tikz@plot@mark}% make sure we restore the environment setting
		\noexpand\pgfkeysdef{/tikz/current plot style}{\the\t@pgfplots@toka}%
		% de-activate the FPU here if it was active! I fear its number
		% format may cause errors when used in low-level
		% routines.
		\noexpand\pgfkeys{/pgf/fpu=false}%
		%
		\noexpand\xdef\noexpand\pgfplots@metamin{\pgfplots@metamin}%
		\noexpand\xdef\noexpand\pgfplots@metamax{\pgfplots@metamax}%
		\noexpand\def\noexpand\pgfplotspointmetainputhandler{\pgfplotspointmetainputhandler}%
		%
		\the\t@pgfplots@tokb
		\noexpand\pgfextra
		\noexpand\pgfplots@markers@install@plotmark@handler
		\the\t@pgfplots@tokc
		\noexpand\endpgfextra
		;%
		\noexpand\pgfkeysvalueof{/pgfplots/execute at end plot visualization}%
	}%
	\t@pgfplots@toka=\expandafter{\pgfplots@loc@TMPa}%
	\t@pgfplots@tokb=\expandafter{\pgfplots@stored@current@precmd}%
	\edef\pgfplotsretval{%
		\noexpand\scope% make sure that 'fill opacity' and 'dotted' styles remain local!
		\the\t@pgfplots@tokb
		\the\t@pgfplots@toka
		\noexpand\endscope}%
}%

\def\pgfplots@markers@install@plotmark@handler{%
	% note: I can't check on tikz@transform because it can be '\relax'.
	\pgfplots@gettikzinternal@keyval{mark indices}{tikz@mark@list}{}%
	\pgfplots@gettikzinternal@keyval{mark}{tikz@plot@mark}{}%
	%
	%
	% do not reset \tikz@options: draw color may be acquired
	% from 'current plot style'
	%\let\tikz@options=\pgfutil@empty%
	\let\tikz@transform=\pgfutil@empty%
	\tikzset{every plot/.try,every mark}%
	%
	% This sets colors:
	\tikz@options
	%
	% This sets the \iftikz@mode@draw etc:
	%\tikz@mode
	% FIXME: using 'color=blue' will NOT activate filltrue!
	% So: if 'tikz@mode' *contains* 'fillfalse', I know what to do... 
	% but all other cases are not clear
	%--------------------------------------------------
	% \iftikz@mode@draw
	% \else
	% 	% Override the marker codes: force 'draw=none'
	% 	% even if the markers likes to be stroked:
	% 	\let\pgfusepathqfillstroke=\pgfusepathqfill
	% \fi
	% \iftikz@mode@fill
	% \else
	% 	% Override the marker codes: force 'fill=none'
	% 	% even if the markers likes to be filled:
	% 	\let\pgfusepathqfillstroke=\pgfusepathqstroke
	% \fi
	%-------------------------------------------------- 
	\pgfplots@perpointmeta@preparetrafo
	%
	\ifpgfplots@stackedmode
		\pgfplots@stacked@visphase@beginplot
	\fi
	\pgfplots@prepare@visualization@dependencies
	%
	% this here is the MAIN marker code.
	% It may be modified if scatter plot is enabled, see below.
	\def\pgfplots@loc@TMPa{%
		% the transformation has been reset before processing plot
		% marks.
		% Consequently, it applies only transformation options in "every mark".
		\tikz@transform
		\pgfuseplotmark{\tikz@plot@mark}%
	}%
	\ifpgfplots@scatterplotenabled
		% Scatter plots work like this:
		%
		% <compute per-point meta info>
		% /pgfplots/scatter/@pre marker code
		% <marker code, lowlevel>
		% /pgfplots/scatter/@post marker code
		%
		% -> that's all. The Rest is configurable with style which
		%  (re)define '@pre marker code' and '@post marker code' (see
		%  the docs for details).
		%
		% Prepare arguments for '@pre/@post' macros:
		\t@pgfplots@toka={%
			\begingroup
			\pgfplotsaxisvisphasetransformpointmeta
			\pgfkeysvalueof{/pgfplots/scatter/@pre marker code/.@cmd}\pgfeov
		}%
		\t@pgfplots@tokb=\expandafter{\pgfplots@loc@TMPa}%
		\t@pgfplots@tokc={%
			\pgfkeysvalueof{/pgfplots/scatter/@post marker code/.@cmd}\pgfeov
			\endgroup
		}%
		\edef\pgfplots@loc@TMPa{%
			\the\t@pgfplots@toka
			\the\t@pgfplots@tokb
			\the\t@pgfplots@tokc
		}%
		\if r\pgfplots@scatter@position
			% scatter/position=relative
			%
			% tikz transforms the coordinate system such that "(0,0)"
			% is the point where the mark should be placed.
		\else
			% scatter/position=absolute
			%
			% ah - we do not want tikz's transformation.
			%
			% Disable it by means of \aftergroup hackery:
			\t@pgfplots@tokc=\expandafter{\pgfplots@loc@TMPa}%
			\xdef\pgfplots@scatter@plot@mark{%
				\noexpand\begingroup
				\the\t@pgfplots@tokc
				\noexpand\endgroup
			}%
			\def\pgfplots@loc@TMPa{\aftergroup\pgfplots@scatter@plot@mark}%
		\fi
	\fi
	\def\pgfplots@loc@TMPb##1{%
		\ifx\tikz@mark@list\pgfutil@empty%
			\pgfplothandlermark{##1}%
		\else
			\pgfplothandlermarklisted{##1}{\tikz@mark@list}%
		\fi
	}%
	\t@pgfplots@tokc=\expandafter\expandafter\expandafter{\expandafter\pgfplots@loc@TMPb\expandafter{\pgfplots@loc@TMPa}}%
	\edef\pgfplots@basiclevel@plothandler{\the\t@pgfplots@tokc}%
	%
	\pgfplots@basiclevel@plothandler
}%


\def\pgfplots@markers@check@for@default@plot@mark{%
	% make sure there is a mark set!
	\pgfplots@gettikzinternal@keyval{mark}{tikz@plot@mark}{}%
	\def\pgfplots@loc@TMPa{none}%
	\ifx\tikz@plot@mark\pgfplots@loc@TMPa
		% this here happens only in older versions of pgf.
		\let\tikz@plot@mark\pgfutil@empty
	\fi
	\ifx\tikz@plot@mark\pgfutil@empty
		\pgfplots@getcurrent@plothandler\pgfplots@basiclevel@plothandler
		\ifx\pgfplots@basiclevel@plothandler\pgfplothandlerdiscard
			% oh, the "only marks" plot handler-- and no plot mark!?
			% what's that!?
			\ifpgfplots@scatterplotenabled
				% scatter handles this in /pgfplots/scatter/true
				% automatically.
			\else
				% that appears to be nonsense...
				\def\tikz@plot@mark{*}%
			\fi
		\fi
	\fi
}%


% Used inside of /pgfplots/scatter/classes :
\def\pgfplots@markers@scatter@classes@pre@marker@code{%
	\pgfutil@ifundefined{pgfp@scatter@class@\pgfplotspointmeta}{%
		\let\pgfplots@loc@TMPa=\pgfplotspointmeta
		%
		% ups - no styles available? Maybe something went
		% wrong with the 'scatter src' key. Check whether it
		% was accidentally a numerical style:
		\if1\csname pgfpmeta@\pgfplotspointmetainputhandler @issymbolic\endcsname
		\else
			% ok, be fault tolerant and round to an integer:
			\pgfplotscoordmath{meta}{tofixed}{\pgfplotspointmeta}%
			\begingroup
			\pgfkeys{/pgf/number format/precision=0}%
			\expandafter\pgfmathroundto\expandafter{\pgfmathresult}%
			\pgfmath@smuggleone\pgfmathresult
			\endgroup
			\let\pgfplotspointmeta=\pgfmathresult
		\fi
		% now, check again:
		\pgfutil@ifundefined{pgfp@scatter@class@\pgfplotspointmeta}{%
			% still not possible? Then, try truncating the
			% number to an integer.
			\expandafter\pgfutil@in@\expandafter.\expandafter{\pgfplotspointmeta}%
			\ifpgfutil@in@
				\def\pgfplots@loc@TMPb##1.##2\relax{\def\pgfplotspointmeta{##1}}%
				\expandafter\pgfplots@loc@TMPb\pgfplots@loc@TMPa\relax
			\fi
			% now, check again:
			\pgfutil@ifundefined{pgfp@scatter@class@\pgfplotspointmeta}{%
				\pgfutil@ifundefined{pgfp@scatter@WARNING@\pgfplotspointmeta}{%
					\pgfplotswarning{scatter classes no such class}\pgfplotspointmeta\pgfeov%
					\expandafter\gdef\csname pgfp@scatter@WARNING@\pgfplotspointmeta\endcsname{ALREADY CHECKED}%
				}{}%
				\def\pgfplots@loc@TMPa{}%
			}{%
				\expandafter\let\expandafter\pgfplots@loc@TMPa\csname pgfp@scatter@class@\pgfplotspointmeta\endcsname
			}%
		}{%
			\expandafter\let\expandafter\pgfplots@loc@TMPa\csname pgfp@scatter@class@\pgfplotspointmeta\endcsname
		}%
	}{%
		\expandafter\let\expandafter\pgfplots@loc@TMPa\csname pgfp@scatter@class@\pgfplotspointmeta\endcsname
	}%
	\expandafter\scope\expandafter[\pgfplots@loc@TMPa]%
}%

% validates 'mark layer' such that it can be queried afterwards.
\def\pgfplots@markers@prepare@layered@graphics@marks{%
	\ifpgfplots@layered@graphics
		\pgfkeysgetvalue{/pgfplots/mark layer}\pgfplots@loc@TMPa
		\edef\pgfplots@loc@TMPa{\pgfplots@loc@TMPa}%
		\ifx\pgfplots@loc@TMPa\pgfutil@empty
			\def\pgfplots@loc@TMPa{auto}%
		\fi
		\def\pgfplots@loc@TMPb{auto}%
		\ifx\pgfplots@loc@TMPa\pgfplots@loc@TMPb
			% COMBINATION: 'activate layers,mark layer=auto' --> keep
			% backwards compatibility with 'clip marker paths'
			% -> nothing to do.
			\pgfkeyslet{/pgfplots/mark layer}\pgfutil@empty%
		\else
			% mark layer=like plot
			\def\pgfplots@loc@TMPb{like plot}%
			\ifx\pgfplots@loc@TMPa\pgfplots@loc@TMPb
				% draw markers together with their plot (no matter
				% on which layer):
				\pgfplots@clip@marker@pathstrue
				\pgfkeyslet{/pgfplots/mark layer}\pgfutil@empty%
			\else
				\edef\pgfplots@loc@TMPb{\pgfkeysvalueof{/pgfplots/on layer}}%
				\ifx\pgfplots@loc@TMPa\pgfplots@loc@TMPb
					% nothing to do; they are on the same layer
					% anyway: (this is the same as 'like plot'
					\pgfplots@clip@marker@pathstrue
					\pgfkeyslet{/pgfplots/mark layer}\pgfutil@empty%
				\else
					% OK, marks will be plotted on their own layer.
				\fi
			\fi
		\fi
	\else
		% reset its value:
		\pgfkeyslet{/pgfplots/mark layer}\pgfutil@empty%
	\fi
}%

