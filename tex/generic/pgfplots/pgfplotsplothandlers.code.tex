%--------------------------------------------
%
% Package pgfplots
%
% Provides a user-friendly interface to create function plots (normal
% plots, semi-logplots and double-logplots).
% 
% It is based on Till Tantau's PGF package.
%
% Copyright 2010 by Christian Feuers√§nger.
%
% This program is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program.  If not, see <http://www.gnu.org/licenses/>.
%
%--------------------------------------------

% 1. OVERVIEW
%
% Plot handlers are extended versions of the plot handlers of PGF with
% backwards compatibility.
%
% To remind ourselfes: PGF plot handlers work like this
% \pgfplotstreamstart
% \pgfplotstreampoint{...}
% \pgfplotstreampoint{...}
% \pgfplotstreampoint{...}
% \pgfplotstreampoint{...}
% \pgfplotstreamend
%
% and that's it.
%
% PGFPlots plot handlers also contain these three macros. The tasks
% are (of course) the same. In addition, they support a set of further
% macros for every plot handler:
%
% \pgfplotsplothandlersurveystart
% \pgfplotsplothandlersurveypoint
% \pgfplotsplothandlersurveyend
%
% and serialization methods
% \pgfplotsplothandlerserializepointto
% \pgfplotsplothandlerdeserializepointfrom
% \pgfplotsplothandlerserializestateto
% \pgfplotsplothandlerdeserializepointfrom
%
% The idea is as follows:
% During \addplot, PGFPLots performs a survey phase. Survey means:
% nothing will be drawn, only stats will be collected. In this phase,
% the \pgfplotsplothandlersurvey* methods will be invoked; followed by
% a serialization.
%
% Then, when every plot has been surveyed, PGFPlots calls
% \pgfplotsplothandlerdeserializestatefrom{<serialized state>}
% \pgfplotstreamstart
% foreach <serizalized point> {
% 	\pgfplotsplothandlerdeserializepointfrom{<serialized point>}
% 	apply data transformations 
% 	handle plot marks
% 	\pgfplotstreampoint{\pgfplotsqpointxy{<x>}{<y}}
% }
% \pgfplotstreamend
%
% See below for details about the survey phase and the visualization
% phase and the API of an axis.
%
% Thus, the PGF basic level streams can (but don't need to) make use
% of the macros assigned by the
% \pgfplotsplothandlerdeserializepointfrom and
% \pgfplotsplothandlerdeserializestatefrom.
%
% Furthermore, a plot handler *can* redefine any of the survey and/or
% serialization methods to add further functionality. But it doesn't
% need to, it's ok if it only relies on x,y as standard pgf plot
% handlers do.
%
% If it overwrites something, it should do so in its main method, the
% one in which it also defines the \pgf@plotstreamstart etc. methods
% (see pgfmoduleplot.code.tex for example). BUT: do NOT overwrite
% these methods globally!
%
% 2. THE SURVEY PHASE:
%   The survey phase works as follows.
%   PRECONDITION:
%   	- we are `inside' of an axis.
%   	- \addplot starts the survey phase.
%
%   The following happens:
%   	- the plot handler is determined and activated such that its
%   	methods are usable ("class is instantiated")
%   	- \pgfplots@PREPARE@COORD@STREAM is the internal, low level
%   	entry point where pgfplots controls the survey phase.
%   	- the coordinate input routine is initialised. It issues a
%   	series of commands (all within the *same* TeX scope):
%   		\pgfplots@coord@stream@start
%   		\pgfplots@coord@stream@coord
%   		\pgfplots@coord@stream@coord
%   		\pgfplots@coord@stream@coord
%   		\pgfplots@coord@stream@coord
%   		\pgfplots@coord@stream@coord
%   		\pgfplots@coord@stream@coord
%   		...
%   		\pgfplots@coord@stream@end
%   	- \pgfplotsplothandlersurveystart is called in
%   	\pgfplots@coord@stream@start.
%   	- \pgfplots@coord@stream@coord calls
%   	\pgfplotsplothandlersurveypoint
%   	- \pgfplots@coord@stream@end calls
%   	\pgfplotsplothandlersurveyend
%   	\pgfplotsplothandlerserializestateto<\macro>
%   	Furthermore, it remembers the <\macro> such that it can be
%   	deserialized later.
%   Then, the survey phase ends. The main point of interest is the
%   \pgfplotsplothandlersurveypoint routine, especially its
%   communication with the axis. It is described below.
%
%   POSTCONDITION:
%   	- the state of the axis is now aware of the new plot (limits,
%   	stacking, ...).
%   	- The plot's survey state is stored using its serialized
%   	representation.
%
% 2.1 The API of an axis
%
% As described above, the coordinate input routine fires a lot of
% \pgfplots@coord@stream@coord commands, which, in turn, invoke
% \pgfplotsplothandlersurveypoint. Somehow this should update the
% axis' state to reflect each point. But the 'data point' is a rather
% abstract thing. Usually, it will contain at least (x,y) (or maybe z)
% coordinates. But it may be more complex.
%
% So, the coordinate input routine provides whatever the user has
% chosen. Let's assume, we are using \addplot table. Then, we can 
% access every cell in the current row (using \thisrow{<colname>} for
% example). The plot handler knows how to extract its information from
% this state. In general, the following steps are taken:
% - the plot handler assembles coordinates.
% - every assembled coordinate should be reported to the axis by
%   defining \pgfplots@current@point@[xyz] to its coordinates and
%   calling
%   \pgfplotsaxisparsecoordinate{}
%   This will apply coordinate filters, parse the single coordinates
%   and apply high level transformations and any logarithms.
%   It is some sort of advanced coordinate parser which works only for 
%   (x,y) or for (x,y,z).
%   It yields (x,y,z). But the axis might need to change its
%   components! Thus, you also need to call
%   \pgfplotsaxispreparecoordinate{}.
%   This will, for example, apply the "stack plots" feature.
%
%   If necessary, the plot handler calls
%   \pgfplotsaxisparsecoordinate{} and
%   \pgfplotsaxispreparecoordinate{} multiple times, ones for each
%   encountered coordinate.
%
%	It might occasionally be too much to call
%	\pgfplotsaxispreparecoordinate.
%
%   It might happen that a coordinate filter discards a coordinate.
%   This is returned in the \ifpgfplotsaxisparsecoordinateok boolean
%   and has to be checked by the plot handler.
%
% - the plot handler knows which of the coordinates contribute to the
%   final plot. It invokes
%   \ifpgfplotsaxisparsecoordinateok
%   	\pgfplotsaxisupdatelimitsforcoordinate{<x>}{<y>}{<z>}
%   \fi
%   for each of these coordinates. This has to be done for final
%   coordinates only, i.e. after \pgfplotsaxispreparecoordinate.
%
% - eventually, the plot handler is satisfied and considers a data
%   point as "readily surveyed". It is allowed if this does *not*
%   happen inside of \pgfplotsplothandlersurveypoint, but it must
%   happen before \pgfplotsplothandlersurveyend is finished.
%   
%   The plot handler invokes \pgfplotsaxisdatapointsurveyed.
%   This tells the axis that it can perform its own surveying tasks
%   (see below) and furthermore, that it can serialize the data point.
%   Consequently, it will invoke
%   \pgfplotsplothandlerserializepointto{<\macro>} 
%   and it will remember that \macro internally. This serialization is
%   employed to place plot marks and to apply z buffering techniques
%   (that's why it is done by the axis and not by the plot handler on
%   its own).
%
%   The axis does its own surveying task, initiated by
%   \pgfplotsaxisdatapointsurveyed (which is, turn, invoked by the
%   plot handler). This command handles the |point meta| feature, that
%   is: it queries the |point meta| input source and updates the meta
%   limits. Furthermore, the error bar feature is processed at this
%   point (using the final data point's (x,y,z) coordinates as basis).
%   The |xtick=data| feature is also prepared at this stage.
%
% - Later, the coordinate input routine invokes
%   \pgfplots@coord@stream@end indicating the end-of-input. This will
%   finalize the survey phase.
%
% A simple example looks like this:
% \pgfplotsplothandlersurveystart: does nothing in the simple example.
% \pgfplotsplothandlersurveypoint:
%   parses the input format somehow to get (x,y,z) in raw, symbolic format
%   calls \pgfplotsaxisparsecoordinate
% 	calls \pgfplotsaxispreparecoordinate
% 	calls \ifpgfplotsaxisparsecoordinateok	\pgfplotsaxisupdatelimitsforcoordinate{<x>}{<y>}{<z} \fi
% 	calls \pgfplotsaxisdatapointsurveyed
% \pgfplotsplothandlersurveyend: does nothing in the simple example.
%
% A further survey phase API function is
% \pgfplotsplothandlersurveyaddoptions{<options>}
% which allows to change the current plot style from within API
% functions. It sets <options> and remembers them for the
% visualization phase.
%
% In fact, this is more or less the initial configuration used for
% lineto or similar plot handlers.
%
%
% 3. Details about the VISUALIZATION phase
%
% The visualization phase consists of
% <installation of the plot handler>
% \pgfplotstreamstart
% foreach serialized coordinate {
% 	pgfplots calls \pgfplotsplothandlerdeserializestatefrom{<serialized repr>}
% 	pgfplots calls \pgfplotsaxisvisphasetransformcoordinate
% 	pgfplots calls \pgfplotsaxisvisphasepreparedatapoint
% 	\pgfplotstreampoint
% }
% \pgfplotstreamend
%
% User defined plot handlers might need to invoke
% \pgfplotsaxisvisphasetransformcoordinate on their own.
%
% During the visualization phase, you can also use
% \pgfplotsaxisvisphasetransformpointmeta to set up point meta.
% Use this only if there *is* point meta, see
% \pgfplotsaxisifhaspointmeta{<true code>}{<false code>}.
%
% There is also
% \pgfplotsaxisupdatelimitsforpointmeta{<meta>},
% provided there is a point meta input handler (which is numeric).
% Otherwise, the command is equal to \relax.


% Resets the plot handler routines.
%
% This is necessary before installing a new plot handler!
\def\pgfplotsresetplothandler{%
	\let\pgfplotsplothandlersurveystart=\pgfplotsplothandlersurveystart@default
	\let\pgfplotsplothandlersurveyend=\pgfplotsplothandlersurveyend@default
	\let\pgfplotsplothandlersurveypoint=\pgfplotsplothandlersurveypoint@default
	\let\pgfplotsplothandlerserializepointto=\pgfplotsplothandlerserializepointto@default
	\let\pgfplotsplothandlerdeserializepointfrom=\pgfplotsplothandlerdeserializepointfrom@default
	\let\pgfplotsplothandlerserializestateto=\pgfplotsplothandlerserializestateto@default
	\let\pgfplotsplothandlerdeserializestatefrom=\pgfplotsplothandlerdeserializestatefrom@default
}%

% \pgfplotsplothandlersurveystart
\def\pgfplotsplothandlersurveystart@default{}%

% \pgfplotsplothandlersurveyend
% Called at the end of each survey phase.
\def\pgfplotsplothandlersurveyend@default{}

% \pgfplotsplothandlersurveypoint is called for each encountered data
% point.
%
% The data point as such is available using the current state of any
% macros which are assigned during the survey phase (during \addplot).
% This includes any table macros etc.
% PGFPlots stores the x,y and z coordinates into \pgfplots@current@point@[xyz]. 
% The point meta coordinate is in \pgfplots@current@point@meta.
%
% Note that since any currently assigned macro can be used here, the
% new DV engine of PGF is also valid (and will be supported
% eventually). This DV engine stores data point entries in keys,
% namely those in the key path /data point. See the pgf manual.
\def\pgfplotsplothandlersurveypoint@default{%
	\pgfplotsaxisparsecoordinate
	\pgfplotsaxispreparecoordinate
	\ifpgfplotsaxisparsecoordinateok
		\pgfplotsaxisupdatelimitsforcoordinate\pgfplots@current@point@x\pgfplots@current@point@y\pgfplots@current@point@z
	\fi
	\pgfplotsaxisdatapointsurveyed
}%

% \pgfplotsplothandlerserializepointto{<\macro>}
% should save a complete data point to <\macro> such that it can be
% de-serialized later.
%
% #1: a macro name. Will be filled with (expandable) data.
% 	The format can be arbitrary, but you should be able to extra it.
%
% @PRECONDITION
% 	this macro will be invoked in a context where the current data
% 	point has been processed completely, including any preparations.
% 	The required data which should be saved depends on the plot
% 	handler. Usually, all plot handlers require
% 	\pgfplots@current@point@[xyz] and \pgfplots@current@point@meta.
%   This macro should only assign keys which have been defined or
%   validated by any of the plot handler relevant methods (including
%   the de-serialization or survey methods).
\def\pgfplotsplothandlerserializepointto@default#1{%
	% Store normalized point for list:
	% We need
	% xi,yi,zi,mi;
	% where zi and mi may be empty. mi is the per-point meta
	% information. It is used for per-coordinate marker
	% modifications (like colormaps for scatter plots).
	\edef#1{\pgfplots@current@point@x,\pgfplots@current@point@y,\pgfplots@current@point@z}%
}%

% the counterpart for \pgfplotsplothandlerserializepointto.
% It should restore the state as it was before the serialization.
%
% #1: the serialized information.
\def\pgfplotsplothandlerdeserializepointfrom@default#1{%
	\expandafter\pgfplotsplothandlerdeserializepointfrom@default@#1\relax
}%

\def\pgfplotsplothandlerdeserializepointfrom@default@#1,#2,#3\relax{%
	\def\pgfplots@current@point@x{#1}%
	\def\pgfplots@current@point@y{#2}%
	\def\pgfplots@current@point@z{#3}%
}%
% \pgfplotsplothandlerserializestateto{<\macro>}
% should save the state of the current plot handler such that it can
% be de-serialized later.
%
% The state does usually NOT contain a coordinate stream, this is
% accomplished by \pgfplotsplothandlerserializepointto.
%
% #1: a macro name. Can be filled with anything, including
% non-expandable macro invocations.
\def\pgfplotsplothandlerserializestateto@default#1{%
	\def#1{}%
}%

%
\def\pgfplotsplothandlerdeserializestatefrom@default#1{%
	#1%
}%

\pgfplotsresetplothandler

% ==================================

% Defines 
% - a generic update limits routine,
%   \pgfplotsaxisupdatelimitsforcoordinate#1#2#3
%   if #3 is empty, it will assume a 2d point, otherwise a 3d point
%   and the axis will be three dimensional as well.
%   During \addplot, this auto-detection will be disabled in favor of
%   the '\addplot3' versus' \addplot' syntax.
%
\def\pgfplots@prepare@axis@API{%
	\pgfplots@curplot@threedimtrue
	\pgfplots@prepare@axis@API@
	\let\pgfplotsaxisupdatelimitsforcoordinatethreedim=\pgfplotsaxisupdatelimitsforcoordinate@
	\let\pgfplotsaxisparsecoordinatethreedim=\pgfplotsaxisparsecoordinate@
	%
	\pgfplots@curplot@threedimfalse
	\pgfplots@prepare@axis@API@
	\let\pgfplotsaxisupdatelimitsforcoordinatetwodim=\pgfplotsaxisupdatelimitsforcoordinate@
	\let\pgfplotsaxisparsecoordinatetwodim=\pgfplotsaxisparsecoordinate@
	%
	\def\pgfplotsaxisupdatelimitsforcoordinate##1##2##3{%
		\pgfplots@ifempty{##3}{%
			\pgfplotsaxisupdatelimitsforcoordinatetwodim{##1}{##2}{}%
		}{%
			\global\pgfplots@threedimtrue
			\pgfplotsaxisupdatelimitsforcoordinatethreedim{##1}{##2}{##3}%
		}%
	}%
	\def\pgfplotsaxisparsecoordinate{%
		\ifx\pgfplots@current@point@z\pgfutil@empty
			\pgfplotsaxisparsecoordinatetwodim
		\else
			\global\pgfplots@threedimtrue
			\pgfplotsaxisparsecoordinatethreedim%
		\fi
	}%
}%
\def\pgfplots@prepare@axis@API@{%
	\begingroup
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\let\E=\noexpand
	% Setup Just-In-Time-Macro Compilation:
	% I compile a set of macros which is highly optimized for this
	% particular axis configuration.
	%
	% \pgfplotsaxisupdatelimitsforcoordinate
	% Updates the current x and y limits for point (#1,#2).
	%
	% To eliminate all those case distinctions, it is created with
	% 'edef' and a lot of '\noexpand' calls here:
	%
	%
	% The point coordinates are given in floating point format (FIXME)
	%
	% Please note that if user specified limits are given, automatic
	% limits are only applied to points which fall into the user specified
	% clipping region.
	%
	% PRECONDITIONS:
	% - the input coordinates have been parsed correctly (floating point
	%   format for linear axis, log applied for logarithmic ones)
	%
	% Arguments:
	% #1,#2,#3 the x,y and z coordinate. z is ignored for 2d plots.
	\xdef\pgfplotsaxisupdatelimitsforcoordinate@##1##2##3{%
%\E\tracingmacros=2\E\tracingcommands=2
%\E\pgfplots@message{Updating limits for (##1,##2) ...}%
		%
		% VIM SEARCH PATTERN: 
		%   [^E]\zs\\\ze[^E]
		% -> this finds '\' which is neither '\E' nor is it prefixed
		%  by 'E'.
		%
		%
		%
		\E\pgfplots@update@limits@for@one@point@ISCLIPPEDfalse
		% check whether we need to clip limits:
		\ifpgfplots@clip@limits
			\ifpgfplots@autocompute@xmin
			\else
				\ifpgfplots@xislinear
					\E\pgfmathfloatlessthan@{##1}{\E\pgfplots@xmin}%
					\E\ifpgfmathfloatcomparison
						\E\pgfplots@update@limits@for@one@point@ISCLIPPEDtrue
					\E\fi
				\else
					\E\pgfplotsmathlessthan{##1}{\E\pgfplots@xmin}%
					\E\ifpgfmathfloatcomparison
						\E\pgfplots@update@limits@for@one@point@ISCLIPPEDtrue
					\E\fi
				\fi
			\fi
			\ifpgfplots@autocompute@xmax
			\else
				\ifpgfplots@xislinear
					\E\pgfmathfloatlessthan@{\E\pgfplots@xmax}{##1}%
					\E\ifpgfmathfloatcomparison
						\E\pgfplots@update@limits@for@one@point@ISCLIPPEDtrue
					\E\fi
				\else
					\E\pgfplotsmathlessthan{\E\pgfplots@xmax}{##1}%
					\E\ifpgfmathfloatcomparison
						\E\pgfplots@update@limits@for@one@point@ISCLIPPEDtrue
					\E\fi
				\fi
			\fi
			\ifpgfplots@autocompute@ymin
			\else
				\ifpgfplots@yislinear
					\E\pgfmathfloatlessthan@{##2}{\E\pgfplots@ymin}%
					\E\ifpgfmathfloatcomparison
						\E\pgfplots@update@limits@for@one@point@ISCLIPPEDtrue
					\E\fi
				\else
					\E\pgfplotsmathlessthan{##2}{\E\pgfplots@ymin}%
					\E\ifpgfmathfloatcomparison
						\E\pgfplots@update@limits@for@one@point@ISCLIPPEDtrue
					\E\fi
				\fi
			\fi
			\ifpgfplots@autocompute@ymax
			\else
				\ifpgfplots@yislinear
					\E\pgfmathfloatlessthan@{\E\pgfplots@ymax}{##2}%
					\E\ifpgfmathfloatcomparison
						\E\pgfplots@update@limits@for@one@point@ISCLIPPEDtrue
					\E\fi
				\else
					\E\pgfplotsmathlessthan{\E\pgfplots@ymax}{##2}%
					\E\ifpgfmathfloatcomparison
						\E\pgfplots@update@limits@for@one@point@ISCLIPPEDtrue
					\E\fi
				\fi
			\fi
			\ifpgfplots@curplot@threedim
				\ifpgfplots@autocompute@zmin
				\else
					\ifpgfplots@zislinear
						\E\pgfmathfloatlessthan@{##3}{\E\pgfplots@zmin}%
						\E\ifpgfmathfloatcomparison
							\E\pgfplots@update@limits@for@one@point@ISCLIPPEDtrue
						\E\fi
					\else
						\E\pgfplotsmathlessthan{##3}{\E\pgfplots@zmin}%
						\E\ifpgfmathfloatcomparison
							\E\pgfplots@update@limits@for@one@point@ISCLIPPEDtrue
						\E\fi
					\fi
				\fi
				\ifpgfplots@autocompute@zmax
				\else
					\ifpgfplots@zislinear
						\E\pgfmathfloatlessthan@{\E\pgfplots@zmax}{##3}%
						\E\ifpgfmathfloatcomparison
							\E\pgfplots@update@limits@for@one@point@ISCLIPPEDtrue
						\E\fi
					\else
						\E\pgfplotsmathlessthan{\E\pgfplots@zmax}{##3}%
						\E\ifpgfmathfloatcomparison
							\E\pgfplots@update@limits@for@one@point@ISCLIPPEDtrue
						\E\fi
					\fi
				\fi
			\fi
		\fi
		%
		%
		%
		% Update limits:
		\E\ifpgfplots@update@limits@for@one@point@ISCLIPPED
		\E\else
			\ifpgfplots@autocompute@xmin
				\ifpgfplots@xislinear
					\E\pgfplotsmathfloatmin{\E\pgfplots@xmin}{##1}%
					\E\global\E\let\E\pgfplots@xmin=\E\pgfmathresult
				\else
					\E\pgfplotsmathmin{\E\pgfplots@xmin}{##1}%
					\E\global\E\let\E\pgfplots@xmin=\E\pgfmathresult
				\fi
			\fi
			\ifpgfplots@autocompute@xmax
				\ifpgfplots@xislinear
					\E\pgfplotsmathfloatmax{\E\pgfplots@xmax}{##1}%
					\E\global\E\let\E\pgfplots@xmax=\E\pgfmathresult
				\else
					\E\pgfplotsmathmax{\E\pgfplots@xmax}{##1}%
					\E\global\E\let\E\pgfplots@xmax=\E\pgfmathresult
				\fi
			\fi
			\ifpgfplots@autocompute@ymin
				\ifpgfplots@yislinear
					\E\pgfplotsmathfloatmin{\E\pgfplots@ymin}{##2}%
					\E\global\E\let\E\pgfplots@ymin=\E\pgfmathresult
				\else
					\E\pgfplotsmathmin{\E\pgfplots@ymin}{##2}%
					\E\global\E\let\E\pgfplots@ymin=\E\pgfmathresult
				\fi
			\fi
			\ifpgfplots@autocompute@ymax
				\ifpgfplots@yislinear
					\E\pgfplotsmathfloatmax{\E\pgfplots@ymax}{##2}%
					\E\global\E\let\E\pgfplots@ymax=\E\pgfmathresult
				\else
					\E\pgfplotsmathmax{\E\pgfplots@ymax}{##2}%
					\E\global\E\let\E\pgfplots@ymax=\E\pgfmathresult
				\fi
			\fi
			\ifpgfplots@curplot@threedim
				\ifpgfplots@autocompute@zmin
					\ifpgfplots@zislinear
						\E\pgfplotsmathfloatmin{\E\pgfplots@zmin}{##3}%
						\E\global\E\let\E\pgfplots@zmin=\E\pgfmathresult
					\else
						\E\pgfplotsmathmin{\E\pgfplots@zmin}{##3}%
						\E\global\E\let\E\pgfplots@zmin=\E\pgfmathresult
					\fi
				\fi
				\ifpgfplots@autocompute@zmax
					\ifpgfplots@zislinear
						\E\pgfplotsmathfloatmax{\E\pgfplots@zmax}{##3}%
						\E\global\E\let\E\pgfplots@zmax=\E\pgfmathresult
					\else
						\E\pgfplotsmathmax{\E\pgfplots@zmax}{##3}%
						\E\global\E\let\E\pgfplots@zmax=\E\pgfmathresult
					\fi
				\fi
			\fi
		\E\fi
		%
		% Compute data range:
		\ifpgfplots@autocompute@all@limits
			% the data range will be acquired simply from the axis
			% range, see below!
		\else
			% Attention: it is only done for linear axis!
			\ifpgfplots@xislinear
				\E\pgfplotsmathfloatmin{\E\pgfplots@data@xmin}{##1}%
				\E\global\E\let\E\pgfplots@data@xmin=\E\pgfmathresult
				\E\pgfplotsmathfloatmax{\E\pgfplots@data@xmax}{##1}%
				\E\global\E\let\E\pgfplots@data@xmax=\E\pgfmathresult
			\fi
			\ifpgfplots@yislinear
				\E\pgfplotsmathfloatmin{\E\pgfplots@data@ymin}{##2}%
				\E\global\E\let\E\pgfplots@data@ymin=\E\pgfmathresult
				\E\pgfplotsmathfloatmax{\E\pgfplots@data@ymax}{##2}%
				\E\global\E\let\E\pgfplots@data@ymax=\E\pgfmathresult
			\fi
			\ifpgfplots@curplot@threedim
				\ifpgfplots@zislinear
					\E\pgfplotsmathfloatmin{\E\pgfplots@data@zmin}{##3}%
					\E\global\E\let\E\pgfplots@data@zmin=\E\pgfmathresult
					\E\pgfplotsmathfloatmax{\E\pgfplots@data@zmax}{##3}%
					\E\global\E\let\E\pgfplots@data@zmax=\E\pgfmathresult
				\fi
			\fi
		\fi
%\E\pgfplots@message{Updated limits: (\E\pgfplots@xmin,\E\pgfplots@ymin) rectangle  (\E\pgfplots@xmax,\E\pgfplots@ymax).}%
%
%\E\tracingmacros=0\E\tracingcommands=0
	}%
	%
	% A routine which parses a coordinate.
	% Here, 'coordinate' means (x,y) for a two dimensional plot and
	% '(x,y,z)' for a three dimensional one.
	%
	% The preparation consists of
	% - filtering.
	% - coordinate parsing and high level transformations.
	% - logs.
	%
	% It might happen that \pgfplotsaxisparsecoordinate is called
	% multiple times for a single data "point" (for example, a quiver
	% point might call it for the point where the vector starts and
	% where the vector ends).
	% 
	% @PRECONDITION
	% 	- the plot's survey phase is running (has already been started)
	% 	- \pgfplots@current@point@[xyz] contains the coordinates of the
	% 	point. I assume they are unparsed.
	%
	%
	% @POSTCONDITION
	% 	- the axis' state will be updated.
	% 	- the \pgfplots@current@point@[xyz] macros will contain parsed data.
	% 	- \ifpgfplotsaxisparsecoordinateok will be true if and only
	% 	if the data point has not been filtered away. If it has been
	% 	filtered away, \pgfplots@current@point@[xyz] will be empty.
	% 	- \pgfplots@current@point@[xyz]@unfiltered contain unparsed
	% 	data.
	%
	% @see \pgfplotsaxispreparecoordinate
	% @see \pgfplotsaxisdatapointsurveyed
	\xdef\pgfplotsaxisparsecoordinate@{%
		% These things are necessary for error bars and are available
		% as public results in math parser invocations (for meta and
		% filters)
		\E\let\E\pgfplots@current@point@x@unfiltered=\E\pgfplots@current@point@x
		\E\let\E\pgfplots@current@point@y@unfiltered=\E\pgfplots@current@point@y
		\E\let\E\pgfplots@current@point@z@unfiltered=\E\pgfplots@current@point@z
		\E\def\E\pgfplots@unbounded@dir{}%
		%
		\E\pgfplots@prepare@xcoord{\E\pgfplots@current@point@x}%
		\E\expandafter\E\pgfplots@invoke@filter\E\expandafter{\E\pgfmathresult}{x}%
		\E\let\E\pgfplots@current@point@x=\E\pgfmathresult
		%
		\E\pgfplots@prepare@ycoord{\E\pgfplots@current@point@y}%
		\E\expandafter\E\pgfplots@invoke@filter\E\expandafter{\E\pgfmathresult}{y}%
		\E\let\E\pgfplots@current@point@y=\E\pgfmathresult
		%
		\ifpgfplots@curplot@threedim
			\E\pgfplots@prepare@zcoord{\E\pgfplots@current@point@z}%
			\E\expandafter\E\pgfplots@invoke@filter\E\expandafter{\E\pgfmathresult}{z}%
			\E\let\E\pgfplots@current@point@z=\E\pgfmathresult
		\fi
		%
		\E\pgfplots@invoke@filter@xyz
		%
		\ifpgfplots@xislinear
			% NOTE: this handling of unbounded coords in the case of
			% LOG coords is performed directly by
			% \pgfplots@prepare@ycoord!
			\E\ifx\E\pgfplots@current@point@x\E\pgfutil@empty
			\E\else
				\E\pgfmathfloatparsenumber{\E\pgfplots@current@point@x}%
				\E\expandafter\E\pgfmathfloat@decompose@F\E\pgfmathresult\E\relax\E\c@pgf@counta
				\E\ifnum\E\c@pgf@counta>2 % this clears nan, inf and -inf points.
					\E\let\E\pgfplots@current@point@x=\E\pgfutil@empty
					\E\def\E\pgfplots@unbounded@dir{x}%
				\E\else
					\E\let\E\pgfplots@current@point@x=\E\pgfmathresult
				\E\fi
			\E\fi
		\fi
		%
		\ifpgfplots@yislinear
			\E\ifx\E\pgfplots@current@point@y\E\pgfutil@empty
			\E\else
				\E\pgfmathfloatparsenumber{\E\pgfplots@current@point@y}%
				\E\expandafter\E\pgfmathfloat@decompose@F\E\pgfmathresult\E\relax\E\c@pgf@counta
				\E\ifnum\E\c@pgf@counta>2
					\E\let\E\pgfplots@current@point@y=\E\pgfutil@empty
					\E\def\E\pgfplots@unbounded@dir{y}%
				\E\else
					\E\let\E\pgfplots@current@point@y=\E\pgfmathresult
				\E\fi
			\E\fi
		\fi
		%
		\ifpgfplots@curplot@threedim
			%
			\ifpgfplots@zislinear
				\E\ifx\E\pgfplots@current@point@z\E\pgfutil@empty
				\E\else
					\E\pgfmathfloatparsenumber{\E\pgfplots@current@point@z}%
					\E\expandafter\E\pgfmathfloat@decompose@F\E\pgfmathresult\E\relax\E\c@pgf@counta
					\E\ifnum\E\c@pgf@counta>2
						\E\let\E\pgfplots@current@point@z=\E\pgfutil@empty
						\E\def\E\pgfplots@unbounded@dir{z}%
					\E\else
						\E\let\E\pgfplots@current@point@z=\E\pgfmathresult
					\E\fi
				\E\fi
			\fi
		\fi
		%
		% check if coordinates are bounded:
		\E\pgfplotsaxisparsecoordinateoktrue
		\E\ifx\E\pgfplots@current@point@x\E\pgfutil@empty
			\E\pgfplotsaxisparsecoordinateokfalse
		\E\else
			\E\ifx\E\pgfplots@current@point@y\E\pgfutil@empty
				\E\pgfplotsaxisparsecoordinateokfalse
			\E\else
				\ifpgfplots@curplot@threedim
					\E\ifx\E\pgfplots@current@point@z\E\pgfutil@empty
						\E\pgfplotsaxisparsecoordinateokfalse
					\E\fi
				\fi
			\E\fi
		\E\fi
		%
		%
		\E\ifpgfplotsaxisparsecoordinateok
			% coordinate is bounded AND non-empty, ok.
			% insert the main 2d/3d code here:
			\ifpgfplots@apply@datatrafo
				\ifpgfplots@datascaletrafo@initialised
					% apply data transformation directly.
					\ifpgfplots@apply@datatrafo@x
						\E\pgfplots@datascaletrafo@x\E\pgfplots@current@point@x
						\E\let\E\pgfplots@current@point@x=\E\pgfmathresult
					\fi
					\ifpgfplots@apply@datatrafo@y
						\E\pgfplots@datascaletrafo@y\E\pgfplots@current@point@y
						\E\let\E\pgfplots@current@point@y=\E\pgfmathresult
					\fi
					\ifpgfplots@curplot@threedim
						\ifpgfplots@apply@datatrafo@z
							\E\pgfplots@datascaletrafo@z\E\pgfplots@current@point@z
							\E\let\E\pgfplots@current@point@z=\E\pgfmathresult
						\fi
					\fi
				\fi
			\fi
		\E\fi
	}%
	%
	\endgroup
}%

% ==================================
% The quiver plot handler.
% It draws a lot of arrows.
% Its input is (x_i,y_i); (u_i,v_i) for data point i and it draws a
% vector in direction (u_i,v_i) starting from (x_i,y_i) .
% It also supports 3D arrows (involving z_i and w_i).
 
\newif\ifpgfplots@quiver@usetikz
\newif\ifpgfplots@quiver@updatelimits

\pgfplotsset{
	% The 'quiver' plot handler for two- and three dimensional plots.
	%
	% User Interface:
	% use /pgfplots/quiver to enable the plot handler.
	% Then, provide `quiver/u value' or `quiver/u' to 
	% tell where to find the 'x' coordinates of the vectors, and similarly
	% for 'v' and 'w' instead of 'u'.
	quiver/.code={%
		\let\tikz@plot@handler=\pgfplotsplothandlerquiver
		\pgfqkeys{/pgfplots/quiver}{#1}%
	},%
	quiver/u value*/.initial=,
	quiver/v value*/.initial=,
	quiver/w value*/.initial=,
	quiver/u value is expr/.initial=0,
	quiver/v value is expr/.initial=0,
	quiver/w value is expr/.initial=0,
	quiver/u value/.code	=\pgfplots@set@source@for{quiver/u}{#1}{0},%
	quiver/u/.code			=\pgfplots@set@source@for{quiver/u}{#1}{1},%
	quiver/v value/.code	=\pgfplots@set@source@for{quiver/v}{#1}{0},%
	quiver/v/.code			=\pgfplots@set@source@for{quiver/v}{#1}{1},%
	quiver/w value/.code	=\pgfplots@set@source@for{quiver/w}{#1}{0},%
	quiver/w/.code			=\pgfplots@set@source@for{quiver/w}{#1}{1},%
	quiver/before arrow/.code=,
	quiver/after arrow/.code=,
	quiver/every arrow/.style={},
	quiver/arrow color/.initial=,
	quiver/scale arrows/.initial=1,
	quiver/update limits/.is if=pgfplots@quiver@updatelimits,
	quiver/update limits=true,
	quiver/colored/.code={%
		\def\pgfplots@loc@TMPa{#1}%
		\ifx\pgfplots@loc@TMPa\pgfutil@empty
		\else
			\pgfkeyslet{/pgfplots/quiver/arrow color}\pgfplots@loc@TMPa
			\pgfkeysalso{/pgfplots/set point meta if empty=f(x)}%
		\fi
	},%
	quiver/colored/.default=mapped color,
}%

\def\pgfplots@set@source@for#1#2#3{%
	\pgfkeyssetvalue{/pgfplots/#1 value*}{#2}%
	\pgfkeyssetvalue{/pgfplots/#1 is expr}{#3}%
}%
% To be used to create a simple parser for keys initialised by
% \pgfplots@set@source@for:
%
% #1: the key path (relative to /pgfplots/) of the data
% #2: the key name of the data
% #3: a macro name which be will defined to be a parser for the data.
%
% The parser will check whether the '#2 is expr' key is set.
% Furthermore, it defines /data point/#2 to be the result.
%
% Example:
% \pgfplots@set@source@for{hist/data}{...}
%
% ->
%  \pgfplots@prepare@source@parser@for{hist}{data}\parser
%
%  then, invoking \parser
%  will define \pgfmathresult to be the argument provided to
%  \pgfplots@set@source@for.
\def\pgfplots@prepare@source@parser@for#1#2#3{%
	\pgfkeyslet{/data point/#2}\pgfutil@empty%
	%
	\pgfkeysgetvalue{/pgfplots/#1/#2 value*}\pgfplots@loc@TMPa
	\ifx\pgfplots@loc@TMPa\pgfutil@empty
		% assume the '/data point/#1' is set by some input
		% routine.
		% Invoke math parser in this case.
		\pgfkeyssetvalue{/pgfplots/#1/#2 is expr}{1}%
	\else
		\pgfkeyslet{/data point/#2}\pgfplots@loc@TMPa
	\fi
	\if1\pgfkeysvalueof{/pgfplots/#1/#2 is expr}%
		\def#3{%
			\pgfmathparse{\pgfkeysvalueof{/data point/#2}}%
		}%
	\else
		\def#3{%
			\pgfmathfloatparsenumber{\pgfkeysvalueof{/data point/#2}}%
		}%
	\fi
}%
\def\pgfplotsplothandlerquiver{%
	\pgfplotsresetplothandler
	\let\pgf@plotstreamstart=\pgfplotsplothandlervisbegin@quiver
	\let\pgfplotsplothandlersurveystart=\pgfplotsplothandlersurveystart@quiver
	\let\pgfplotsplothandlersurveypoint=\pgfplotsplothandlersurveypoint@quiver
	\let\pgfplotsplothandlerserializepointto=\pgfplotsplothandlerserializepointto@quiver
	\let\pgfplotsplothandlerdeserializepointfrom=\pgfplotsplothandlerdeserializepointfrom@quiver
	\let\pgfplotsplothandlerquiver@vis@hook=\pgfutil@empty
	%
}%

\def\pgfplotsplothandlersurveystart@quiver{%
	\pgfkeysgetvalue{/pgfplots/quiver/scale arrows}\pgfplots@quiver@scale
	\ifx\pgfplots@quiver@scale\pgfutil@empty
	\else
		\def\pgfplots@loc@TMPa{1}%
		\ifx\pgfplots@loc@TMPa\pgfplots@quiver@scale
			\let\pgfplots@quiver@scale=\pgfutil@empty
		\else
			\pgfmathparse{\pgfplots@quiver@scale}%
			\pgfmathfloatparsenumber\pgfplots@quiver@scale
			\let\pgfplots@quiver@scale=\pgfmathresult
		\fi
	\fi
	%
	\pgfplots@prepare@source@parser@for@quiver u\pgfplots@quiver@prepare@u%
	\pgfplots@prepare@source@parser@for@quiver v\pgfplots@quiver@prepare@v%
	\pgfplots@prepare@source@parser@for@quiver w\pgfplots@quiver@prepare@w%
}%

\def\pgfplots@prepare@source@parser@for@quiver#1#2{%
	\pgfplots@prepare@source@parser@for{quiver}{#1}{#2}%
	\t@pgfplots@toka=\expandafter{#2}%
	\t@pgfplots@tokb=\expandafter{\csname pgfplots@quiver@#1\endcsname}%
	\edef#2{%
		\the\t@pgfplots@toka
		\noexpand\let\the\t@pgfplots@tokb=\noexpand\pgfmathresult
		\ifx\pgfplots@quiver@scale\pgfutil@empty
		\else
			\noexpand\pgfmathfloatmultiply@{\pgfplots@quiver@scale}{\the\t@pgfplots@tokb}%
			\noexpand\let\the\t@pgfplots@tokb=\noexpand\pgfmathresult
		\fi
	}%
}%

\def\pgfplotsplothandlersurveypoint@quiver{%
	\pgfplots@quiver@prepare@u
	\pgfplots@quiver@prepare@v
	\pgfplotsifcurplotthreedim{%
		\pgfplots@quiver@prepare@w
	}{%
		\let\pgfplots@quiver@w=\pgfutil@empty
	}%
	\pgfplotsaxisparsecoordinate
	\pgfplotsaxispreparecoordinate
	\ifpgfplotsaxisparsecoordinateok
		\pgfplotsaxisupdatelimitsforcoordinate\pgfplots@current@point@x\pgfplots@current@point@y\pgfplots@current@point@z
		%
		\pgfmathadd@{\pgfplots@quiver@u}{\pgfplots@current@point@x}%
		\let\pgfplots@quiver@u=\pgfmathresult
		\pgfmathadd@{\pgfplots@quiver@v}{\pgfplots@current@point@y}%
		\let\pgfplots@quiver@v=\pgfmathresult
		\pgfplotsifcurplotthreedim{%
			\pgfmathadd@{\pgfplots@quiver@w}{\pgfplots@current@point@z}%
			\let\pgfplots@quiver@w=\pgfmathresult
		}{}%
		\ifpgfplots@quiver@updatelimits
			\pgfplotsaxisupdatelimitsforcoordinate\pgfplots@quiver@u\pgfplots@quiver@v\pgfplots@quiver@w
		\fi
	\fi
	\pgfplotsaxisdatapointsurveyed
}%
\def\pgfplotsplothandlerserializepointto@quiver#1{%
	\edef#1{\pgfplots@current@point@x,\pgfplots@current@point@y,\pgfplots@current@point@z>\pgfplots@quiver@u,\pgfplots@quiver@v,\pgfplots@quiver@w}%
}%
\def\pgfplotsplothandlerdeserializepointfrom@quiver#1{%
	\expandafter\pgfplotsplothandlerdeserializepointfrom@quiver@#1\relax
}%
\def\pgfplotsplothandlerdeserializepointfrom@quiver@#1,#2,#3>#4,#5,#6\relax{%
	\def\pgfplots@current@point@x{#1}%
	\def\pgfplots@current@point@y{#2}%
	\def\pgfplots@current@point@z{#3}%
	\def\pgfplots@quiver@u{#4}%
	\def\pgfplots@quiver@v{#5}%
	\def\pgfplots@quiver@w{#6}%
}%
\def\pgfplotsplothandlervisbegin@quiver{%
	\def\pgfplots@quiver@has@handled@point@meta{0}%
	\pgfkeysgetvalue{/pgfplots/quiver/arrow color}\pgfplots@quiver@color
	\ifx\pgfplots@quiver@color\pgfutil@empty
	\else
		% prepare the color data and define 'mapped color':
		\def\pgfplots@quiver@has@handled@point@meta{1}%
		\expandafter\def\expandafter\pgfplotsplothandlerquiver@vis@hook\expandafter{%
			\pgfplotsplothandlerquiver@vis@hook
			\pgfplotsaxisvisphasetransformpointmeta
			\pgfplotscolormapdefinemappedcolor{\pgfplotspointmetatransformed}%
		}%
		% SEE BELOW AS WELL FOR HOW TO ENABLE THE COLOR.
	\fi
	%
	%
	\pgfkeysgetvalue{/pgfplots/quiver/every arrow/.@cmd}\pgfplots@quiver@everyarrow
	\ifx\pgfplots@quiver@everyarrow\pgfplots@empty@style@key
		% use PGF basic level methods to set the 'arrow color':
		\ifx\pgfplots@quiver@color\pgfutil@empty
		\else
			\expandafter\def\expandafter\pgfplotsplothandlerquiver@vis@hook\expandafter{%
				\pgfplotsplothandlerquiver@vis@hook
				\pgfsetstrokecolor{\pgfkeysvalueof{/pgfplots/quiver/arrow color}}%
				% for arrow heads:
				\pgfsetfillcolor{\pgfkeysvalueof{/pgfplots/quiver/arrow color}}%
			}%
		\fi
	\else
		% 'every arrow' should provide a high level user interface.
		% Use tikz instead of pgf. This is slower, but more powerfull.
		\pgfplots@quiver@usetikztrue
		\pgfplotsaxisifhaspointmeta{%
			% ASSERT(mapped color is available)
			\if0\pgfplots@quiver@has@handled@point@meta%
				% -> define mapped color
				\expandafter\def\expandafter\pgfplotsplothandlerquiver@vis@hook\expandafter{%
					\pgfplotsplothandlerquiver@vis@hook
					\pgfplotsaxisvisphasetransformpointmeta
					\pgfplotscolormapdefinemappedcolor{\pgfplotspointmetatransformed}%
				}%
				\def\pgfplots@quiver@has@handled@point@meta{1}%
			\fi
		}{}%
		% use tikz methods to set the 'arrow color':
		\ifx\pgfplots@quiver@color\pgfutil@empty
		\else
			\t@pgfplots@toka=\expandafter{\pgfplots@quiver@color}%
			\edef\pgfplots@loc@TMPa{\noexpand\pgfkeysalso{/pgfplots/quiver/every arrow/.prefix style={\the\t@pgfplots@toka}}}%
			\pgfplots@loc@TMPa
		\fi
	\fi
	%
	\global\let\pgf@plotstreampoint=\pgfplotsplothandlerquiver@vis%
	\global\let\pgf@plotstreamspecial=\pgfutil@gobble%
	\global\let\pgf@plotstreamend=\relax
}%

\def\pgfplotsplothandlerquiver@vis#1{%
	\pgfkeysvalueof{/pgfplots/quiver/before arrow/.@cmd}\pgfeov
	\pgfplotsplothandlerquiver@vis@hook
	\ifpgfplots@quiver@usetikz
		\draw[/pgfplots/quiver/every arrow] \pgfextra{\pgfplotsplothandlerquiver@vis@path{#1}};
	\else
		\pgfplotsplothandlerquiver@vis@path{#1}%
		\pgfusepath{stroke}%
	\fi
	\pgfkeysvalueof{/pgfplots/quiver/after arrow/.@cmd}\pgfeov
}%
\def\pgfplotsplothandlerquiver@vis@path#1{%
	\pgfpathmoveto{#1}%
	\pgfplotsaxisvisphasetransformcoordinate\pgfplots@quiver@u\pgfplots@quiver@v\pgfplots@quiver@w
	\pgfpathlineto{%
		\pgfplotsifcurplotthreedim{%
			\pgfplotsqpointxyz\pgfplots@quiver@u\pgfplots@quiver@v\pgfplots@quiver@w
		}{%
			\pgfplotsqpointxy\pgfplots@quiver@u\pgfplots@quiver@v
		}%
	}%
}%

\newif\ifpgfplotsplothandlerhistogram@intervals
\pgfplotsset{
	hist/.code={%
		\let\tikz@plot@handler=\pgfplotsplothandlerhistogram
		\pgfqkeys{/pgfplots/hist}{#1}%
	},
	hist/data value/.code	=\pgfplots@set@source@for{hist/data}{#1}{0},%
	hist/data/.code			=\pgfplots@set@source@for{hist/data}{#1}{1},%
	hist/data={y},
	hist/bins/.initial=10,
	hist/intervals/.is if=pgfplotsplothandlerhistogram@intervals,
	hist/intervals/.default=true,
	hist/intervals=true,
	hist/handler/.style={/tikz/ybar interval},
}%
\def\pgfplotsplothandlerhistogram{%
	\pgfplotsresetplothandler
	\def\pgf@plotstreamstart{%
		\pgfplotsset{/pgfplots/hist/handler}%
		\pgfplotsresetplothandler
		\tikz@plot@handler
		\pgf@plotstreamstart
	}%
	\let\pgfplotsplothandlersurveypoint=\pgfplotsplothandlersurveypoint@hist
	\let\pgfplotsplothandlersurveystart=\pgfplotsplothandlersurveystart@hist
	\let\pgfplotsplothandlersurveyend=\pgfplotsplothandlersurveyend@hist
}%
\def\pgfplotsplothandlersurveystart@hist{%
	\pgfplots@prepare@source@parser@for{hist}{data}{\pgfplotsplothandlerhistogram@parse}%
	%
	\pgfmathfloatcreate{1}{1.0}{2147483645}%
	\let\pgfplotsplothandlerhistogram@datamin=\pgfmathresult
	\pgfmathfloatcreate{2}{1.0}{2147483645}%
	\let\pgfplotsplothandlerhistogram@datamax=\pgfmathresult
	%
	\edef\pgfplotsplothandlerhistogram@Nfixed{\pgfkeysvalueof{/pgfplots/hist/bins}}%
	\c@pgf@counta=\pgfplotsplothandlerhistogram@Nfixed\relax
	\advance\c@pgf@counta by-1
	\edef\pgfplotsplothandlerhistogram@Nmax{\the\c@pgf@counta}%
	%
	\pgfmathfloatparsenumber{\pgfplotsplothandlerhistogram@Nfixed}%
	\let\pgfplotsplothandlerhistogram@N=\pgfmathresult
	%
	\pgfplotsapplistXnewempty\pgfp@hist@@
	\def\c@pgfplotsplothandlerhistogram@num{0}%
}%

\def\pgfplotsplothandlersurveypoint@hist{%
	\pgfplotsplothandlerhistogram@parse
	\let\pgfplots@current@point@data=\pgfmathresult
	%
	\pgfmathfloatiffinite\pgfplots@current@point@data{%
		\pgfplotsmathfloatmin{\pgfplots@current@point@data}{\pgfplotsplothandlerhistogram@datamin}%
		\let\pgfplotsplothandlerhistogram@datamin=\pgfmathresult
		%
		\pgfplotsmathfloatmax{\pgfplots@current@point@data}{\pgfplotsplothandlerhistogram@datamax}%
		\let\pgfplotsplothandlerhistogram@datamax=\pgfmathresult
		%
		\pgfplotsutil@advancestringcounter\c@pgfplotsplothandlerhistogram@num
		%
		% store parsed result.
		\edef\pgfmathresult{{\pgfplots@current@point@data}}%
		\expandafter\pgfplotsapplistXpushback\expandafter{\pgfmathresult}\to\pgfp@hist@@
	}{%
	}%
}%
\def\pgfplotsplothandlersurveyend@hist{%
	\ifnum\c@pgfplotsplothandlerhistogram@num>0
		\expandafter\pgfplotsplothandlersurveyend@hist@
	\fi
}%
\def\pgfplotsplothandlersurveyend@hist@{%
	\pgfmathfloatsubtract@{\pgfplotsplothandlerhistogram@datamax}{\pgfplotsplothandlerhistogram@datamin}%
	\let\pgfplotsplothandlerhistogram@range=\pgfmathresult
	\pgfmathfloatdivide@{\pgfplotsplothandlerhistogram@range}{\pgfplotsplothandlerhistogram@N}%
	\let\pgfplotsplothandlerhistogram@h=\pgfmathresult
	\pgfmathfloatreciprocal@{\pgfplotsplothandlerhistogram@h}%
	\let\pgfplotsplothandlerhistogram@invh=\pgfmathresult
	%
	\pgfplotsarraynewempty{pgfp@hist}%
	\pgfplotsarrayresize{pgfp@hist}{\pgfplotsplothandlerhistogram@Nfixed}%
	\pgfplotsarrayforeachungrouped{pgfp@hist}\as\pgfplots@hist@count{%
		\pgfplotsarrayset{\pgfplotsarrayforeachindex}\of{pgfp@hist}\to{0}%
	}%
	%
	\pgfplotsapplistXlet\pgfplots@hist@data=\pgfp@hist@@
	\pgfplotsapplistXnewempty\pgfp@hist@@
	\expandafter\pgfplotsplothandlersurveyend@hist@loop\pgfplots@hist@data\pgfplots@EOI
	\let\pgfplots@hist@data=\relax
	%
	\pgfplotsset{/pgfplots/hist/handler}%
	\pgfplotsresetplothandler
	\tikz@plot@handler
	%
	\pgfplotsplothandlersurveystart
	%
	\let\pgfplots@current@point@z=\pgfutil@empty
	\pgfplotsarrayforeachungrouped{pgfp@hist}\as\pgfplots@hist@count{%
		\pgfplotsplothandlerhistgetintervalstartfor\pgfplotsarrayforeachindex
		\let\pgfplots@current@point@x\pgfmathresult%
		\let\pgfplots@current@point@y\pgfplots@hist@count%
		\pgfplotsplothandlersurveypoint
	}%
	\ifpgfplotsplothandlerhistogram@intervals
		% replicate last count.
		\let\pgfplots@current@point@x\pgfplotsplothandlerhistogram@datamax%
		\let\pgfplots@current@point@y\pgfplots@hist@count%
		\pgfplotsplothandlersurveypoint
	\fi
	%
	\pgfplotsplothandlersurveyend
}
\def\pgfplotsplothandlersurveyend@hist@loop#1{%
	\def\pgfplots@loc@TMPa{#1}%
	\ifx\pgfplots@loc@TMPa\pgfplots@EOI
	\else
		\pgfplotsplothandlerhistgetbinfor@{#1}%
		\expandafter\pgfplotsplothandlerhistadvancebin\expandafter{\pgfmathresult}%
		%
		\expandafter\pgfplotsplothandlersurveyend@hist@loop
	\fi
}%
\def\pgfplotsplothandlerhistadvancebin#1{%
	\pgfplotsarrayselect{#1}\of{pgfp@hist}\to\pgfplots@loc@TMPa%
	\pgfplotsutil@advancestringcounter\pgfplots@loc@TMPa
	\pgfplotsarrayletentry{#1}\of{pgfp@hist}=\pgfplots@loc@TMPa
}%
\def\pgfplotsplothandlerhistgetintervalstartfor#1{%
	\pgfmathfloatparsenumber{#1}%
	\expandafter\pgfplotsplothandlerhistgetintervalstartfor@\expandafter{\pgfmathresult}%
}%
\def\pgfplotsplothandlerhistgetintervalstartfor@#1{%
	\pgfmathfloatmultiply@{\pgfplotsplothandlerhistogram@h}{#1}%
	\expandafter\pgfmathfloatadd@\expandafter{\pgfmathresult}{\pgfplotsplothandlerhistogram@datamin}%
}%
\def\pgfplotsplothandlerhistgetbinfor#1{%
	\pgfmathfloatparsenumber{#1}%
	\expandafter\pgfplotsplothandlerhistgetbinfor@\expandafter{\pgfmathresult}%
}%
\def\pgfplotsplothandlerhistgetbinfor@#1{%
	\pgfmathfloatsubtract@{#1}{\pgfplotsplothandlerhistogram@datamin}%
	\expandafter\pgfmathfloatmultiply@\expandafter{\pgfmathresult}{\pgfplotsplothandlerhistogram@invh}%
	\pgfmathfloattofixed{\pgfmathresult}%
	\afterassignment\pgfplots@gobble@until@relax
	\c@pgf@counta=\pgfmathresult\relax
	\ifnum\pgfplotsplothandlerhistogram@Nfixed>\c@pgf@counta
		\ifnum\c@pgf@counta<0
			\def\pgfmathresult{0}%
		\fi
	\else
		\let\pgfmathresult=\pgfplotsplothandlerhistogram@Nmax
	\fi
}%

