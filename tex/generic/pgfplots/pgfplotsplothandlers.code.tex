%--------------------------------------------
%
% Package pgfplots
%
% Provides a user-friendly interface to create function plots (normal
% plots, semi-logplots and double-logplots).
% 
% It is based on Till Tantau's PGF package.
%
% Copyright 2010 by Christian Feuers√§nger.
%
% This program is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program.  If not, see <http://www.gnu.org/licenses/>.
%
%--------------------------------------------

% 1. OVERVIEW
%
% Plot handlers are extended versions of the plot handlers of PGF with
% backwards compatibility.
%
% To remind ourselfes: PGF plot handlers work like this
% \pgfplotstreamstart
% \pgfplotstreampoint{...}
% \pgfplotstreampoint{...}
% \pgfplotstreampoint{...}
% \pgfplotstreampoint{...}
% \pgfplotstreamend
%
% and that's it.
%
% PGFPlots plot handlers also contain these three macros. The tasks
% are (of course) the same. In addition, they support a set of further
% macros for every plot handler:
%
% \pgfplotsplothandlersurveystart
% \pgfplotsplothandlersurveypoint
% \pgfplotsplothandlersurveyend
%
% and serialization methods
% \pgfplotsplothandlerserializepointto
% \pgfplotsplothandlerdeserializepointfrom
% \pgfplotsplothandlerserializestateto
% \pgfplotsplothandlerdeserializepointfrom
%
% The idea is as follows:
% During \addplot, PGFPLots performs a survey phase. Survey means:
% nothing will be drawn, only stats will be collected. In this phase,
% the \pgfplotsplothandlersurvey* methods will be invoked; followed by
% a serialization.
%
% Then, when every plot has been surveyed, PGFPlots calls
% \pgfplotsplothandlerdeserializestatefrom{<serialized state>}
% \pgfplotstreamstart
% foreach <serizalized point> {
% 	\pgfplotsplothandlerdeserializepointfrom{<serialized point>}
% 	apply data transformations 
% 	handle plot marks
% 	\pgfplotstreampoint{\pgfplotsqpointxy{<x>}{<y}}
% }
% \pgfplotstreamend
%
% See below for details about the survey phase and the visualization
% phase and the API of an axis.
%
% Thus, the PGF basic level streams can (but don't need to) make use
% of the macros assigned by the
% \pgfplotsplothandlerdeserializepointfrom and
% \pgfplotsplothandlerdeserializestatefrom.
%
% Furthermore, a plot handler *can* redefine any of the survey and/or
% serialization methods to add further functionality. But it doesn't
% need to, it's ok if it only relies on x,y as standard pgf plot
% handlers do.
%
% If it overwrites something, it should do so in its main method, the
% one in which it also defines the \pgf@plotstreamstart etc. methods
% (see pgfmoduleplot.code.tex for example). BUT: do NOT overwrite
% these methods globally!
%
% 2. THE SURVEY PHASE:
%   The survey phase works as follows.
%   PRECONDITION:
%   	- we are `inside' of an axis.
%   	- \addplot starts the survey phase.
%
%   The following happens:
%   	- the plot handler is determined and activated such that its
%   	methods are usable ("class is instantiated")
%   	- \pgfplots@PREPARE@COORD@STREAM is the internal, low level
%   	entry point where pgfplots controls the survey phase.
%   	- the coordinate input routine is initialised. It issues a
%   	series of commands (all within the *same* TeX scope):
%   		\pgfplots@coord@stream@start
%   		\pgfplots@coord@stream@coord
%   		\pgfplots@coord@stream@coord
%   		\pgfplots@coord@stream@coord
%   		\pgfplots@coord@stream@coord
%   		\pgfplots@coord@stream@coord
%   		\pgfplots@coord@stream@coord
%   		...
%   		\pgfplots@coord@stream@end
%   	- \pgfplotsplothandlersurveystart is called in
%   	\pgfplots@coord@stream@start.
%   	- \pgfplots@coord@stream@coord calls
%   	\pgfplotsplothandlersurveypoint
%   	- \pgfplots@coord@stream@end calls
%   	\pgfplotsplothandlersurveyend
%   	\pgfplotsplothandlerserializestateto<\macro>
%   	Furthermore, it remembers the <\macro> such that it can be
%   	deserialized later.
%   Then, the survey phase ends. The main point of interest is the
%   \pgfplotsplothandlersurveypoint routine, especially its
%   communication with the axis. It is described below.
%
%   POSTCONDITION:
%   	- the state of the axis is now aware of the new plot (limits,
%   	stacking, ...).
%   	- The plot's survey state is stored using its serialized
%   	representation.
%
% 2.1 The API of an axis
%
% As described above, the coordinate input routine fires a lot of
% \pgfplots@coord@stream@coord commands, which, in turn, invoke
% \pgfplotsplothandlersurveypoint. Somehow this should update the
% axis' state to reflect each point. But the 'data point' is a rather
% abstract thing. Usually, it will contain at least (x,y) (or maybe z)
% coordinates. But it may be more complex.
%
% So, the coordinate input routine provides whatever the user has
% chosen. Let's assume, we are using \addplot table. Then, we can 
% access every cell in the current row (using \thisrow{<colname>} for
% example). The plot handler knows how to extract its information from
% this state. In general, the following steps are taken:
% - the plot handler assembles coordinates.
% - every assembled coordinate should be reported to the axis by
%   defining \pgfplots@current@point@[xyz] to its coordinates and
%   calling
%   \pgfplotsaxisparsecoordinate{}
%   This will apply coordinate filters, parse the single coordinates
%   and apply high level transformations and any logarithms.
%   It is some sort of advanced coordinate parser which works only for 
%   (x,y) or for (x,y,z).
%   It yields (x,y,z). But the axis might need to change its
%   components! Thus, you also need to call
%   \pgfplotsaxispreparecoordinate{}.
%   This will, for example, apply the "stack plots" feature.
%
%   If necessary, the plot handler calls
%   \pgfplotsaxisparsecoordinate{} and
%   \pgfplotsaxispreparecoordinate{} multiple times, ones for each
%   encountered coordinate.
%
%	It might occasionally be too much to call
%	\pgfplotsaxispreparecoordinate.
%
%   It might happen that a coordinate filter discards a coordinate.
%   This is returned in the \ifpgfplotsaxisparsecoordinateok boolean
%   and has to be checked by the plot handler.
%
% - the plot handler knows which of the coordinates contribute to the
%   final plot. It invokes
%   \ifpgfplotsaxisparsecoordinateok
%   	\pgfplotsaxisupdatelimitsforcoordinate{<x>}{<y>}{<z>}
%   \fi
%   for each of these coordinates. This has to be done for final
%   coordinates only, i.e. after \pgfplotsaxispreparecoordinate.
%
% - eventually, the plot handler is satisfied and considers a data
%   point as "readily surveyed". It is allowed if this does *not*
%   happen inside of \pgfplotsplothandlersurveypoint, but it must
%   happen before \pgfplotsplothandlersurveyend is finished.
%   
%   The plot handler invokes \pgfplotsaxisdatapointsurveyed.
%   This tells the axis that it can perform its own surveying tasks
%   (see below) and furthermore, that it can serialize the data point.
%   Consequently, it will invoke
%   \pgfplotsplothandlerserializepointto{<\macro>} 
%   and it will remember that \macro internally. This serialization is
%   employed to place plot marks and to apply z buffering techniques
%   (that's why it is done by the axis and not by the plot handler on
%   its own).
%
%   The axis does its own surveying task, initiated by
%   \pgfplotsaxisdatapointsurveyed (which is, turn, invoked by the
%   plot handler). This command handles the |point meta| feature, that
%   is: it queries the |point meta| input source and updates the meta
%   limits. Furthermore, the error bar feature is processed at this
%   point (using the final data point's (x,y,z) coordinates as basis).
%   The |xtick=data| feature is also prepared at this stage.
%
% - Later, the coordinate input routine invokes
%   \pgfplots@coord@stream@end indicating the end-of-input. This will
%   finalize the survey phase.
%
% A simple example looks like this:
% \pgfplotsplothandlersurveystart: does nothing in the simple example.
% \pgfplotsplothandlersurveypoint:
%   parses the input format somehow to get (x,y,z) in raw, symbolic format
%   calls \pgfplotsaxisparsecoordinate
% 	calls \pgfplotsaxispreparecoordinate
% 	calls \ifpgfplotsaxisparsecoordinateok	\pgfplotsaxisupdatelimitsforcoordinate{<x>}{<y>}{<z} \fi
% 	calls \pgfplotsaxisdatapointsurveyed
% \pgfplotsplothandlersurveyend: does nothing in the simple example.
%
% In fact, this is more or less the initial configuration used for
% lineto or similar plot handlers.
%
%
% 3. Details about the VISUALIZATION phase
%
% The visualization phase consists of
% <installation of the plot handler>
% \pgfplotstreamstart
% foreach serialized coordinate {
% 	pgfplots calls \pgfplotsplothandlerdeserializestatefrom{<serialized repr>}
% 	pgfplots calls \pgfplotsaxisvisphasetransformcoordinate
% 	pgfplots calls \pgfplotsaxisvisphasepreparedatapoint
% 	\pgfplotstreampoint
% }
% \pgfplotstreamend
%
% User defined plot handlers might need to invoke
% \pgfplotsaxisvisphasetransformcoordinate on their own.
%
% During the visualization phase, you can also use
% \pgfplotsaxisvisphasetransformpointmeta to set up point meta.
% Use this only if there *is* point meta, see
% \pgfplotsaxisifhaspointmeta{<true code>}{<false code>}.
%
% There is also
% \pgfplotsaxisupdatelimitsforpointmeta{<meta>},
% provided there is a point meta input handler (which is numeric).
% Otherwise, the command is equal to \relax.


% Called at the start of each survey phase.
\def\pgfplotsplothandlersurveystart{}%

% Called at the end of each survey phase.
\def\pgfplotsplothandlersurveyend{}%

% \pgfplotsplothandlersurveypoint is called for each encountered data
% point.
%
% The data point as such is available using the current state of any
% macros which are assigned during the survey phase (during \addplot).
% This includes any table macros etc.
% PGFPlots stores the x,y and z coordinates into \pgfplots@current@point@[xyz]. 
% The point meta coordinate is in \pgfplots@current@point@meta.
%
% Note that since any currently assigned macro can be used here, the
% new DV engine of PGF is also valid (and will be supported
% eventually). This DV engine stores data point entries in keys,
% namely those in the key path /data point. See the pgf manual.
\def\pgfplotsplothandlersurveypoint@genericimpl{%
	\pgfplotsaxisparsecoordinate
	\pgfplotsaxispreparecoordinate
	\ifpgfplotsaxisparsecoordinateok
		\pgfplotsaxisupdatelimitsforcoordinate\pgfplots@current@point@x\pgfplots@current@point@y\pgfplots@current@point@z
	\fi
	\pgfplotsaxisdatapointsurveyed
}%
\let\pgfplotsplothandlersurveypoint=\pgfplotsplothandlersurveypoint@genericimpl

% \pgfplotsplothandlerserializepointto{<\macro>}
% should save a complete data point to <\macro> such that it can be
% de-serialized later.
%
% #1: a macro name. Will be filled with (expandable) data.
% 	The format can be arbitrary, but you should be able to extra it.
%
% @PRECONDITION
% 	this macro will be invoked in a context where the current data
% 	point has been processed completely, including any preparations.
% 	The required data which should be saved depends on the plot
% 	handler. Usually, all plot handlers require
% 	\pgfplots@current@point@[xyz] and \pgfplots@current@point@meta.
%   This macro should only assign keys which have been defined or
%   validated by any of the plot handler relevant methods (including
%   the de-serialization or survey methods).
\def\pgfplotsplothandlerserializepointto@genericimpl#1{%
	% Store normalized point for list:
	% We need
	% xi,yi,zi,mi;
	% where zi and mi may be empty. mi is the per-point meta
	% information. It is used for per-coordinate marker
	% modifications (like colormaps for scatter plots).
	\edef#1{\pgfplots@current@point@x,\pgfplots@current@point@y,\pgfplots@current@point@z}%
}%
\let\pgfplotsplothandlerserializepointto=\pgfplotsplothandlerserializepointto@genericimpl

% the counterpart for \pgfplotsplothandlerserializepointto.
% It should restore the state as it was before the serialization.
%
% #1: the serialized information.
\def\pgfplotsplothandlerdeserializepointfrom@genericimpl#1{%
	\expandafter\pgfplotsplothandlerdeserializepointfrom@genericimpl@#1\relax
}%
\let\pgfplotsplothandlerdeserializepointfrom=\pgfplotsplothandlerdeserializepointfrom@genericimpl

\def\pgfplotsplothandlerdeserializepointfrom@genericimpl@#1,#2,#3\relax{%
	\def\pgfplots@current@point@x{#1}%
	\def\pgfplots@current@point@y{#2}%
	\def\pgfplots@current@point@z{#3}%
}%
% \pgfplotsplothandlerserializestateto{<\macro>}
% should save the state of the current plot handler such that it can
% be de-serialized later.
%
% The state does usually NOT contain a coordinate stream, this is
% accomplished by \pgfplotsplothandlerserializepointto.
%
% #1: a macro name. Can be filled with anything, including
% non-expandable macro invocations.
\def\pgfplotsplothandlerserializestateto@genericimpl#1{%
	\def#1{}%
}%
\let\pgfplotsplothandlerserializestateto=\pgfplotsplothandlerserializestateto@genericimpl

%
\def\pgfplotsplothandlerdeserializestatefrom@genericimpl#1{%
	#1%
}%
\let\pgfplotsplothandlerdeserializestatefrom=\pgfplotsplothandlerdeserializestatefrom@genericimpl



% ==================================
% The quiver plot handler.
% It draws a lot of arrows.
% Its input is (x_i,y_i); (u_i,v_i) for data point i and it draws a
% vector in direction (u_i,v_i) starting from (x_i,y_i) .
% It also supports 3D arrows (involving z_i and w_i).
 
\newif\ifpgfplots@quiver@usetikz
\newif\ifpgfplots@quiver@updatelimits

% The 'quiver' plot handler for two- and three dimensional plots.
%
% User Interface:
% use /pgfplots/quiver to enable the plot handler.
% Then, provide `quiver/u value' or `quiver/u' to 
% tell where to find the 'x' coordinates of the vectors, and similarly
% for 'v' and 'w' instead of 'u'.
\pgfplotsset{
	quiver/.code={%
		\let\tikz@plot@handler=\pgfplotsplothandlerquiver
	},%
	quiver/u value*/.initial=,
	quiver/v value*/.initial=,
	quiver/w value*/.initial=,
	quiver/u value is expr/.initial=0,
	quiver/v value is expr/.initial=0,
	quiver/w value is expr/.initial=0,
	quiver/u value/.code	=\pgfplots@quiver@pgfkeys@src{#1}{u}{0},%
	quiver/u/.code			=\pgfplots@quiver@pgfkeys@src{#1}{u}{1},%
	quiver/v value/.code	=\pgfplots@quiver@pgfkeys@src{#1}{v}{0},%
	quiver/v/.code			=\pgfplots@quiver@pgfkeys@src{#1}{v}{1},%
	quiver/w value/.code	=\pgfplots@quiver@pgfkeys@src{#1}{w}{0},%
	quiver/w/.code			=\pgfplots@quiver@pgfkeys@src{#1}{w}{1},%
	quiver/before arrow/.code=,
	quiver/after arrow/.code=,
	quiver/every arrow/.style={},
	quiver/arrow color/.initial=,
	quiver/scale arrows/.initial=1,
	quiver/update limits/.is if=pgfplots@quiver@updatelimits,
	quiver/update limits=true,
	quiver/colored/.code={%
		\def\pgfplots@loc@TMPa{#1}%
		\ifx\pgfplots@loc@TMPa\pgfutil@empty
		\else
			\pgfkeyslet{/pgfplots/quiver/arrow color}\pgfplots@loc@TMPa
			\pgfkeysalso{/pgfplots/set point meta if empty=f(x)}%
		\fi
	},%
	quiver/colored/.default=mapped color,
}%

\def\pgfplots@quiver@pgfkeys@src#1#2#3{%
	\pgfkeyssetvalue{/pgfplots/quiver/#2 value*}{#1}%
	\pgfkeyssetvalue{/pgfplots/quiver/#2 is expr}{#3}%
}%

\def\pgfplotsplothandlerquiver{%
	\def\pgf@plotstreamstart{%
		\global\let\pgf@plotstreampoint=\pgfplotsplothandlerquiver@vis%
		\global\let\pgf@plotstreamspecial=\pgfutil@gobble%
		\global\let\pgf@plotstreamend=\relax
	}%
	\let\pgfplotsplothandlersurveypoint=\pgfplotsplothandlersurveypoint@quiver
	\let\pgfplotsplothandlerserializepointto=\pgfplotsplothandlerserializepointto@quiver
	\let\pgfplotsplothandlerdeserializepointfrom=\pgfplotsplothandlerdeserializepointfrom@quiver
	\let\pgfplotsplothandlerquiver@vis@hook=\pgfutil@empty
	%
	\def\pgfplots@quiver@has@handled@point@meta{0}%
	\pgfkeysgetvalue{/pgfplots/quiver/arrow color}\pgfplots@quiver@color
	\ifx\pgfplots@quiver@color\pgfutil@empty
	\else
		% prepare the color data and define 'mapped color':
		\def\pgfplots@quiver@has@handled@point@meta{1}%
		\expandafter\def\expandafter\pgfplotsplothandlerquiver@vis@hook\expandafter{%
			\pgfplotsplothandlerquiver@vis@hook
			\pgfplotsaxisvisphasetransformpointmeta
			\pgfplotscolormapdefinemappedcolor{\pgfplotspointmetatransformed}%
		}%
		% SEE BELOW AS WELL FOR HOW TO ENABLE THE COLOR.
	\fi
	%
	%
	\pgfkeysgetvalue{/pgfplots/quiver/every arrow/.@cmd}\pgfplots@quiver@everyarrow
	\ifx\pgfplots@quiver@everyarrow\pgfplots@empty@style@key
		% use PGF basic level methods to set the 'arrow color':
		\ifx\pgfplots@quiver@color\pgfutil@empty
		\else
			\expandafter\def\expandafter\pgfplotsplothandlerquiver@vis@hook\expandafter{%
				\pgfplotsplothandlerquiver@vis@hook
				\pgfsetstrokecolor{\pgfkeysvalueof{/pgfplots/quiver/arrow color}}%
				% for arrow heads:
				\pgfsetfillcolor{\pgfkeysvalueof{/pgfplots/quiver/arrow color}}%
			}%
		\fi
	\else
		% 'every arrow' should provide a high level user interface.
		% Use tikz instead of pgf. This is slower, but more powerfull.
		\pgfplots@quiver@usetikztrue
		\pgfplotsaxisifhaspointmeta{%
			% ASSERT(mapped color is available)
			\if0\pgfplots@quiver@has@handled@point@meta%
				% -> define mapped color
				\expandafter\def\expandafter\pgfplotsplothandlerquiver@vis@hook\expandafter{%
					\pgfplotsplothandlerquiver@vis@hook
					\pgfplotsaxisvisphasetransformpointmeta
					\pgfplotscolormapdefinemappedcolor{\pgfplotspointmetatransformed}%
				}%
				\def\pgfplots@quiver@has@handled@point@meta{1}%
			\fi
		}{}%
		% use tikz methods to set the 'arrow color':
		\ifx\pgfplots@quiver@color\pgfutil@empty
		\else
			\t@pgfplots@toka=\expandafter{\pgfplots@quiver@color}%
			\edef\pgfplots@loc@TMPa{\noexpand\pgfkeysalso{/pgfplots/quiver/every arrow/.prefix style={\the\t@pgfplots@toka}}}%
			\pgfplots@loc@TMPa
		\fi
	\fi
	%
	\pgfkeysgetvalue{/pgfplots/quiver/scale arrows}\pgfplots@quiver@scale
	\ifx\pgfplots@quiver@scale\pgfutil@empty
	\else
		\def\pgfplots@loc@TMPa{1}%
		\ifx\pgfplots@loc@TMPa\pgfplots@quiver@scale
			\let\pgfplots@quiver@scale=\pgfutil@empty
		\else
			\pgfmathparse{\pgfplots@quiver@scale}%
			\let\pgfplots@quiver@scale=\pgfmathresult
		\fi
	\fi
	%
	\pgfkeyslet{/data point/u}\pgfutil@empty%
	\pgfkeyslet{/data point/v}\pgfutil@empty%
	\pgfkeyslet{/data point/w}\pgfutil@empty%
	\pgfplots@quiver@prepare@src u%
	\pgfplots@quiver@prepare@src v%
	\pgfplots@quiver@prepare@src w%
}%
\def\pgfplots@quiver@prepare@src#1{%
	\pgfkeysgetvalue{/pgfplots/quiver/#1 value*}\pgfplots@loc@TMPa
	\t@pgfplots@tokb=\expandafter{\csname pgfplots@quiver@#1\endcsname}%
	\ifx\pgfplots@loc@TMPa\pgfutil@empty
		% assume the '/data point/#1' is set by some input
		% routine.
		% Invoke math parser in this case.
		\pgfkeyssetvalue{/pgfplots/quiver/#1 is expr}{1}%
	\else
		\pgfkeyslet{/data point/#1}\pgfplots@loc@TMPa
	\fi
	\if1\pgfkeysvalueof{/pgfplots/quiver/#1 is expr}%
		\t@pgfplots@toka={%
			\pgfmathparse{\pgfkeysvalueof{/data point/#1}}%
		}%
	\else
		\t@pgfplots@toka={%
			\pgfmathfloatparsenumber{\pgfkeysvalueof{/data point/#1}}%
		}%
	\fi
	\expandafter\edef\csname pgfplots@quiver@prepare@#1\endcsname{%
		\the\t@pgfplots@toka
		\noexpand\let\the\t@pgfplots@tokb=\noexpand\pgfmathresult
		\ifx\pgfplots@quiver@scale\pgfutil@empty
		\else
			\noexpand\pgfmathmultiply@{\pgfplots@quiver@scale}{\the\t@pgfplots@tokb}%
			\noexpand\let\the\t@pgfplots@tokb=\noexpand\pgfmathresult
		\fi
	}%
}%

\def\pgfplotsplothandlersurveypoint@quiver{%
	\pgfplots@quiver@prepare@u
	\pgfplots@quiver@prepare@v
	\pgfplotsifcurplotthreedim{%
		\pgfplots@quiver@prepare@w
	}{%
		\let\pgfplots@quiver@w=\pgfutil@empty
	}%
	\pgfplotsaxisparsecoordinate
	\pgfplotsaxispreparecoordinate
	\ifpgfplotsaxisparsecoordinateok
		\pgfplotsaxisupdatelimitsforcoordinate\pgfplots@current@point@x\pgfplots@current@point@y\pgfplots@current@point@z
		%
		\pgfmathadd@{\pgfplots@quiver@u}{\pgfplots@current@point@x}%
		\let\pgfplots@quiver@u=\pgfmathresult
		\pgfmathadd@{\pgfplots@quiver@v}{\pgfplots@current@point@y}%
		\let\pgfplots@quiver@v=\pgfmathresult
		\pgfplotsifcurplotthreedim{%
			\pgfmathadd@{\pgfplots@quiver@w}{\pgfplots@current@point@z}%
			\let\pgfplots@quiver@w=\pgfmathresult
		}{}%
		\ifpgfplots@quiver@updatelimits
			\pgfplotsaxisupdatelimitsforcoordinate\pgfplots@quiver@u\pgfplots@quiver@v\pgfplots@quiver@w
		\fi
	\fi
	\pgfplotsaxisdatapointsurveyed
}%
\def\pgfplotsplothandlerserializepointto@quiver#1{%
	\edef#1{\pgfplots@current@point@x,\pgfplots@current@point@y,\pgfplots@current@point@z>\pgfplots@quiver@u,\pgfplots@quiver@v,\pgfplots@quiver@w}%
}%
\def\pgfplotsplothandlerdeserializepointfrom@quiver#1{%
	\expandafter\pgfplotsplothandlerdeserializepointfrom@quiver@#1\relax
}%
\def\pgfplotsplothandlerdeserializepointfrom@quiver@#1,#2,#3>#4,#5,#6\relax{%
	\def\pgfplots@current@point@x{#1}%
	\def\pgfplots@current@point@y{#2}%
	\def\pgfplots@current@point@z{#3}%
	\def\pgfplots@quiver@u{#4}%
	\def\pgfplots@quiver@v{#5}%
	\def\pgfplots@quiver@w{#6}%
}%
\def\pgfplotsplothandlerquiver@vis#1{%
	\pgfkeysvalueof{/pgfplots/quiver/before arrow/.@cmd}\pgfeov
	\pgfplotsplothandlerquiver@vis@hook
	\ifpgfplots@quiver@usetikz
		\draw[/pgfplots/quiver/every arrow] \pgfextra{\pgfplotsplothandlerquiver@vis@path{#1}};
	\else
		\pgfplotsplothandlerquiver@vis@path{#1}%
		\pgfusepath{stroke}%
	\fi
	\pgfkeysvalueof{/pgfplots/quiver/after arrow/.@cmd}\pgfeov
}%
\def\pgfplotsplothandlerquiver@vis@path#1{%
	\pgfpathmoveto{#1}%
	\pgfplotsaxisvisphasetransformcoordinate\pgfplots@quiver@u\pgfplots@quiver@v\pgfplots@quiver@w
	\pgfpathlineto{%
		\pgfplotsifcurplotthreedim{%
			\pgfplotsqpointxyz\pgfplots@quiver@u\pgfplots@quiver@v\pgfplots@quiver@w
		}{%
			\pgfplotsqpointxy\pgfplots@quiver@u\pgfplots@quiver@v
		}%
	}%
}%
