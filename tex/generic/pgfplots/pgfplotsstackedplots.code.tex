%--------------------------------------------
%
% Package pgfplots
%
% Provides a user-friendly interface to create function plots (normal
% plots, semi-logplots and double-logplots).
% 
% It is based on Till Tantau's PGF package.
%
% Copyright 2007/2008 by Christian Feuers√§nger.
%
% This program is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program.  If not, see <http://www.gnu.org/licenses/>.
%
%--------------------------------------------

%
% This file contains the implementation for stacked plots.
%
% Stacked plots always keep record of the last plotted coordinates.
% Any new plot will be ADDED on top of the last plotted coordinates.
% 
% Terminology: "last plotted coordinates" are called "zero levels"
% because they actually work like shifts.
%
% Programming Structure:
%
% 1. We keep TWO lists of coordinates: a list of CURRENT zero level
% coordinates and a list of NEXT zero level coordinates.
%
% The first one will be queried whenever a zero level coordinate is
% requested.
%
% The second one will be used to form zero levels for the next plot.
%
% 2. At the beginning and end of each plot, the lists in 1.) are
% initialised properly.
%
% 3.1 While plot coordinates are processed during the survey phase, the following methods
% interact with the stacked API:
% \pgfplots@stacked@preparepoint@inmacro
% 	-> compute the 'stacked' sum.
% 	This may need to be done with floating point arithmetics because
% 	the data scaling trafo is not yet initialised
% \pgfplots@stacked@rememberzerolevelpoint@for@next@plot
% \pgfplots@stacked@getnextzerolevelpoint
%
%
% 3.2 during the final visualization phase, we have
% \pgfplots@stacked@finishpoint
% 	-> takes coordinates as they will be given to Tikz. This method is
% 	used to 
% 		- communicate zero level coordinates to Tikz
% 		- implement the 'closed paths' option (allows filled stacked plots).
%
% 4. Zero levels are communicated to Tikz by
% \pgfplots@stacked@initzerolevelhandler. This routine initialises an
% input stream for Tikz plot handlers which produces a sequence of
% zero levels. It is used by [xy]comb and [xy]bar.
%
%

\let\pgfplots@stacked@zerolevelpoint@x=\pgfutil@empty
\let\pgfplots@stacked@zerolevelpoint@y=\pgfutil@empty
\newif\ifpgfplots@stacked@isfirstplot
\newif\ifpgfplots@stacked@isinitialised

% Pre-initialisation.
% Needs to be called before the first call to
% \pgfplots@stacked@beginplot.
\def\pgfplots@stacked@initialise{%
	\gdef\pgfplots@stacked@coordcount{-1}%
	\pgfplots@stacked@isfirstplottrue
	\pgfplots@stacked@isinitialisedtrue
}%

% Cleanup method. Truncates any global variables to reduce string
% space.
\def\pgfplots@stacked@finalize{%
	\global\pgfplotslistnewempty\pgfplots@stacked@zerolevellist
	\global\pgfplotslistnewempty\pgfplots@stacked@nextzerolevellist
	\pgfplots@stacked@isinitialisedfalse
}%

% (Re)defines the macro \pgfplots@stacked@getnextzerolevelpoint
% at the beginning of each plot.
%
% The macro \pgfplots@stacked@getnextzerolevelpoint fills
% \pgfplots@stacked@zerolevelpoint@[xy].
%
% ATTENTION: call \pgfplots@stacked@initialise before the first call
% of beginplot!
\def\pgfplots@stacked@beginplot{%
%\message{pgfplots@stacked@beginplot: PLOT STARTED.}%
	\ifpgfplots@stacked@isinitialised
	\else
		\pgfplots@error{LOGIC ERROR: please call \string\pgfplots@stacked@initialise.}%
	\fi
	\def\pgfplotsstackedzerolevelcurrent{}%
	% accumulate this command here for \closedcycle:
	\ifpgfplots@stacked@isfirstplot
		\global\pgfplotslistnewempty\pgfplots@stacked@zerolevellist
		% only work with float if its really necessary - for
		% example if the scaling trafo which maps to pgfmath is
		% not yet initialised.
		\ifpgfplots@datascaletrafo@initialised % FIXME : should be '!ifsurvey'
			\def\pgfplots@stacked@zerolevelpoint@x{0}%
			\def\pgfplots@stacked@zerolevelpoint@y{0}%
			\def\pgfplots@stacked@zerolevelpoint@z{0}%
		\else
			% note that log plots are special: their "stacked zero" is
			% computed with \pgfplotscoordmath{default}
			%
			\pgfplots@if{pgfplots@xislinear}{\pgfplotscoordmath{x}{zero}}{\pgfplotscoordmath{default}{zero}}%
			\let\pgfplots@stacked@zerolevelpoint@x=\pgfmathresult
			%
			\pgfplots@if{pgfplots@yislinear}{\pgfplotscoordmath{y}{zero}}{\pgfplotscoordmath{default}{zero}}%
			\let\pgfplots@stacked@zerolevelpoint@y=\pgfmathresult
			%
			\pgfplots@if{pgfplots@xislinear}{\pgfplotscoordmath{z}{zero}}{\pgfplotscoordmath{default}{zero}}%
			\let\pgfplots@stacked@zerolevelpoint@z=\pgfmathresult
		\fi
		%
		\def\pgfplots@stacked@getnextzerolevelpoint{}% will remain constant anyway.
	\else
		{\globaldefs=1
		\pgfplotslistcopy\pgfplots@stacked@nextzerolevellist\to\pgfplots@stacked@zerolevellist
		}%
		\def\pgfplots@stacked@getnextzerolevelpoint{%
			\pgfplotslistcheckempty\pgfplots@stacked@zerolevellist
			\ifpgfplotslistempty
				\pgfplots@stacked@wrong@count@error
			\else
				{\globaldefs=1
				\pgfplotslistpopfront\pgfplots@stacked@zerolevellist\to\pgfmathresult
				}%
				\expandafter\pgfplots@stacked@parsezerolevelpoint\expandafter{\pgfmathresult}%
			\fi
		}%
	\fi
	\global\pgfplotslistnewempty\pgfplots@stacked@nextzerolevellist
}%

\def\pgfplots@stacked@visphase@beginplot{%
	\let\pgfplots@stacked@closedcycle@impl=\pgfutil@empty
}%

\def\pgfplots@stacked@parsezerolevelpoint#1{%
	\begingroup
%	\pgfplotsaxisdeserializedatapointfrom{#1}%
	\pgfplotsplothandlerdeserializepointfrom{#1}%
	\pgfplots@stacked@smuggle
	\endgroup
	% the value of \pgfplotsstackedzerolevelcurrent will be configured as
	% "visualization depends on".
	% In other words: it is available later-on.
	\def\pgfplotsstackedzerolevelcurrent{#1}%
}

\def\pgfplots@stacked@smuggle\endgroup{%
	\xdef\pgfplots@glob@TMPb{%
		\noexpand\def\noexpand\pgfplots@stacked@zerolevelpoint@x{\pgfplots@current@point@x}%
		\noexpand\def\noexpand\pgfplots@stacked@zerolevelpoint@y{\pgfplots@current@point@y}%
		\noexpand\def\noexpand\pgfplots@stacked@zerolevelpoint@z{\pgfplots@current@point@z}%
	}%
	\endgroup
	\pgfplots@glob@TMPb
}%

\def\pgfplots@stacked@wrong@count@error{%
	\pgfplots@error{Sorry, pgfplots expects stacked plots to have exactly the same number of coordinates. Unfortunately, I encountered at plot with DIFFERENT NUMBERS OF COORDINATES. Please verify that 1. no point has been dropped by coordinate filters (for example log(0) or so) and 2. all plots have the same number of coordinates.}%
}%

\def\pgfplots@stacked@survey@endplot{%
%\message{Stacked plot survey phase end: isfirst = \ifpgfplots@stacked@isfirstplot true \else false\fi^^J}%
	\ifpgfplots@stacked@isfirstplot
		\pgfplotslistcheckempty\pgfplots@stacked@zerolevellist
		\ifpgfplotslistempty
		\else
			\pgfplots@stacked@wrong@count@error
		\fi
	\fi
	\ifpgfplots@stacked@isfirstplot
		\def\pgfplots@stacked@serialized@commands{\noexpand\pgfplots@stacked@isfirstplottrue}%
	\else
		\def\pgfplots@stacked@serialized@commands{\noexpand\pgfplots@stacked@isfirstplotfalse}%
	\fi
	\global\pgfplots@stacked@isfirstplotfalse
}%

\def\pgfplots@stacked@visphase@endplot{%
%\message{Stacked plot vis phase end: isfirst = \ifpgfplots@stacked@isfirstplot true \else false\fi^^J}%
	\ifpgfplots@stacked@isfirstplot
		\let\pgfplots@stacked@closedcycle@impl=\pgfplots@path@closed@cycle@std
	\else
		\t@pgfplots@tokc=\expandafter{\pgfplots@stacked@closedcycle@impl}%
		\edef\pgfplots@stacked@closedcycle@impl{%
			[mark=none,/utils/exec=\noexpand\pgfplots@try@mirror@plot@handler]
			--plot coordinates{\the\t@pgfplots@tokc}
			--cycle
		}%
	\fi
	\global\pgfplots@stacked@isfirstplotfalse
}%

% WARNING: when this method is called, NEITHER
% \ifpgfplots@stacked@isfirstplot NOR the zero level lists are
% initialised!
\def\pgfplots@stacked@initzerolevelhandler{%
	\if\pgfplots@stacked@dir x
		\pgfplotxzerolevelstream@@list
		\pgfplotyzerolevelstreamconstant{\pgfplots@ZERO@y}%
	\else
		\pgfplotxzerolevelstreamconstant{\pgfplots@ZERO@x}%
		\pgfplotyzerolevelstream@@list
	\fi
}%

% #1: a point as (x,y) (or (x,y,z) )
\def\pgfplots@stacked@rememberzerolevelpoint@for@next@plot#1{%
	\expandafter\pgfplotslistpushbackglobal\expandafter{#1}\to\pgfplots@stacked@nextzerolevellist
}

% PRECONDITION:
% 	Is in invoked inside of a coord preparation routine, that means
% 	- \pgfplots@current@point@[xyz] 
% 	- \ifpgfplots@curplot@threedim
% 	are all set properly.
\def\pgfplots@stacked@finishpoint{%
	\ifx\pgfplotsstackedzerolevel\pgfutil@empty
		% this here is the case if we have the first encountered plot,
		% i.e. the one on which others are stacked.
		%
		% Note that it is not necessarily the first one which is
		% processed (compare reverse stacked plots).
		\if\pgfplots@stacked@dir x
			\edef\pgfplots@loc@TMPa{\pgfplots@logical@ZERO@x pt}%
		\else
			\edef\pgfplots@loc@TMPa{\pgfplots@logical@ZERO@y pt}%
		\fi
		\let\pgfplots@stacked@PGF@zerolevel\pgfplots@loc@TMPa
	\else
		\begingroup
		\expandafter\pgfplotsplothandlerdeserializepointfrom\expandafter{\pgfplotsstackedzerolevel}%
		%
		% avoid endless recursion:
		\let\pgfplots@stacked@finishpoint=\relax
		\pgfplotsaxisvisphasegetpoint
		\edef\pgfplots@current@point@x{\the\pgf@x}%
		\edef\pgfplots@current@point@y{\the\pgf@y}%
		\pgfplots@stacked@smuggle
		\endgroup
		%
		\if\pgfplots@stacked@dir x
			\let\pgfplots@stacked@PGF@zerolevel=\pgfplots@stacked@zerolevelpoint@x%
		\else
			\let\pgfplots@stacked@PGF@zerolevel=\pgfplots@stacked@zerolevelpoint@y%
		\fi
		\t@pgfplots@toka=\expandafter{\pgfplots@stacked@closedcycle@impl}%
		\edef\pgfplots@stacked@closedcycle@impl{%
			(\pgfplots@stacked@zerolevelpoint@x,\pgfplots@stacked@zerolevelpoint@y)%
			\the\t@pgfplots@toka}%
	\fi
}%

% PRECONDITION:
% 	Is in invoked inside of a coord preparation routine, that means
% 	- \pgfplots@current@point@[xyz] 
% 	- \ifpgfplots@curplot@threedim
% 	are all set properly.
%
% POSTCONDITION:
% 	- \pgfplots@current@point@[xyz] are adjusted.
\def\pgfplots@stacked@preparepoint@inmacro{%
	\pgfplots@stacked@getnextzerolevelpoint
	%
	\ifpgfplots@stacked@plus
		\def\pgfplots@stacked@op{add}%
	\else
		\def\pgfplots@stacked@op{subtract}%
	\fi
	\pgfplots@if{pgfplots@\pgfplots@stacked@dir islinear}{%
		\pgfplotscoordmath{\pgfplots@stacked@dir}{op}{\pgfplots@stacked@op}{%
			{\csname pgfplots@stacked@zerolevelpoint@\pgfplots@stacked@dir\endcsname}%
			{\csname pgfplots@current@point@\pgfplots@stacked@dir\endcsname}}%
	}{%
		% LOG. we need to compute log(zerolevel + current):
		% FIXME : this might work, but is is hackery - because the
		% coordmath framework handles log bases in a very stupid way.
		% improve it somehow!
		\edef\pgfmathresult{\csname pgfplots@current@point@\pgfplots@stacked@dir\endcsname}%
		\pgfplotscoordmath{\pgfplots@stacked@dir}{exp}{\pgfmathresult}%
		\pgfplotscoordmath{default}{parsenumber}{\pgfmathresult}%
		\expandafter\let\csname pgfplots@current@point@\pgfplots@stacked@dir\endcsname=\pgfmathresult
		\pgfplotscoordmath{default}{op}{\pgfplots@stacked@op}{%
			{\csname pgfplots@stacked@zerolevelpoint@\pgfplots@stacked@dir\endcsname}%
			{\csname pgfplots@current@point@\pgfplots@stacked@dir\endcsname}%
		}%
	}%
	%
	% for logs, I remember just zerolevel+current; not its log.
	\expandafter\let\csname pgfplots@current@point@\pgfplots@stacked@dir\endcsname=\pgfmathresult
	\pgfplotsplothandlerserializepointto\pgfplotsretval
	%\axisserializedatapointtostring
	% 
	\pgfplots@stacked@rememberzerolevelpoint@for@next@plot{\pgfplotsretval}%
	%
	\pgfplots@if{pgfplots@\pgfplots@stacked@dir islinear}{%
	}{%
		\pgfplotscoordmath{\pgfplots@stacked@dir}{log}{\csname pgfplots@current@point@\pgfplots@stacked@dir\endcsname}%
		\expandafter\let\csname pgfplots@current@point@\pgfplots@stacked@dir\endcsname=\pgfmathresult
	}%
}

% This here is a re-implementation of the stored plot processing.
%
% The idea is simple, although it requires quite some work:
%
% If we stack plots on top of each other, early drawing commands
% (early plots) will be OVERDRAWN by later drawing commands (later
% plots). This is especially unfortunate if we use filled bar plots
% or comb plots.
%
% IDEA: draw plots in REVERSE order. The positioning, styles and
% whatever must not be affected, only the sequence of drawing commands
% shall change.
%
% So, this command here does all numerics which is to be done and
% assembles a NEW, REVERSED STORED PLOT LIST.
%
% FIXME : this routine is a mess. It is largely out-of-sync with the
% remaining implementation of pgfplots and has way too many
% responsabilities. I suppose it should be rewritten from scratch.
% From what I see, it is more complicated than simply reversing the
% list of stored plots and their legends: one needs to postprocess the
% stacking order as it seems (?). 
%
%
\def\pgfplots@stacked@finalize@stored@plots{%
	\pgfplotslistnewempty\pgfplots@stored@plotlist@reversed
	\begingroup
	\pgfplotslistforeachungrouped\pgfplots@stored@plotlist\as\pgfplots@loc@TMPa{%
		% Reverse sequence:
		\expandafter\pgfplotslistpushfront\pgfplots@loc@TMPa\to\pgfplots@stored@plotlist@reversed
	}%
	% Now, overwrite the original list:
	\global\let\pgfplots@stored@plotlist=\pgfplots@stored@plotlist@reversed
	\global\let\pgfplots@stored@plotlist@reversed=\relax
	\endgroup
}%

\def\pgfplots@stacked@path@closed@cycle{%
	\pgfplots@stacked@closedcycle@impl
}

% PGF interfaces:
\def\pgfplotxzerolevelstream@@list{%
	\def\pgf@plotxzerolevelstreamstart{%
		\gdef\pgf@plotxzerolevelstreamnext{%
			\global\pgf@x=\pgfplots@stacked@PGF@zerolevel\relax
		}%
	}%
	\def\pgf@plotxzerolevelstreamend{%
	}%
}%

\def\pgfplotyzerolevelstream@@list{%
	\def\pgf@plotyzerolevelstreamstart{%
		\gdef\pgf@plotyzerolevelstreamnext{%
			\global\pgf@x=\pgfplots@stacked@PGF@zerolevel\relax
		}%
	}%
	\def\pgf@plotyzerolevelstreamend{%
	}%
}%
