%--------------------------------------------
% $Header: /cvsroot/pgfplots/pgfplots/generic/pgfplots/util/pgfplotscolormap.code.tex,v 1.15 2009/07/21 18:18:48 ludewich Exp $
%
% Package pgfplots
%
% Provides a user-friendly interface to create function plots (normal
% plots, semi-logplots and double-logplots).
% 
% It is based on Till Tantau's PGF package.
%
% Copyright 2007-2013 by Christian Feuers√§nger.
%
% This program is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program.  If not, see <http://www.gnu.org/licenses/>.
%
%--------------------------------------------

\input pgfplotscolor.code.tex

\pgfkeyssetvalue{/pgfplots/colormap default colorspace}{auto}

% preset for '/pgfplots/colormap uniform=always
% This is only used for the colormap predefined in this very file.
\def\pgfplots@colormap@uniform@choice{0}%

% This package relies on pgfplots temporary registers and its array
% data structure.

% Internal structure:
% the colormap data structure consists of
% - an array 'pgfpl@cm@#1' of RGB color triples,
% - numbers 'pgfpl@cm@#1@h' and 'pgfpl@cm@#1@invh' for the mesh width
%   and inverse mesh width.

% Creates a new colormap.
%
% #1 : the name of the color map as string (not as macro).
% #2 : a <color specification> as is expected for a shading spec of
% pgf. However, the format allows a little bit more freedom:
% 	- it supports 'rgb255' in addition to pgf,
% 	- the length is not required (defaults to 1cm for the first and to
% 	the last length+h for all others).
% 	- the semicolons can be omitted.
%
% Example: 
% \pgfplotscreatecolormap{my map}{rgb(0cm)=(1,0,0); rgb(1cm)=(0,1,0); rgb255(1.5cm)=(128,5,255); rgb(2cm)=(0,0,1); gray(3cm)=(3);  color(4cm)=(green); }
% \pgfplotscreatecolormap{my map}{color=(green); color=(red); color=(blue); color=(yellow)}
\def\pgfplotscreatecolormap#{\pgfplots@createcolormap}%
\def\pgfplots@createcolormap#1#2{%
	\edef\pgfplots@createcolormap@name{pgfpl@cm@#1}%
	\expandafter\pgfplotsarraynewempty\expandafter{\pgfplots@createcolormap@name}%
	\pgfplotsapplistXnewempty\pgfplots@createcolormap@X
	%
	% '0' = is not uniform
	% '1' = is uniform
	% '2' = is FORCED to be uniform, i.e. will be reinterpolated
	\ifcase\pgfplots@colormap@uniform@choice\relax
		% colormap uniform=always
		\def\b@pgfplotscreatecolormap@isuniform{2}%
	\or
		% colormap uniform=if requested
		\def\b@pgfplotscreatecolormap@isuniform{1}%
	\fi
	\def\pgfplots@createcolormap@MIN{0}% NORMALIZATION: assume that lower-end is 0pt.
	\def\pgfplots@createcolormap@MAX{0}% To be computed.
	\pgfplots@createcolormap@initcolorspace
	\let\pgfplots@createcolormap@LAST=\pgfplots@createcolormap@MIN
	% PARSE IT:
	\edef\pgfplots@loc@TMPa{#2}%
	\let\pgfplots@createcolormap@context=\pgfutil@empty
	%%%%%%%%%%%%%%%%%%
	% this does also init @H:
	\expandafter\pgfplots@createcolormap@startloop\pgfplots@loc@TMPa\pgfplots@EOI
	%%%%%%%%%%%%%%%%%%
	%
	\expandafter\pgfplotsarraycheckempty\expandafter{\pgfplots@createcolormap@name}%
	% sanity checking:
	\expandafter\pgfplotsarraysizetomacro\expandafter{\pgfplots@createcolormap@name}\to\pgfplots@loc@TMPa
	\ifcase\pgfplots@loc@TMPa\relax
		\pgfplots@error{Sorry, you need to provide at least two points of a colormap.}%
	\or
		\pgfplots@error{Sorry, you need to provide at least two points of a colormap.}%
	\fi
	% Map the input range [0pt,MAX] linearly to [0,1000]
	\pgfmathdivide@{\pgfplotscolormaprange}{\pgfplots@createcolormap@MAX}%
	\let\pgfplots@loc@TMPb=\pgfmathresult
	\pgfmathmultiply@{\pgfplots@loc@TMPb}{\pgfplots@createcolormap@H}%
	\let\pgfplots@createcolormap@H=\pgfmathresult
	\expandafter\let\csname\pgfplots@createcolormap@name @h\endcsname=\pgfplots@createcolormap@H
	\pgfmathreciprocal@{\pgfplots@createcolormap@H}%
	\expandafter\let\csname\pgfplots@createcolormap@name @invh\endcsname=\pgfmathresult
	%
	% ... and set up the X coordinates if the grid is not uniform:
	\expandafter\pgfplotsarraynewempty\expandafter{\pgfplots@createcolormap@name @X}%
	\if0\b@pgfplotscreatecolormap@isuniform
		% Uncomment the '\iftrue' for testing purposes (to see if a uniform map changes if
		% processed as non-uniform):
%	\iftrue
		\pgfplotsapplistXlet\pgfplots@loc@TMPc=\pgfplots@createcolormap@X
		\expandafter\pgfplotsutilforeachcommasep\expandafter{\pgfplots@loc@TMPc}\as\pgfplots@loc@TMPc{%
			\ifx\pgfplots@loc@TMPc\pgfutil@empty
			\else
				% apply the trafo [0pt,MAX] -> [0,1000] here as well:
				\pgfmathmultiply@{\pgfplots@loc@TMPb}{\pgfplots@loc@TMPc}%
				\expandafter\pgfplotsarraypushback\expandafter{\pgfmathresult}\to{pgfpl@cm@#1@X}%
			\fi
		}%
		%
		\pgfplotscolormapsetadditionalintervalwidth@{#1}%
	\else
		\expandafter\let\csname\pgfplots@createcolormap@name @X@scale@order@z\endcsname=\pgfutil@empty
	\fi
	% clear temporary list:
	\pgfplotsapplistXnewempty\pgfplots@createcolormap@X
	%
	\endpgfplotscolornormalizesequence%
	\expandafter\let\csname\pgfplots@createcolormap@name @colspace\endcsname=\pgfplotsretval
	\expandafter\let\csname\pgfplots@createcolormap@name @col@comps\endcsname=\pgfplotsretvalb
	\c@pgf@counta=\expandafter\pgfplotsarraysizeof\expandafter{\pgfplots@createcolormap@name}\relax
	\advance\c@pgf@counta by-1 %
	\expandafter\edef\csname\pgfplots@createcolormap@name @lastindex\endcsname{\the\c@pgf@counta}%
%\pgfplots@colormap@showdebuginfofor{#1}%
	\pgfplots@colormap@LUA@new{#1}%
}

\def\pgfplotscolormapsetadditionalintervalwidth#1#2{%
	\pgfplotscolormapifisuniform{#1}{%
		\pgfplots@error{Setting the additional interval width for a uniform colormap is not implemented at the time of this writing. Please use a non-uniform colormap.}%
	}{%
		\pgfmathparse{#2}%
		\ifdim\pgfmathresult pt>0pt
			\ifdim\pgfmathresult pt>0.9pt
				\pgfplots@error{Expected a number 0< X <= 0.9, not \pgfmathresult}%
			\else
				% compute the 'h'.
				%
				% Note that 's:=#2' is a fraction 0<x<1 of the RESULTING
				% range, i.e. s * 1000 = H where 0<=H<=1000. 
				% but H = 1000/(1000+h) * 1000, and we need the 'h'.
				% 
				% -> h = 1000/s - 1000.
				\pgfmathparse{1000/(1-#2)-1000}%
				\expandafter\let\csname pgfpl@cm@#1@h\endcsname=\pgfmathresult
				\expandafter\let\csname pgfpl@cm@#1@invh\endcsname=\pgfutil@empty% unused!
				\pgfplotscolormapsetadditionalintervalwidth@{#1}%
			\fi
		\else
			\pgfplots@error{Expected a number 0< X <= 0.9, not \pgfmathresult}%
		\fi
	}%
}%
\def\pgfplotscolormapsetadditionalintervalwidth@#1{%
	% 'colormap access=piecewise constant' (order 0) requires a
	% special scaling factor. See its consumers for details +
	% documentation
	\pgfmathparse{1000/(1000+\csname pgfpl@cm@#1@h\endcsname)}%
	\expandafter\let\csname pgfpl@cm@#1@X@scale@order@z\endcsname=\pgfmathresult
}%

\def\pgfplots@createcolormap@initcolorspace{%
	\pgfplotscolornormalizesequence[
		colorspace=\pgfkeysvalueof{/pgfplots/colormap default colorspace},
		context message=\pgfplots@createcolormap@context,
	]%
}%
\def\pgfplots@createcolormap@seth[#1]{%
	\def\pgfplots@createcolormap@context{[#1]}%
	\pgfmathparse{#1}%
	\let\pgfplots@createcolormap@H=\pgfmathresult
	% request for a uniform colormap:
	\def\b@pgfplotscreatecolormap@isuniform{2}%
	\pgfplots@createcolormap@
}%

\def\pgfplots@createcolormap@startloop{%
	\pgfutil@ifnextchar[%
		{\pgfplots@createcolormap@seth}%
		{%
			\let\pgfplots@createcolormap@H=\pgfutil@empty
		 	\pgfplots@createcolormap@
		}%
}%
\def\pgfplots@createcolormap@{%
	\pgfutil@ifnextchar\pgfplots@EOI{\pgfutil@gobble}%done!
	{%
		\pgfutil@ifnextchar;{\pgfplots@createcolormap@grabsemicolon}%
		{%
			\expandafter\pgfutil@ifnextchar\pgfplots@activesemicolon{\pgfplots@createcolormap@grabsemicolon@active}%
			{%
				\pgfplots@createcolormap@grabnext
			}%
		}%
	}%
}
\def\pgfplots@createcolormap@error#1#2\pgfplots@EOI{%
	{%
		\t@pgfplots@toka={#1#2}%
		\t@pgfplots@tokb={#1}%
		\pgfplots@error{Illformed colormap specification: I could not read the substring `\the\t@pgfplots@toka' starting at `\the\t@pgfplots@tokb'}%
	}%
}%

\def\pgfplots@createcolormap@grabnext#1={%
	\pgfutil@ifnextchar({\pgfplots@createcolormap@grabnext@round{#1}=}{%
		\pgfutil@ifnextchar\bgroup{\pgfplots@createcolormap@grabnext@curly{#1}=}{%
			\pgfplots@createcolormap@error#1=%
		}%
	}%
}
\def\pgfplots@createcolormap@grabnext@round#1=(#2){%
	\pgfplots@createcolormap@grabnext@@{#1}={#2}%
}%
\def\pgfplots@createcolormap@grabnext@curly#1=#2{%
	\pgfplots@createcolormap@grabnext@@{#1}={#2}%
}%
\def\pgfplots@createcolormap@grabnext@@#1=#2{%
	\pgfutil@in@({#1}%
	\ifpgfutil@in@
		% Ah. We have something like 'color(1cm)' before the equal sign.
		\pgfplots@createcolormap@grabnext@read@pos#1\pgfplots@EOI%
		% now:
		%\pgfplots@loc@TMPa = colorspace
		%\pgfplots@loc@TMPb = position
		%
	\else
		% Ah. we do not have a position, i.e. we have
		%   color=(green)
		% or something like this.
		%
		% this here defines \pgfplots@loc@TMPa to contain the
		% colorspace:
		\pgfkeys@spdef\pgfplots@loc@TMPa{#1}%
		%
		\pgfplots@createcolormap@grabnext@computenextposition
		\let\pgfplots@loc@TMPb=\pgfmathresult% posisiton
	\fi
	\def\pgfplots@loc@TMPc{#2}%
	\pgfplots@createcolormap@grabnext@complete
}%

\def\pgfplots@createcolormap@grabnext@read@pos#1({%
	\pgfkeys@spdef\pgfplots@loc@TMPa{#1}% colorspace
	\pgfplots@createcolormap@grabnext@read@pos@
}%
\def\pgfplots@createcolormap@grabnext@read@pos@#1){%
	\def\pgfplots@loc@TMPb{#1}% position
	\pgfutil@ifnextchar\pgfplots@EOI{%
		% OK
		\pgfplots@gobble@until@EOI
	}{%
		\pgfplots@createcolormap@error#1)%
	}%
}%

%%%%%%%%%%

% defines \pgfplotsretval to contain the argument and \pgfplotsretvalb
% to contain the colormap name.
\def\pgfplots@createcolormap@special@split#1{%
	\pgfutil@in@{of }{#1}%
	\ifpgfutil@in@
		\pgfplots@createcolormap@special@split@#1\pgfplots@EOI
	\else
		\pgfkeys@spdef\pgfplotsretval{#1}%
		\pgfkeysgetvalue{/pgfplots/colormap name}\pgfplotsretvalb
	\fi
	\pgfplots@createcolormap@special@ensure@source@cm{\pgfplotsretvalb}%
}%
\def\pgfplots@createcolormap@special@split@#1of #2\pgfplots@EOI{%
	\pgfkeys@spdef\pgfplotsretval{#1}%
	\pgfkeys@spdef\pgfplotsretvalb{#2}%
}
\def\pgfplots@createcolormap@special@ensure@source@cm#1{%
	\pgfplotscolormapifdefined{#1}{%
	}{%
		\pgfplots@error{The argument '#1' is no valid colormap.}%
	}%
}%


\pgfqkeys{/pgfplots/of colormap}{%
	name/.initial=,
	pos/.initial=,
	selection/.initial=,
	%
	@define/.code={%
		\pgfplots@error{Please write 'single color' or 'color list' such that pgfplots knows how to interprete values}
		\let\pgfplotsretval=\pgfutil@empty
	},
	single color/.style={%
		/pgfplots/of colormap/@define/.code={%
			\pgfplots@createcolormap@special@process@single
		},
	},
	color list/.style={%
		/pgfplots/of colormap/@define/.code={%
			\pgfplots@createcolormap@special@process@list%
		},
	},
	color list,
	%
	color/.style={%
		/pgfplots/of colormap/interpolation=map,
		/pgfplots/of colormap/single color,
	},
	const color/.style={%
		/pgfplots/of colormap/interpolation=piecewise constant,
		/pgfplots/of colormap/single color,
	},
	index/.style={%
		/pgfplots/of colormap/interpolation=direct,
		/pgfplots/of colormap/single color,
	},
	colors/.style={%
		/pgfplots/of colormap/interpolation=map,
		/pgfplots/of colormap/color list,
	},
	const colors/.style={%
		/pgfplots/of colormap/interpolation=piecewise constant,
		/pgfplots/of colormap/color list,
	},
	indices/.style={%
		/pgfplots/of colormap/interpolation=direct,
		/pgfplots/of colormap/color list,
	},
	interpolation/.style={/pgfplots/colormap access={#1}},
	range/.initial=0:1000,
}

\def\pgfplots@createcolormap@of@colormap@process@keys#1{%
	\pgfqkeys{/pgfplots/of colormap}{#1}%
	\pgfkeysgetvalue{/pgfplots/of colormap/name}\pgfplots@loc@TMPa
	\edef\pgfplots@loc@TMPa{\pgfplots@loc@TMPa}%
	\ifx\pgfplots@loc@TMPa\pgfutil@empty
	\else
		\pgfkeyslet{/pgfplots/colormap name}\pgfplots@loc@TMPa
	\fi
	\pgfplots@createcolormap@special@ensure@source@cm{\pgfkeysvalueof{/pgfplots/colormap name}}%
	%
	\pgfqkeys{/pgfplots/of colormap}{@define}%
}%


\def\pgfplots@createcolormap@special@process@single{%
	\begingroup
	\let\pgfplots@color@of@colormap@access=\pgfplots@colormap@access
	\pgfkeysgetvalue{/pgfplots/of colormap/range}\pgfplotspointmetatransformedrange
	\ifx\pgfplotspointmetatransformedrange\pgfutil@empty
		% evaluated by \pgfplots@color@of@colormap@define...
		\let\pgfplotspointmetatransformedrange=\pgfplotscolormaprange
	\fi
	%
	\pgfkeysgetvalue{/pgfplots/of colormap/pos}\pgfplots@temp@pos
	\ifx\pgfplots@temp@pos\pgfutil@empty
	\else
		\edef\pgfplots@temp@pos{(\pgfplots@temp@pos)}%
	\fi
	%
	\edef\pgfplots@loc@TMPa{%
		\noexpand\pgfplots@color@of@colormap@define{\pgfkeysvalueof{/pgfplots/of colormap/selection}}%
	}%
	\pgfplots@loc@TMPa
	%
	\edef\pgfplotsretval{%
		\csname pgfpl@cm@\pgfkeysvalueof{/pgfplots/colormap name}@colspace\endcsname\pgfplots@temp@pos=(\pgfmathresult)%
	}%
	\pgfmath@smuggleone\pgfplotsretval
	\endgroup
}%
% PRECONDITION: Must be invoked within \pgfplots@createcolormap@of@colormap@process@keys
\def\pgfplots@createcolormap@special@process@list{%
	\begingroup
	\pgfkeysgetvalue{/pgfplots/of colormap/selection}\pgfplots@source
	\pgfkeysgetvalue{/pgfplots/colormap name}\pgfplots@sourcecm
	%
	\pgfplotsapplistXnewempty\pgfplots@createcolormap@special@process@result
	\def\pgfplots@loc@TMPa{\pgfplotsforeachungrouped \x in }%
	\expandafter\pgfplots@loc@TMPa\expandafter{\pgfplots@source}{%
		\t@pgfplots@tokb=\expandafter{\pgfplots@sourcecm}%
		%
		\pgfkeyslet{/pgfplots/of colormap/selection}\x
		\pgfplots@createcolormap@special@process@single
		\edef\pgfplotsretval{\pgfplotsretval\space}%
		%
		\expandafter\pgfplotsapplistXpushback\pgfplotsretval\to\pgfplots@createcolormap@special@process@result
		%
		% all following ones receive auto-positions:
		\pgfkeyslet{/pgfplots/of colormap/pos}\pgfutil@empty
	}%
	\pgfplotsapplistXlet\pgfplotsretval=\pgfplots@createcolormap@special@process@result
	\global\let\pgfplots@glob@TMPa=\pgfplotsretval
	\endgroup
	\let\pgfplotsretval=\pgfplots@glob@TMPa
}%
%%%%%%%%%%

\def\pgfplots@createcolormap@grabnext@complete{%
	\edef\pgfplots@loc@TMPd{%
		\noexpand\pgfutil@in@{of colormap}{\pgfplots@loc@TMPa}%
	}%
	\pgfplots@loc@TMPd
	\ifpgfutil@in@
		% ah - a special one based on another colormap!
		% convert it into the standard format:
		\begingroup
		\let\pgfplotscolormap@at=\pgfplots@loc@TMPb
		\let\pgfplotscolormap@argument=\pgfplots@loc@TMPc
		\let\pgfplotscolormap@key=\pgfplots@loc@TMPa
		%
		\pgfplots@createcolormap@grabnext@complete@ofcolormap
		\pgfmath@smuggleone\pgfplotsretval
		\endgroup
		%
		\def\pgfplots@loc@TMPd{%
			\expandafter\pgfplots@createcolormap@\pgfplotsretval
		}%
	\else
		% ok, this is a 'normal' color specification with position,
		% colorspace, and color data.
		%
		\edef\pgfplots@loc@TMPa{%
			{\pgfplots@loc@TMPb}% position
			{%
			\pgfplots@loc@TMPa% colorspace
			=\pgfplots@loc@TMPc% color data
			}%
		}%
		\expandafter\pgfplots@createcolormap@nextcolor\pgfplots@loc@TMPa
		%
		% continue loop:
		\def\pgfplots@loc@TMPd{\pgfplots@createcolormap@}%
	\fi
	%
	%
	% continue loop:
	\pgfplots@loc@TMPd
}%

\def\pgfplots@createcolormap@grabnext@complete@ofcolormap{%
	\expandafter\pgfplots@createcolormap@split@accessmode@\pgfplotscolormap@key\pgfplots@EOI
	% If you write 'color of colormap=(...)', accessmode is 'color'.
	% It is the prefix before 'of colormap':
	\let\pgfplotscolormap@accessmode=\pgfplotsretval
	%
	\ifx\pgfplotscolormap@accessmode\pgfutil@empty
		% Ah, we have 'of colormap={<list of keys>}':
		% keep the argument as-is.
		\t@pgfplots@tokb=\expandafter{\pgfplotscolormap@argument}%
		\edef\pgfplotscolormap@keyvalue{%
			% position:
			pos={\pgfplotscolormap@at},%
			% ... but can be overriden here:
			\the\t@pgfplots@tokb
		}%
	\else
		% Convert 'color of colormap={...}' and its variants into
		% 'of colormap={<list of keys>}':
		\expandafter\pgfplots@createcolormap@special@split\expandafter{\pgfplotscolormap@argument}%
		\edef\pgfplotscolormap@keyvalue{%
			% position:
			pos={\pgfplotscolormap@at},%
			\pgfplotscolormap@accessmode,%
			selection={\pgfplotsretval},%
			name={\pgfplotsretvalb},%
		}%
	\fi
	%
	% finally, process the keys:
	\expandafter\pgfplots@createcolormap@of@colormap@process@keys\expandafter{%
		\pgfplotscolormap@keyvalue,
	}%
}%

% 'colors of colormap' -> \pgfplotsretval = 'colors'
\def\pgfplots@createcolormap@split@accessmode@#1of colormap\pgfplots@EOI{%
	\pgfkeys@spdef\pgfplotsretval{#1}%
}%

\def\pgfplots@createcolormap@grabnext@computenextposition{%
	% determine next step size automatically:
	\expandafter\pgfplotsarraycheckempty\expandafter{\pgfplots@createcolormap@name}%
	\ifpgfplotsarrayempty
		% first: must be at 0.
		\def\pgfmathresult{0sp}%
	\else
		% not first:
		\ifx\pgfplots@createcolormap@H\pgfutil@empty
			% ah; we really have to deduce something. We are at the
			% second node:
			\def\pgfmathresult{1cm}%
		\else
			\pgfmathadd@\pgfplots@createcolormap@LAST\pgfplots@createcolormap@H
		\fi
	\fi
}%

\def\pgfplots@createcolormap@grabsemicolon;{\pgfplots@createcolormap@}%

{
	\catcode`\;=13
	\gdef\pgfplots@createcolormap@grabsemicolon@active;{\pgfplots@createcolormap@}%
}

\def\pgfplots@createcolormap@nextcolor@tostring#1=#2\pgfplots@EOI#3{%
	#1(#3)=(#2)%
}%

% #1: h
% #2: a compound element of the form
% '<colorspace>=<comma-separated-color-components>'
%  The format is chosen such that it can be forwarded directly to
%  \pgfplotscolornormalizesequencenext
%
% see  \pgfplotscolornormalizesequencenext for details
\def\pgfplots@createcolormap@nextcolor#1#2{%
	\def\pgfplots@createcolormap@context{\pgfplots@createcolormap@nextcolor@tostring#2\pgfplots@EOI{#1}}%
	%
	\pgfplotscolornormalizesequencenext{#2}%
	\let\pgfplots@createcolormap@col@comps=\pgfplotsretvalb
	%
	\edef\pgfplots@loc@TMPa{{#1}{\pgfplotsretval}}%
	\expandafter\pgfplots@createcolormap@nextcolor@\pgfplots@loc@TMPa%
}%
\def\pgfplots@createcolormap@nextcolor@#1#2{%
%\message{processing color #1=(#2)^^J}%
	% compute 'h':
	\pgfmathparse{#1}%
	\let\pgfplots@createcolormap@MAX=\pgfmathresult
	\expandafter\pgfmathsubtract@\expandafter{\pgfmathresult}{\pgfplots@createcolormap@LAST}%
	\let\pgfplots@createcolormap@H@cur=\pgfmathresult
	\let\pgfplots@createcolormap@LAST=\pgfplots@createcolormap@MAX
	\ifx\pgfplots@createcolormap@H\pgfutil@empty
		\expandafter\pgfplotsarraycheckempty\expandafter{\pgfplots@createcolormap@name}%
		\ifpgfplotsarrayempty
			\ifdim\pgfplots@createcolormap@MAX pt=0pt
			\else
				\pgfplots@error{Sorry, the left end of a colormap (at 0pt) must be provided explicitly. You cannot start with \pgfplots@createcolormap@MAX pt. The error occured near `\pgfplots@createcolormap@context'}%
				\def\pgfplots@createcolormap@MAX{0}%
			\fi
		\else
			\let\pgfplots@createcolormap@H=\pgfplots@createcolormap@H@cur
		\fi
	\else
		\pgfmathapproxequalto@{\pgfplots@createcolormap@H}{\pgfplots@createcolormap@H@cur}%
		\ifpgfmathcomparison
		\else
			\if2\b@pgfplotscreatecolormap@isuniform
				% force reinterpolation:
				\pgfplotscreatecolormap@reinterpolate{#2}%
			\else
				% it is NOT uniform!
				\def\b@pgfplotscreatecolormap@isuniform{0}%
				%
				\pgfplotsmathmin{\pgfplots@createcolormap@H@cur}{\pgfplots@createcolormap@H}%
				\let\pgfplots@createcolormap@H=\pgfmathresult
			\fi
		\fi
	\fi
%\message{found current diff  = \pgfplots@createcolormap@H@cur\ ( from \pgfplots@createcolormap@MAX pt - \pgfplots@createcolormap@LAST pt) -> H=\pgfplots@createcolormap@H^^J}%
	% 
	% remember positions:
	\expandafter\pgfplotsapplistXpushback\expandafter{\pgfplots@createcolormap@MAX,}\to\pgfplots@createcolormap@X
	%
	\edef\pgfplots@loc@TMPa{\noexpand\pgfplotsarraypushback{#2}\noexpand\to}%
	\expandafter\pgfplots@loc@TMPa\expandafter{\pgfplots@createcolormap@name}%
	\edef\pgfplots@createcolormap@last{#2}%
}%
\def\pgfplotscreatecolormap@reinterpolate#1{%
	\pgfmathdivide@{\pgfplots@createcolormap@H@cur}{\pgfplots@createcolormap@H}%
	% after this group, \pgfmathresult is
	% - empty if no reinterpolation is possible,
	% - non-empty if reinterpolation IS possible. In this
	%   case, it contains the integer multiple of H.
	\begingroup
		\afterassignment\pgfplots@createcolormap@nextRGB@consider@reinterpolation
		\c@pgf@counta=\pgfmathresult\relax
		\pgfmath@smuggleone\pgfmathresult
	\endgroup
	\ifx\pgfmathresult\pgfutil@empty
		% I can't do that yet.
	\else
		\let\pgfplots@createcolormap@loop@end=\pgfmathresult
		% interpolate missing values using the already fixed H.
		% This interpolation procedure is stupid because it works
		% only in forward direction - but it works at least.
		% For the backwards direction, you can provide the
		% meshwidth explicitly at
		% \pgfplotscreatecolormap{}{[1pt]}
		\pgfplotsforeachungrouped \c@pgfplots@createcolormap in {1,2,...,\pgfplots@createcolormap@loop@end} {%
			\ifdim\c@pgfplots@createcolormap pt=\pgfplots@createcolormap@loop@end pt %
				% omit the last.
			\else
				\pgfmathparse{\c@pgfplots@createcolormap/\pgfplots@createcolormap@loop@end}%
				\let\pgfplots@createcolormap@scale@current=\pgfmathresult
				\pgfmathparse{1-\pgfplots@createcolormap@scale@current}%
				\let\pgfplots@createcolormap@scale@last=\pgfmathresult
				%
				\pgfplotscolornormalizesequencezero
				\pgfplotscolornormalizesequenceaddweighted
					{\pgfplotsretval}
					{\pgfplots@createcolormap@scale@current}
					{#1}%
				\pgfplotscolornormalizesequenceaddweighted
					{\pgfplotsretval}
					{\pgfplots@createcolormap@scale@last}
					{\pgfplots@createcolormap@last}%
				%
%\message{interpolation step \c@pgfplots@createcolormap = \pgfplotsretval^^J}%
				\edef\pgfplots@loc@TMPa{%
					\noexpand\pgfplotsarraypushback{\pgfplotsretval}%
					\noexpand\to}%
				\expandafter\pgfplots@loc@TMPa\expandafter{\pgfplots@createcolormap@name}%
			\fi
		}%
	\fi
}%
\def\pgfplots@createcolormap@nextRGB@consider@reinterpolation#1\relax{%
	\pgf@xa=#1pt
	\ifdim\pgf@xa>0.5pt % we have something like 99.995 or so.
		% round up and compute 1 - #1:
		\advance\c@pgf@counta by1
		\pgf@xa=1pt \advance\pgf@xa by-#1pt
	\fi
	%
	% compute relative error:
	\pgf@xb=\the\c@pgf@counta pt
	\divide\pgf@xb by10000
%\message{Checking  H/h = \pgfplots@createcolormap@H@cur pt/\pgfplots@createcolormap@H pt = \the\c@pgf@counta+-\pgf@sys@tonumber\pgf@xa\space:  \the\pgf@xa > \the\pgf@xb\space (relative to \the\c@pgf@counta)?}%
	%
	\ifdim\pgf@xa>\pgf@xb
		\pgfplots@error{Sorry, non-uniform colormaps are only partially implemented, yet: the provided points must be multiples of the mesh width h=\pgfplots@createcolormap@H pt (but I found one with H/h = \pgfplots@createcolormap@H@cur pt/\pgfplots@createcolormap@H pt = \the\c@pgf@counta+-\pgf@sys@tonumber\pgf@xa\space which is no integer). Perhaps it helps to provide the mesh widths as argument as in {<name>}{[1cm] <color arguments>}? The error occured near `\pgfplots@createcolormap@context'}%
		\let\pgfmathresult=\pgfutil@empty
	\else
		\ifnum\c@pgf@counta=0
			\let\pgfmathresult=\pgfutil@empty
		\else
			\edef\pgfmathresult{\the\c@pgf@counta}%
		\fi
	\fi
}%

\def\pgfplots@colormap@LUA@new#1{%
	\ifpgfplots@LUA@supported
		\pgfplotscolormapserializecomponentstomacro{#1}\pgfplots@loc@TMPa
		\pgfplotsutil@directlua{%
			local colorspace =^^J%
				pgfplots.\csname pgfpl@cm@#1@colspace\endcsname;^^J%
			if colorspace then^^J%
				pgfplots.ColorMaps["#1"] = pgfplots.ColorMap.new(^^J%
					\csname pgfpl@cm@#1@h\endcsname,^^J%
					colorspace,^^J%
					{ \pgfplots@loc@TMPa });^^J%
			else^^J%
				io.write("There is no LUA colorspace for '\csname pgfpl@cm@#1@colspace\endcsname' - skipping LUA color map definition of #1\string\n");^^J%
			end^^J%
		}%
	\fi
}%

% Executes '#2' if the colormap named '#1' has a uniform grid and '#3'
% if not.
\def\pgfplotscolormapifisuniform#1#2#3{%
	\ifnum0=\pgfplotsarraysizeof{pgfpl@cm@#1@X}\relax
		#2\relax
	\else
		#3\relax
	\fi
}%

% Shows debug info about colormap #1 into the console.
\def\pgfplots@colormap@showdebuginfofor#1{%
	\message{Debug info for color map '#1':^^J}%
	\message{(Transformed) Range: [0:\pgfplotscolormaprange];  ^^J}%
	\message{H: \csname pgfpl@cm@#1@h\endcsname;    ^^J}%
	\message{H:^{-1}: \csname pgfpl@cm@#1@invh\endcsname;    ^^J}%
	\pgfplotsarraysizetomacro{pgfpl@cm@#1}\to\pgfplots@loc@TMPa
	\message{Size: \pgfplots@loc@TMPa;    ^^J}%
	\message{Colorspace: \csname pgfpl@cm@#1@colspace\endcsname^^JValues (\csname pgfpl@cm@#1@col@comps\endcsname\space components each): ^^J}%
	\begingroup
	\c@pgf@counta=0
	\pgfplotscolormapifisuniform{#1}{%
		\pgfplotsarrayforeachungrouped{pgfpl@cm@#1}\as\elem{%
			\pgfmath@basic@multiply@{\the\c@pgf@counta}{\csname pgfpl@cm@#1@h\endcsname}%
			\message{\#\the\c@pgf@counta=(\pgfmathresult)=(\elem);^^J}%
			\advance\c@pgf@counta by1 %
		}%
	}{%
		\pgfplotsarrayforeachungrouped{pgfpl@cm@#1}\as\elem{%
			\pgfplotsarrayselect\c@pgf@counta\of{pgfpl@cm@#1@X}\to\pgfmathresult
			\message{\#\the\c@pgf@counta=(\pgfmathresult)=(\elem);^^J}%
			\advance\c@pgf@counta by1 %
		}%
	}%
	\message{^^J}%
	\endgroup
}

% #1: comma-separated list of values for the current entry
% #2: color map name
% #3: the current index into the colormap
% #4: the "x coordinate", i.e. the offset within the colormap
%
% Defines \pgfplotsretval
%
% Example:
% \pgfplotscolormaptodatafile[
%		output each nth=1,
%		output format=csv,
%	]{viridis}
%	{viridis.dat}
\def\pgfplotscolormaptodatafile@elem#1#2#3#4{
	\let\pgfplotsretval=\pgfutil@empty
}%

\begingroup
\catcode`\[=1
\catcode`\]=2
\catcode`\{=12
\catcode`\}=12
\xdef\pgfplots@lbrace[{]%
\xdef\pgfplots@rbrace[}]%
\endgroup


\pgfkeys{
	/pgfplots/colormap/output each nth/.initial=1,
	/pgfplots/colormap/output format/.is choice,
	/pgfplots/colormap/output format/csv/.code={%
		\def\pgfplotscolormaptodatafile@head##1{%
			\let\pgfplotsretval=\pgfutil@empty
		}%
		\def\pgfplotscolormaptodatafile@elem##1##2##3##4{%
			\edef\pgfplotsretval{##4,##1}%
		}%
		\def\pgfplotscolormaptodatafile@foot##1{%
			\let\pgfplotsretval=\pgfutil@empty
		}%
	},
	/pgfplots/colormap/output format/native/.code={%
		\def\pgfplotscolormaptodatafile@head##1{%
			\edef\pgfplotsretval{\string\pgfplotsset\pgfplots@lbrace colormap={##1}\pgfplots@lbrace}%
		}%
		\def\pgfplotscolormaptodatafile@elem##1##2##3##4{%
			\edef\pgfplotsretval{\csname pgfpl@cm@##2@colspace\endcsname=(##1)}%
		}%
		\def\pgfplotscolormaptodatafile@foot##1{%
			\edef\pgfplotsretval{\pgfplots@rbrace\pgfplots@rbrace}%
		}%
	},
	/pgfplots/colormap/output format=csv,
}


% An export of a color map.
% #1: options. Can use 'output each nth=2' and 'output format=csv|native'
% #2: a color map
% #3: a data file
\def\pgfplotscolormaptodatafile{\pgfutil@ifnextchar[{\pgfplotscolormaptodatafile@}{\pgfplotscolormaptodatafile@[]}}%
\def\pgfplotscolormaptodatafile@[#1]#2#3{%
	\begingroup
	\pgfqkeys{/pgfplots/colormap}{#1}%
	\pgfkeysgetvalue{/pgfplots/colormap/output each nth}{\pgfplots@eachnth}%
	\immediate\openout\w@pgf@writea=#3\relax
	\pgfplotscolormaptodatafile@head{#2}%
	\ifx\pgfplotsretval\pgfutil@empty
	\else
		\immediate\write\w@pgf@writea{%
			\pgfplotsretval
		}%
	\fi
	\gdef\pgfplots@eachnth@cur{0}%
	\pgfplotsarrayforeach{pgfpl@cm@#2}\as\elem{%
		\ifnum\pgfplots@eachnth@cur=0\relax
			\gdef\pgfplots@eachnth@cur{0}%
			\pgfplotscolormapifisuniform{#2}{%
				\pgfmath@basic@multiply@{\pgfplotsarrayforeachindex}{\csname pgfpl@cm@#2@h\endcsname}%
			}{%
				\pgfplotsarrayselect\pgfplotsarrayforeachindex\of{pgfpl@cm@#1@X}\to\pgfmathresult
			}%
			\edef\pgfplots@loc@TMPa{{\elem}{#2}{\pgfplotsarrayforeachindex}{\pgfmathresult}}%
			\expandafter\pgfplotscolormaptodatafile@elem\pgfplots@loc@TMPa
			\ifx\pgfplotsretval\pgfutil@empty
			\else
				\immediate\write\w@pgf@writea{%
					\pgfplotsretval
				}%
			\fi
		\fi
		\pgfplotsutil@advancestringcounter@global\pgfplots@eachnth@cur%
		\ifnum\pgfplots@eachnth@cur=\pgfplots@eachnth\relax
			\gdef\pgfplots@eachnth@cur{0}%
		\fi
	}%
	\pgfplotscolormaptodatafile@foot{#2}%
	\ifx\pgfplotsretval\pgfutil@empty
	\else
		\immediate\write\w@pgf@writea{%
			\pgfplotsretval
		}%
	\fi
	\immediate\closeout\w@pgf@writea
	\endgroup
}

% Defines \pgfplotsretval to contain the mesh width of colormap #1.
% If the color map has a non-uniform grid, it returns the SMALLEST
% encountered mesh width.
\def\pgfplotscolormapgetmeshwidth#1{%
	\expandafter\let\expandafter\pgfplotsretval\csname pgfpl@cm@#1@h\endcsname%
}%

% defines macro #2 to contain a serialized variant of the color
% components (only the color components!)
\def\pgfplotscolormapserializecomponentstomacro#1#2{%
	\pgfplotscolormapserialize@to@macro{pgfpl@cm@#1}{#2}%
}
\def\pgfplotscolormapserialize@to@macro#1#2{%
	\pgfplotsapplistXnewempty\pgfplots@serialize@list@
	\pgfplots@loc@tmptrue
	\expandafter\pgfplotsarrayforeachungrouped\expandafter{#1}\as\elem{%
		\ifpgfplots@loc@tmp
			\expandafter\pgfplotsapplistXpushback\expandafter{\expandafter{\elem}}\to\pgfplots@serialize@list@
			\pgfplots@loc@tmpfalse
		\else
			\expandafter\pgfplotsapplistXpushback\expandafter,\expandafter{\elem}\to\pgfplots@serialize@list@
		\fi
	}%
	\pgfplotsapplistXlet#2=\pgfplots@serialize@list@
}%
\def\pgfplotscolormapserializeXtomacro#1#2{%
	\pgfplotscolormapserialize@to@macro{pgfpl@cm@#1@X}{#2}%
}%

% Copies the contents of the colormap named '#1' into a macro '#2'.
% Invocation of the macro will then re-create the colormap.
%
% #1: color map name
% #2: a macro name
\def\pgfplotscolormapserializetomacro#1#2{%
	\begingroup
		\pgfplotscolormapserializecomponentstomacro{#1}\pgfplots@serialize@list
		\pgfplotscolormapserializeXtomacro{#1}\pgfplots@serialize@list@X
		\toks0={\expandafter\def\csname pgfpl@cm@#1@h\endcsname}%
		\toks1={\expandafter\def\csname pgfpl@cm@#1@invh\endcsname}%
		\toks2={%
			\pgfplotsarraynewempty{pgfpl@cm@#1}%
			\expandafter\pgfplotsutilforeachcommasep\pgfplots@loc@TMPa\as\pgfplots@loc@TMPb{%
				\ifx\pgfplots@loc@TMPb\pgfutil@empty
				\else
					\expandafter\pgfplotsarraypushback\pgfplots@loc@TMPb\to{pgfpl@cm@#1}%
				\fi
			}%
		}%
		\toks3=\expandafter{\pgfplots@serialize@list}%
		\toks4=\expandafter{\expandafter\def\csname pgfpl@cm@#1@colspace\endcsname}%
		\toks5=\expandafter{\expandafter\def\csname pgfpl@cm@#1@col@comps\endcsname}%
		\toks6=\expandafter{\expandafter\def\csname pgfpl@cm@#1@lastindex\endcsname}%
		\toks7={%
			\pgfplotsarraynewempty{pgfpl@cm@#1@X}%
			\expandafter\pgfplotsutilforeachcommasep\pgfplots@loc@TMPa\as\pgfplots@loc@TMPb{%
				\ifx\pgfplots@loc@TMPb\pgfutil@empty
				\else
					\expandafter\pgfplotsarraypushback\pgfplots@loc@TMPb\to{pgfpl@cm@#1@X}%
				\fi
			}%
		}%
		\toks8=\expandafter{\pgfplots@serialize@list@X}%
		\xdef\pgfplots@glob@TMPa{%
			\the\toks0 {\csname pgfpl@cm@#1@h\endcsname}%
			\the\toks1 {\csname pgfpl@cm@#1@invh\endcsname}%
			\noexpand\def\noexpand\pgfplots@loc@TMPa{\the\toks3 }%
			\the\toks2
			\the\toks4 {\csname pgfpl@cm@#1@colspace\endcsname}%
			\the\toks5 {\csname pgfpl@cm@#1@col@comps\endcsname}%
			\the\toks6 {\csname pgfpl@cm@#1@lastindex\endcsname}%
			\noexpand\def\noexpand\pgfplots@loc@TMPa{\the\toks8 }%
			\the\toks7
			\def\expandafter\noexpand\csname pgfpl@cm@#1@X@scale@order@z\endcsname{\csname pgfpl@cm@#1@X@scale@order@z\endcsname}%
		}%
	\endgroup
	\let#2=\pgfplots@glob@TMPa
}%

% this is a CONSTANT! Do NOT change it!
% Just read it -- just in case \pgfplotscolormaptopdffunction will use
% a different upper bound in the future.
\def\pgfplotscolormappdfmax{1}% FIXME : why? 1000 would be more precise...?

% Expands to the size of colormap #1 .
\def\pgfplotscolormapsizeof#1{%
	\pgfplotscolormapifdefined{#1}{%
		\pgfplotsarraysizeof{pgfpl@cm@#1}%
	}{%
		0%
	}%
}%

% Expands to the last index of colormap #1 (or -1)
\def\pgfplotscolormaplastindexof#1{%
	\pgfplotscolormapifdefined{#1}{%
		\csname pgfpl@cm@#1@lastindex\endcsname%
	}{%
		-1%
	}%
}%

% Writes a PDF function of /FunctionType 3 to \pgfplotsretval
%
% The /Domain argument will be set to [ 0 \pgfplotscolormappdfmax ] and bounds will be
% computed accordingly.
%
% Note that the value depends on 'colormap access'
%
% #1: the colormap
\def\pgfplotscolormaptopdffunction#1{%
	\begingroup
	\pgfplotscolormapassertexists{#1}%
	\pgfplotsapplistXnewempty\pgfplots@resultaccum
	\pgfplotsapplistXpushback{
		<< 
			/FunctionType 3 
			/Domain [0 \pgfplotscolormappdfmax] 
			/Functions [ 
	}\to\pgfplots@resultaccum%
	\c@pgf@counta=0
	\c@pgf@countb=\pgfplotsarraysizeof{pgfpl@cm@#1} %
	\advance\c@pgf@countb by-1
	\def\pgfplots@loc@TMPa{}%
	\pgfplotsapplistXnewempty\pgfplots@bounds@accum%
	\pgfplotsapplistXnewempty\pgfplots@encode@accum
	\ifnum\csname pgfpl@cm@#1@col@comps\endcsname>4
		\pgfplots@error{Sorry, processing more than 4 color components (as required for color map #1) is unsupported in this context}%
	\fi
	%
	\if m\pgfplots@colormap@access
		% colormap access=map
		\def\pgfplots@order{1}%
		\global\pgf@x=\csname pgfpl@cm@#1@h\endcsname pt %
		\def\pgfplots@C@left{C0}%
		\def\pgfplots@C@right{C1}%
	\else
		\if c\pgfplots@colormap@access
			% colormap access=piecewise constant
			% This has a dedicated special interval at the rightmost
			% end. 
			% See comments in pgfplotscolormapfindpiecewiseconst@precomputed@
			\def\pgfplots@order{0}%
			%
			% advance the number of intervals by 1.
			\pgfplotscolormapifisuniform{#1}{%
				% To this end, we have to compute 
				% N = n+1
				% and 
				% H = 1000 / (N-1) = 1000/n.
				% Store H in \pgf@x:
				\c@pgf@countd=\pgfplotscolormapsizeof{#1}\relax
				%
				\global\pgf@x=1000pt %
				\global\divide\pgf@x by\c@pgf@countd
			}{%
				% the very same idea as for uniform colormaps applies
				% for non-uniform maps as well: we create an
				% artificial interval at the rightmost end.
				% The idea is to think of a temporary map in the range
				% [0,1000+ h] where h is the current colormap's
				% mesh width. 
				% Since the domain is [0,1000], we map [0,1000+h]
				% linearly into [0,1000].
				%
				% This here is the scaling factor:
				\global\pgf@x=\csname pgfpl@cm@#1@X@scale@order@z\endcsname pt %
				% see also
				% \pgfplotscolormapfindpiecewiseconst@precomputed for
				% comments
			}%
			%
			% interchange the sequence in the PDF function as it is
			% defined as 
			% y = C0 + x^0 * (C1 - C0) = C1
			% -> we want the left interval boundary.
			\def\pgfplots@C@left{C1}%
			\def\pgfplots@C@right{C0}%
		\else
			% colormap access=direct
			\pgfplots@error{This should never happen}%
			% ?
			\def\pgfplots@order{0}%
			\global\pgf@x=\csname pgfpl@cm@#1@h\endcsname pt %
			\def\pgfplots@C@left{C0}%
			\def\pgfplots@C@right{C1}%
		\fi
	\fi
	%
	\pgfplotsarrayforeachungrouped{pgfpl@cm@#1}\as\cdata{%
		\edef\cdata{%
			\expandafter
			\expandafter
			\csname pgfplotscolormaptopdffunction@convertcdata@\csname pgfpl@cm@#1@col@comps\endcsname\endcsname
			\cdata\relax
		}%
		\ifnum\c@pgf@counta>0
			\edef\pgfplots@loc@TMPd{%
				<<
					/FunctionType 2
					/Domain [0 \pgfplotscolormappdfmax] 
					/\pgfplots@C@left\space [\pgfplots@loc@TMPa] /\pgfplots@C@right\space [\cdata] 
					/N \pgfplots@order
				>>
			}%
			\expandafter\pgfplotsapplistXpushback\expandafter{\pgfplots@loc@TMPd}\to\pgfplots@resultaccum
			\ifnum\c@pgf@counta<\c@pgf@countb\relax
				\pgfplotscolormapifisuniform{#1}{%
					\pgf@xa=\pgf@x
					\multiply\pgf@xa by\c@pgf@counta\relax
				}{%
					\pgfplotsarrayselect{\c@pgf@counta}\of{pgfpl@cm@#1@X}\to\pgfplots@loc@TMPc
					\if m\pgfplots@colormap@access
						% colormap access=map
						\pgf@xa=\pgfplots@loc@TMPc pt %
					\else
						\pgf@xa=\pgfplots@loc@TMPc\pgf@x%
					\fi
				}%
				\divide\pgf@xa by1000 % we want [ 0 1 ] not [0 1000] as domain XXX : why!?
				\edef\pgfplots@loc@TMPc{ \pgf@sys@tonumber\pgf@xa}%
				\expandafter\pgfplotsapplistXpushback\expandafter{\pgfplots@loc@TMPc}\to\pgfplots@bounds@accum%
			\fi
			\pgfplotsapplistXpushback{ 0 1}\to\pgfplots@encode@accum%
		\fi
		\let\pgfplots@loc@TMPa=\cdata
		\advance\c@pgf@counta by1
	}%
	\if 0\pgfplots@order
		% add an artificial interval.
		\edef\pgfplots@loc@TMPd{%
			<<
				/FunctionType 2
				/Domain [0 \pgfplotscolormappdfmax] 
				/\pgfplots@C@left\space [\cdata] /\pgfplots@C@right\space [\cdata] 
				/N \pgfplots@order
			>>
		}%
		\expandafter\pgfplotsapplistXpushback\expandafter{\pgfplots@loc@TMPd}\to\pgfplots@resultaccum
		\advance\c@pgf@counta by-1 %
		\pgfplotscolormapifisuniform{#1}{%
			\pgf@xa=\pgf@x
			\multiply\pgf@xa by\c@pgf@counta\relax
		}{%
			\pgfplotsarrayselect{\c@pgf@counta}\of{pgfpl@cm@#1@X}\to\pgfplots@loc@TMPc
			\pgf@xa=\pgfplots@loc@TMPc\pgf@x%
		}%
		\divide\pgf@xa by1000 % we want [ 0 1 ] not [0 1000] as domain XXX : why!?
		\edef\pgfplots@loc@TMPc{ \pgf@sys@tonumber\pgf@xa}%
		\expandafter\pgfplotsapplistXpushback\expandafter{\pgfplots@loc@TMPc}\to\pgfplots@bounds@accum%
		\pgfplotsapplistXpushback{ 0 1}\to\pgfplots@encode@accum%
	\fi
	\pgfplotsapplistXlet\pgfplotsretval=\pgfplots@resultaccum
	\pgfplotsapplistXlet\pgfplotsbounds=\pgfplots@bounds@accum
	\pgfplotsapplistXlet\pgfplotsencode=\pgfplots@encode@accum
	\t@pgfplots@toka=\expandafter{\pgfplotsretval}%
	\t@pgfplots@tokb=\expandafter{\pgfplotsbounds}%
	\t@pgfplots@tokc=\expandafter{\pgfplotsencode}%
	\xdef\pgfplots@glob@TMPa{%
			\the\t@pgfplots@toka
			]
			/Bounds [\the\t@pgfplots@tokb]
			/Encode [\the\t@pgfplots@tokc]
		>>
	}%
	\endgroup
	\let\pgfplotsretval=\pgfplots@glob@TMPa
}%
\expandafter\def\csname pgfplotscolormaptopdffunction@convertcdata@1\endcsname#1\relax{#1}%
\expandafter\def\csname pgfplotscolormaptopdffunction@convertcdata@2\endcsname#1,#2\relax{#1 #2}%
\expandafter\def\csname pgfplotscolormaptopdffunction@convertcdata@3\endcsname#1,#2,#3\relax{#1 #2 #3}%
\expandafter\def\csname pgfplotscolormaptopdffunction@convertcdata@4\endcsname#1,#2,#3,#4\relax{#1 #2 #3 #4}%

% Invokes '#2' if a color map named '#1' exists and '#3' if no such color map exists.
\def\pgfplotscolormapifdefined#1#2#3{\pgfplotsarrayifdefined{pgfpl@cm@#1}{#2}{#3}}%

\def\pgfplotscolormapassertexists#1{%
	\pgfplotscolormapifdefined{#1}{}{%
		\pgfutil@ifundefined{pgfplotscolormap@errorissued@#1}{%
			\pgfplots@error{The colormap `#1' is undefined! Maybe you misspelled it?}%
		}{}%
		\expandafter\gdef\csname pgfplotscolormap@errorissued@#1\endcsname{1}%
		\pgfplotscreatecolormap{#1}{color(0cm)=(blue); color(1cm)=(yellow)}%
	}%
}

% Convert a colormap into a PGF shading's color specification for use
% in \pgfdeclare*shading.
%
% #1: the colormap's name.
% #2: the PGF "size" of the shading. It is used to set the right end
% of the color specification.
% #3: a macro which will be filled with the result.
%
% Example:
% \pgfplotscolormaptoshadingspec{my colormap}{4cm}{\output}
% \def\tempb{\pgfdeclarehorizontalshading{myshadingA}{1cm}}
% \expandafter\tempb\expandafter{\temp}	
%
% \pgfuseshading{myshadingA}
\def\pgfplotscolormaptoshadingspec#1#2#3{%
	\pgfplotscolormapassertexists{#1}%
	\begingroup
	\def\pgfplots@rgb{rgb}%
	\pgfmathparse{#2}%
	\expandafter\pgfmathdivide@\expandafter{\pgfmathresult}{\pgfplotscolormaprange}%
	\let\pgfplots@loc@TMPb=\pgfmathresult
	\pgfmathmultiply@{\csname pgfpl@cm@#1@h\endcsname}{\pgfplots@loc@TMPb}%
	\pgf@ya=\pgfmathresult pt
	\c@pgf@counta=0
	\let#3=\pgfutil@empty
	\pgfplotsarrayforeachungrouped{pgfpl@cm@#1}\as\pgfplotscolormaptoshadingspec@TMP{%
		\pgfplotscolormapifisuniform{#1}{%
			\pgf@yb=\c@pgf@counta\pgf@ya
		}{%
			\pgfplotsarrayselect\c@pgf@counta\of{pgfpl@cm@#1@X}\to\pgfplots@loc@TMPd
			\pgfmathmultiply@{\pgfplots@loc@TMPd}{\pgfplots@loc@TMPb}%
			\pgf@yb=\pgfmathresult pt %
		}%
		\edef\pgfplots@colspace{\csname pgfpl@cm@#1@colspace\endcsname}%
		% FIXME : PGF shadings accept only RGB!
		\if1\pgfplotscolormaptoshadingspectorgb
			\ifx\pgfplots@colspace\pgfplots@rgb
			\else
				\pgfutil@ifundefined{pgfpl@cm@#1@warned}{%
					\expandafter\gdef\csname pgfpl@cm@#1@warned\endcsname{1}%
					\pgfplotswarning{lossy colormap rgb conversion}{#1}{\pgfplots@colspace}\pgfeov%
				}{%
				}%
				\edef\pgf@tempcolor{{\pgfplots@colspace}{\pgfplotscolormaptoshadingspec@TMP}}%
				\expandafter\pgfutil@convertcolorspec\pgf@tempcolor{rgb}{\pgfplotscolormaptoshadingspec@TMP}%
				\def\pgfplots@colspace{rgb}%
			\fi
		\fi
		\edef\pgfplots@loc@TMPc{\pgfplots@colspace(\the\pgf@yb)=(\pgfplotscolormaptoshadingspec@TMP)}%
		\ifx#3\pgfutil@empty
			\t@pgfplots@toka={}%
		\else
			\t@pgfplots@toka=\expandafter{#3; }%
		\fi
		\t@pgfplots@tokb=\expandafter{\pgfplots@loc@TMPc}%
		\edef#3{\the\t@pgfplots@toka \the\t@pgfplots@tokb }%
		\advance\c@pgf@counta by1
	}%
	\pgfmath@smuggleone#3%
	\endgroup
}%
\def\pgfplotscolormaptoshadingspectorgb{1}%

% The same as \pgfplotscolormaptoshadingspec, but this here yields the
% *reversed* sequence.
\def\pgfplotscolormapreversedtoshadingspec#1#2#3{%
	\begingroup
	\let\pgfplotsarrayforeachungrouped=\pgfplotsarrayforeachreversedungrouped
	\pgfplotscolormaptoshadingspec{#1}{#2}{#3}%
	\pgfmath@smuggleone#3%
	\endgroup
}%


% Expands to the transformed range's right end of every colormap. The left
% end is fixed to '0'.
\def\pgfplotscolormaprange{1000}
\pgfmathfloatcreate{1}{1.0}{3}%
\let\pgfplotscolormaprange@float=\pgfmathresult

\def\pgfplotscolormapgetcolorspace#1{%
	\edef\pgfplotsretval{\csname pgfpl@cm@#1@colspace\endcsname}%
}%
\def\pgfplotscolormapgetcolorcomps#1{%
	\edef\pgfplotsretval{\csname pgfpl@cm@#1@col@comps\endcsname}%
}%
\def\pgfplotscolormapcolorspaceof#1{%
	\csname pgfpl@cm@#1@colspace\endcsname%
}%
\def\pgfplotscolormapcolorcompsof#1{%
	\csname pgfpl@cm@#1@col@comps\endcsname%
}%


% Linearly maps the number #4 into the colormap #5 and returns the
% interpolated colors into \pgfmathresult. The result will be a triple
% for an RGB colormap and it will contain four numbers for CMYK. The
% components of the result will be in the range [0:1].
% 
% [#1:#2]  the number range of the data source (i.e. of #4). This is required to
%          map into the colormap.
% [#3]     (optional) the quantity 
% 			 s := \pgfplotscolormaprange / (#2-#1).
% 		   Precomputing this quantity may save a lot of time because
% 		   divisions are expensive in TeX. You can omit [#3] or
% 		   provide an empty string here.
% #4       the number to map.
% #5       the colormap's name. Must be defined with
%          \pgfplotscreatecolormap before.
%
% Example:
% \pgfplotscolormapfind[-1:1]{0.2}{my colormap}
\def\pgfplotscolormapfind[#1:#2]{%
	\pgfutil@ifnextchar[{%
		\pgfplotscolormapfind@precomputed[#1:#2]%
	}{%
		\pgfplotscolormapfind@precomputed[#1:#2][]%
	}%
}%
\def\pgfplotscolormapfind@precomputed[#1:#2][#3]#4#5{%
	\ifpgfplots@LUA@supported
		\pgfplotscolormapifisuniform{#5}{%
			\edef\pgfmathresult{%
				\pgfplotsutil@directlua{%
					pgfplots.texColorMapPrecomputed("#5", #1,#2,#4)
				}%
			}%
			\ifx\pgfmathresult\pgfutil@empty
				\pgfplotscolormapfind@precomputed@warn@LUA{#5}%
				\pgfplotscolormapfind@precomputed@[#1:#2][#3]{#4}{#5}%
			\else
				%\message{LUA colormapfind[#1:#2](#4)(#5) = \pgfmathresult^^J}%
			\fi
		}{%
			% FIXME : implement LUA for non-uniform colormaps
			\pgfplotscolormapfind@precomputed@[#1:#2][#3]{#4}{#5}%
		}%
	\else
		\pgfplotscolormapfind@precomputed@[#1:#2][#3]{#4}{#5}%
	\fi
}

\def\pgfplotscolormapfind@precomputed@warn@LUA#1{%
	\expandafter\ifx\csname pgfplotscolormapfind@precomputed@warn@LUA@#1\endcsname\relax
		\pgfplotswarning{lua colormap unavailable}{#1}\pgfeov%
		\expandafter\gdef\csname pgfplotscolormapfind@precomputed@warn@LUA@#1\endcsname{1}%
	\fi
}%
\def\pgfplotscolormapfind@transform[#1:#2][#3]#4#5{%
	\edef\pgfplots@loc@TMPa{#1:#2}%
	\edef\pgfplots@loc@samerange{0:\pgfplotscolormaprange}%
	\ifx\pgfplots@loc@TMPa\pgfplots@loc@samerange
		% we have phi(#4) = #4  because #4 in [0:1000].
		\edef\pgfmathresult{#4}%
	\else
		% Step 0: compute #3 if it is missing and write it into \pgfplots@loc@TMPa.
%\message{mapping '#4' into colormap '#5' with range [#1:#2] ... ^^J}%
		\pgfmathfloatparsenumber{#1}%
		\let\pgfplots@L=\pgfmathresult
		%
		\def\pgfplots@loc@TMPa{#3}%
		\ifx\pgfplots@loc@TMPa\pgfutil@empty
			\pgfmathfloatparsenumber{#2}%
			\let\pgfplots@R=\pgfmathresult
			\pgfmathfloatsubtract@{\pgfplots@R}{\pgfplots@L}%
			\let\pgfplots@loc@TMPb=\pgfmathresult
			\pgfmathfloatdivide@{\pgfplotscolormaprange@float}{\pgfplots@loc@TMPb}%
		\else
			\pgfmathfloatparsenumber{#3}%
		\fi
		\let\pgfplots@loc@TMPa=\pgfmathresult
		%
		% Step 1: perform lookup. Map #4 into the colormap's range
		% using the linear trafo
		% phi(#4) = ( #4 - #1 ) / (#2-#1) * colormaprange(#5).
		% This, determine the INTERVAL number into which #4 falls.
		\pgfmathfloatparsenumber{#4}%
		\let\pgfplots@V=\pgfmathresult
		\pgfmathfloatsubtract@{\pgfplots@V}{\pgfplots@L}%
		\expandafter\pgfmathfloatmultiply@\expandafter{\pgfmathresult}{\pgfplots@loc@TMPa}%
		\pgfmathfloattofixed\pgfmathresult
	\fi
	\ifdim\pgfmathresult pt<0pt
		\def\pgfmathresult{0}%
	\else
		\ifdim\pgfmathresult pt>1000pt
			\def\pgfmathresult{1000}%
		\fi
	\fi
}%
\def\pgfplotscolormapfind@precomputed@[#1:#2][#3]#4#5{%
	\pgfplotscolormapassertexists{#5}%
	\begingroup
	\pgfplotscolormapfind@transform[#1:#2][#3]{#4}{#5}%
	\let\pgfplotscolormapfind@transformedx=\pgfmathresult
	%
	% Now, we have it in [0,1000]. Find the correct interval:
	\pgfplotscolormapifisuniform{#5}{%
		\pgfmathmultiply@{\pgfplotscolormapfind@transformedx}{\csname pgfpl@cm@#5@invh\endcsname}%
		\let\pgfplotscolormapfind@transformedx@divh=\pgfmathresult
		% assign \pgfplotscolormapfind@intervalno := \pgfmathresult
		% without '.0' suffix:
		\expandafter\pgfplotscolormap@floor@unforgiving\pgfmathresult\relax
		% Step 2: interpolate the desired RGB value using vector valued
		% interpolation on the identified interval.
		\c@pgf@counta=\pgfplotscolormapfind@intervalno\relax
		% color^m(x) = ( (x-x_i)/(x_{i+1} - x_i) ) * (c_{i+1}^m - c_i^m ) + c_i^m
		%            = ( x/h - i ) * ( c_{i+1}^m - c_{i}^m ) + c_i^m 
		%            = s * c_{i+1}^m  + S * c_i^m
		%
		%  s= x_h / h -i 
		\pgfmathsubtract@{\pgfplotscolormapfind@transformedx@divh}{\pgfplotscolormapfind@intervalno}%
		\let\pgfplots@loc@factor=\pgfmathresult
	}{%
		\pgfplotsarraybinarysearch{pgfpl@cm@#5@X}{\pgfplotscolormapfind@transformedx}{0}{\pgfplotscolormapsizeof{#5}}%
		\c@pgf@counta=\pgfplotsretval\relax
		\ifnum\c@pgf@counta<0
			% as per definition of \pgfplotsarraybinarysearch, a
			% negative result indicates the "insertion point" ...
			\c@pgf@counta=-\c@pgf@counta
			% ... plus one.
			\advance\c@pgf@counta by-1
			%
			% But we do not WANT the insertion point! We want the LEFT
			% interval boundary!
			\advance\c@pgf@counta by-1
		\fi
		%
		% color^m(x) = ( (x-x_i)/(x_{i+1} - x_i) ) * (c_{i+1}^m - c_i^m ) + c_i^m
		%            = s * c_{i+1}^m  + S * c_i^m
		%
		%  s = (x - x_i) / (x_{i+1} - x_i)
		\begingroup
		\pgfplotsarrayselect\c@pgf@counta\of{pgfpl@cm@#5@X}\to\pgfplotscolormapfind@rgb@X@left
		\advance\c@pgf@counta by1
		\ifnum\c@pgf@counta<\pgfplotsarraysizeof{pgfpl@cm@#5} %
			% ok, we really have an interval
			\pgfplotsarrayselect\c@pgf@counta\of{pgfpl@cm@#5@X}\to\pgfplotscolormapfind@rgb@X@right
			%
			\pgfmathsubtract@{\pgfplotscolormapfind@rgb@X@right}{\pgfplotscolormapfind@rgb@X@left}%
			\let\pgfplotscolormapfind@h=\pgfmathresult
			\pgfmathsubtract@{\pgfplotscolormapfind@transformedx}{\pgfplotscolormapfind@rgb@X@left}%
			\let\pgfplots@loc@TMPa=\pgfmathresult
			\pgfmathdivide@{\pgfplots@loc@TMPa}{\pgfplotscolormapfind@h}%
			\let\pgfplots@loc@factor=\pgfmathresult
		\else
			% irrelevant (not used)
			\def\pgfplots@loc@factor{1}%
		\fi
		\pgfmath@smuggleone\pgfplots@loc@factor
		\endgroup
	}%
	% POSTCONDITION: \c@pgf@counta is the index of the LEFT interval
	%                and \pgfplots@loc@factor is the factor for the linear interpolation.
	%
%\message{mapping [#1,#2] -> [0,\pgfplotscolormaprange]  yielded phi(#4) = \pgfplotscolormapfind@transformedx, situated in interval no \the\c@pgf@counta.^^J}%
	\pgfplotsarrayselect\c@pgf@counta\of{pgfpl@cm@#5}\to\pgfplotscolormapfind@rgb@LEFT
	%
	% do the stuff which is specific to linear interpolation:
	%
	%  S = 1 - s
	\pgfmathsubtract@{1}{\pgfplots@loc@factor}%
	\let\pgfplots@loc@factor@two=\pgfmathresult
	%
	\advance\c@pgf@counta by1 %
	\ifnum\c@pgf@counta<\pgfplotsarraysizeof{pgfpl@cm@#5} %
		% Ah: (selected index < length)  . That means: we have an interval.
		\pgfplotsarrayselect\c@pgf@counta\of{pgfpl@cm@#5}\to\pgfplotscolormapfind@rgb@RIGHT
%\message{After lookup: the corresponding RGB interval boundaries are [\pgfplotscolormapfind@rgb@LEFT: \pgfplotscolormapfind@rgb@RIGHT].^^J}%
		%
		%
		\pgfplotscolorzero{\csname pgfpl@cm@#5@col@comps\endcsname}%
		\pgfplotscoloraddweighted
			{\csname pgfpl@cm@#5@col@comps\endcsname}
			{\pgfplotsretval}%
			{\pgfplots@loc@factor@two}%
			{\pgfplotscolormapfind@rgb@LEFT}%
		\pgfplotscoloraddweighted
			{\csname pgfpl@cm@#5@col@comps\endcsname}
			{\pgfplotsretval}%
			{\pgfplots@loc@factor}%
			{\pgfplotscolormapfind@rgb@RIGHT}%
		\let\pgfmathresult=\pgfplotsretval
	\else
		% Ah: selected index = last index. Use the rightmost color!
		\let\pgfmathresult=\pgfplotscolormapfind@rgb@LEFT
	\fi
	\pgfmath@smuggleone\pgfmathresult
	\endgroup
%\message{-> got finally mapping(#4, #5) = RGB'\pgfmathresult'.}%
}%


% Maps the number #4 into the colormap #5 using piecewise constant
% interpolation. It returns the interpolated colors into \pgfmathresult. The result will be a triple
% for an RGB colormap and it will contain four numbers for CMYK. The
% components of the result will be in the range [0:1].
% 
% [#1:#2]  the number range of the data source (i.e. of #4). This is required to
%          map into the colormap.
% [#3]     (optional) the quantity 
% 			 s := \pgfplotscolormaprange / (#2-#1).
% 		   Precomputing this quantity may save a lot of time because
% 		   divisions are expensive in TeX. You can omit [#3] or
% 		   provide an empty string here.
% #4       the number to map.
% #5       the colormap's name. Must be defined with
%          \pgfplotscreatecolormap before.
%
% Example:
% \pgfplotscolormapfindpiecewiseconst[-1:1]{0.2}{my colormap}
\def\pgfplotscolormapfindpiecewiseconst[#1:#2]{%
	\pgfutil@ifnextchar[{%
		\pgfplotscolormapfindpiecewiseconst@precomputed[#1:#2]%
	}{%
		\pgfplotscolormapfindpiecewiseconst@precomputed[#1:#2][]%
	}%
}%
\def\pgfplotscolormapfindpiecewiseconst@precomputed[#1:#2][#3]#4#5{%
	%\ifpgfplots@LUA@supported
	\iffalse
		% FIXME : implement
		\edef\pgfmathresult{%
			\pgfplotsutil@directlua{%
				pgfplots.texColorMapPrecomputed("#5", #1,#2,#4)
			}%
		}%
		\ifx\pgfmathresult\pgfutil@empty
			\pgfplotscolormapfindpiecewiseconst@precomputed@warn@LUA{#5}%
			\pgfplotscolormapfindpiecewiseconst@precomputed@[#1:#2][#3]{#4}{#5}%
		\else
			%\message{LUA colormapfindpiecewiseconst[#1:#2](#4)(#5) = \pgfmathresult^^J}%
		\fi
	\else
		\pgfplotscolormapfindpiecewiseconst@precomputed@[#1:#2][#3]{#4}{#5}%
	\fi
}

\def\pgfplotscolormapfindpiecewiseconst@precomputed@warn@LUA#1{%
	\expandafter\ifx\csname pgfplotscolormapfindpiecewiseconst@precomputed@warn@LUA@#1\endcsname\relax
		\pgfplotswarning{lua colormap unavailable}{#1}\pgfeov%
		\expandafter\gdef\csname pgfplotscolormapfindpiecewiseconst@precomputed@warn@LUA@#1\endcsname{1}%
	\fi
}%

\def\pgfplotscolormapfindpiecewiseconst@precomputed@[#1:#2][#3]#4#5{%
	\pgfplotscolormapassertexists{#5}%
	\begingroup
	\pgfplotscolormapfind@transform[#1:#2][#3]{#4}{#5}%
	\let\pgfplotscolormapfind@transformedx=\pgfmathresult
	%
	% Now, we have it in [0,1000]. Find the correct interval:
	% In principle, we could easily find the correct interval. But the
	% native approach has one distinct disadvantage: we will never
	% assign the rightmost color unless #4=1000! That means that our
	% colormap is not used entirely.
	%
	% I decided to enlarge the colormap artificially such that the
	% rightmost color receives its own interval.
	% 
	% To this end, I recompute the coordinates at which colors "live".
	% The operations sounds more involved than it is: I simply need a NEW mesh width locally 
	% inside of this function. The new mesh width H can be computed as
	% follows, assuming that the OLD colormap has mesh width h.
	%
	% H := 1000/ (N-1)
	%
	% N := n+1
	% n := 1000/h + 1 = \pgfplotscolormapsizeof{#5}
	%
	% what I really need is:
	%  1/H = N/1000 = (1000 h^{-1} +1)/ 1000 = h^{-1} + 1/1000
	%
	\pgfplotscolormapifisuniform{#5}{%
		%
		% compute 1/H here:
		\pgfmathadd@{\csname pgfpl@cm@#5@invh\endcsname}{0.001}%
		\let\pgfplots@piecewiseconst@invh=\pgfmathresult%
		\pgfmathmultiply@{\pgfplotscolormapfind@transformedx}{\pgfplots@piecewiseconst@invh}%
		\let\pgfplotscolormapfind@transformedx@divh=\pgfmathresult
		% assign \pgfplotscolormapfind@intervalno := \pgfmathresult
		% without '.0' suffix:
		\expandafter\pgfplotscolormap@floor\pgfmathresult\relax
		% Step 2: interpolate the desired RGB value using vector valued
		% interpolation on the identified interval.
		\c@pgf@counta=\pgfplotscolormapfind@intervalno\relax
	}{%
		% the same idea can also be applied to non-uniform grids.
		% However, it is more involved here.
		%
		% My idea is that I add an extra interval of length 'h' at the right end of
		% the domain, i.e. I enlarge the domain to [0,1000+h].
		% 
		% To this end, I map the input number linearly from 
		%  [0,1000] -> [0,1000+h]
		% using k(t) = (1000+h)/1000 * t
		%
		% Note that k(t) = 1/ pgfpl@cm@#5@X@scale@order@z
		%
		% and search in the existing X coordinates of the colormap.
		% Note that these X coordinates actually do not contain the
		% artifical rightmost boundary point at 1000+h. But that is
		% ok, we plan to assign COLOR(1000+h) := COLOR(1000) anyway.
		%
		% Naturally, some values 'k(t)' will be BEYOND '1000'. In this
		% case, we simply use the rightmost interval and are done with
		% it.
		%
		% compute k(t):
		\pgfmathadd@{1000}{\csname pgfpl@cm@#5@h\endcsname}%
		\pgf@xa=\pgfmathresult pt %
		\divide\pgf@xa by1000 %
		\edef\pgfplotscolormapfind@map@to@extra@interval{\pgf@sys@tonumber\pgf@xa}%
		%
		\pgfmathmultiply@{\pgfplotscolormapfind@transformedx}{\pgfplotscolormapfind@map@to@extra@interval}%
		\let\pgfplotscolormapfind@transformedx@=\pgfmathresult
		%
		% search k(t) in the original X values.
		\pgfplotsarraybinarysearch{pgfpl@cm@#5@X}{\pgfplotscolormapfind@transformedx@}{0}{\pgfplotscolormapsizeof{#5}}%
		\c@pgf@counta=\pgfplotsretval\relax
		\ifnum\c@pgf@counta<0
			% as per definition of \pgfplotsarraybinarysearch, a
			% negative result indicates the "insertion point" ...
			\c@pgf@counta=-\c@pgf@counta
			% ... plus one.
			\advance\c@pgf@counta by-1
			%
			% But we do not WANT the insertion point! We want the LEFT
			% interval boundary!
			\advance\c@pgf@counta by-1
		\fi
%\pgfplotscolormapserializeXtomacro{#5}\XXX
%\message{k(\pgfplotscolormapfind@transformedx) = \pgfplotscolormapfind@transformedx@. Searching for value in X=(\XXX) resulted in \pgfplotsretval, and the index to use is \the\c@pgf@counta.^^J}%
	}%
	%
	\ifnum\c@pgf@counta=\pgfplotscolormapsizeof{#5}\relax
		% we have artificially increased the "h" (see the comments
		% above) -- meaning that this 'if' can happen. 
		% ->Map the rightmost point to the rightmost interval:
		\advance\c@pgf@counta by-1
	\fi
	%
%\message{mapping [#1,#2] -> [0,\pgfplotscolormaprange]  yielded phi = \pgfplotscolormapfind@transformedx, situated in interval no \the\c@pgf@counta/\pgfplotsarraysizeof{pgfpl@cm@#5}.^^J}%
	\pgfplotsarrayselect\c@pgf@counta\of{pgfpl@cm@#5}\to\pgfplotscolormapfind@rgb@LEFT
	\let\pgfmathresult=\pgfplotscolormapfind@rgb@LEFT
	\pgfmath@smuggleone\pgfmathresult
	\endgroup
}%

\def\pgfplotscolormap@floor#1.#2\relax{%
	\ifdim0.#2pt>0.999pt
		% ok, it is ALMOST one more! Take this as rounding inaccuracy
		\c@pgf@counta=#1\relax
		\advance\c@pgf@counta by1
		\edef\pgfplotscolormapfind@intervalno{\the\c@pgf@counta}%
	\else
		\def\pgfplotscolormapfind@intervalno{#1}%
	\fi
}%

\def\pgfplotscolormap@floor@unforgiving#1.#2\relax{%
	\def\pgfplotscolormapfind@intervalno{#1}%
}%

% Performs a direct color access into color map '#2' using an index
% '#1'.
%
% #1: an index in the range 0 ... len(#2)-1.
%  If it does not match, it will be pruned. If #1 is a real number, it
%  will be truncated.
% #2: a color map name.
%
% The resulting RGB value will be written to \pgfmathresult.
\def\pgfplotscolormapgetindex#1#2{%
	\pgfplotscolormapassertexists{#2}%
	\begingroup
	\afterassignment\pgfplots@gobble@until@relax
	\c@pgf@counta=#1\relax
	\ifnum\c@pgf@counta<0
		\c@pgf@counta=0
	\else
		\pgfplotsarraysizetomacro{pgfpl@cm@#2}\to\pgfplotscolormapgetindex@
		\ifnum\c@pgf@counta<\pgfplotscolormapgetindex@\relax
		\else
			\c@pgf@counta=\pgfplotscolormapgetindex@\relax
			\advance\c@pgf@counta by-1
		\fi
	\fi
	\pgfplotsarrayselect\c@pgf@counta\of{pgfpl@cm@#2}\to\pgfmathresult
	\pgfmath@smuggleone\pgfmathresult
	\endgroup
}

% Invokes one of \pgfplotscolormapfind,
% \pgfplotscolormapfindpiecewiseconst, or \pgfplotscolormapgetindex,
% depending on the value of '/pgfplots/colormap access'.
\def\pgfplotscolormapaccess[#1:#2]{%
	\pgfutil@ifnextchar[{%
		\pgfplotscolormapaccess@precomputed[#1:#2]%
	}{%
		\pgfplotscolormapaccess@precomputed[#1:#2][]%
	}%
}
\def\pgfplotscolormapaccess@precomputed[#1:#2][#3]#4#5{%
	\if m\pgfplots@colormap@access
		% colormap access=map
		\pgfplotscolormapfind@precomputed[#1:#2][#3]{#4}{#5}%
	\else
		\if c\pgfplots@colormap@access
			% colormap access=piecewise constant
			\pgfplotscolormapfindpiecewiseconst@precomputed[#1:#2][#3]{#4}{#5}%
		\else
			% colormap access=direct
			\pgfplotscolormapgetindex{#4}{#5}%
		\fi
	\fi
}%

\pgfutil@definecolor{mapped color}{rgb}{0,0,0}% make sure this color exists. It will be overwritten if needed.
% ATTENTION: replicated in pgfplots.code.tex :
\pgfplotscreatecolormap{hot}{color(0cm)=(blue); color(1cm)=(yellow); color(2cm)=(orange); color(3cm)=(red)}


\def\pgfplotspointmetatransformedrange{0:1000}

% Defines the 'mapped color' on the basis of
% the current color map.
%
% #1: is the value which should be mapped into the color map; it
% is expected in the range [0,1000] (like point meta).
\def\pgfplotscolormapdefinemappedcolor#1{%
	\expandafter\pgfplotscolormapaccess\expandafter[\pgfplotspointmetatransformedrange]
		[1.0]
		{#1}
		{\pgfkeysvalueof{/pgfplots/colormap name}}
%\message{Color for current point is RGB '\pgfmathresult' (determined using meta 'phi(\pgfplotspointmeta) = \pgfplotspointmetatransformed')^^J}%
	\def\pgfplots@loc@TMPb{\pgfutil@definecolor{mapped color}{\csname pgfpl@cm@\pgfkeysvalueof{/pgfplots/colormap name}@colspace\endcsname}}%
	\expandafter\pgfplots@loc@TMPb\expandafter{\pgfmathresult}%
}%

