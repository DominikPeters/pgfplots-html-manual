%--------------------------------------------
%
% Package pgfplots, library for dynamic content in PDF files
% (clickable plots)
%
% Copyright 2007/2008 by Christian Feuers√§nger.
%
% This program is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program.  If not, see <http://www.gnu.org/licenses/>.
%
%--------------------------------------------

\edef\pgfplotscatcodeDQ{\the\catcode`\"}%
\catcode`\"=12

\newif\ifpgfplots@clickable
\newif\ifpgfplots@annot@printable

\pgfqkeys{/pgfplots}{
	@backgroundpath@hook/.add code={}{\pgfplots@create@clickable@plotarea@hook},
	clickable/.is if=pgfplots@clickable,
	clickable/.default=true,
	clickable=true,
	/pgfplots/execute at begin axis/.add={}{%
		\pgfplots@clickable@beginaxis
	},%
	clickable coords code/.code={
		\def\pgfplots@clickable@init@@{%
			\pgfplots@clickable@startcoordcollect
			\pgfplotsset{%
				/pgfplots/execute at end plot@@/.add={}{%
					\pgfplots@clickable@endcoordcollect
				},
				/pgfplots/execute for finished point/.add={}{%
					\pgfplots@clickable@coordcollect{#1}%
				},%
			}%
			\let\pgfplots@clickable@init@@=\relax
		}%
		\pgfkeysalso{%
			/pgfplots/execute at begin plot@@/.add={}{%
				\pgfplots@clickable@init@@
			},
		}%
	},
	clickable coords/.style={
		clickable coords code={\def\pgfplotsretval{#1}},
	},
	clickable coords/.default={(xy)},
	annot/js fillColor/.initial={["RGB",1,1,.855]},
	annot/point format/.initial={(\%.1f, \%.1f)},
	annot/point format 3d/.initial={(\%.1f, \%.1f, \%.1f)},
	annot/slope format/.initial={\%.1f*x \%+.1f},
	annot/printable/.is if=pgfplots@annot@printable,
	annot/printable/.default=true,
	% Available are:
% Times-Roman           font.Times
% Times-Bold            font.TimesB
% Times-Italic          font.TimesI
% Times-BoldItalic      font.TimesBI
% Helvetica             font.Helv
% Helvetica-Bold        font.HelvB
% Helvetica-Oblique     font.HelvI
% Helvetica-BoldOblique font.HelvBI
% Courier               font.Cour
% Courier-Bold          font.CourB
% Courier-Oblique       font.CourI
% Courier-BoldOblique   font.CourBI
% Symbol                font.Symbol
% ZapfDingbats          font.ZapfD
	annot/font/.initial={font.Times},
%	annot/font={"CMR10"},
	annot/textSize/.initial=11,
	annot/width/.initial=,
	annot/height/.initial=,
	annot/jsname/.initial=,
	annot/dim/.initial=2,
	annot/xmin/.initial=,
	annot/xmax/.initial=,
	annot/ymin/.initial=,
	annot/ymax/.initial=,
	annot/zmin/.initial=,
	annot/zmax/.initial=,
	annot/xscale/.initial=, % "log" or "linear" or "log:<basis>"
	annot/yscale/.initial=,
	annot/zscale/.initial=,
	annot/minminmin/.initial=,
	annot/xaxis/.initial=,
	annot/yaxis/.initial=,
	annot/zaxis/.initial=,
	% format: 
	% 	[<plot1coords>, <plot2coords>,...,<plotncoords>]
	% with <ploticoords> = [<coord>,<coord>,....,<coord>]
	% and <coord> = [ <x>, <y>, "text" ]
	% for example:
	% 	[[[0.0e0,-4.0849609e-1,": (0,0)"],[1.25e-1,-3.7412109e-1,": (3,1)"],[2.5e-1,-3.0849609e-1,": (2,1)"],[3.75e-1,-2.1162109e-1,": (3,3)"],[5.0e-1,-8.3496094e-2,": (1,1)"],[6.25e-1,7.5878906e-2,": (3,5)"],[7.5e-1,2.6650391e-1,": (2,3)"],[8.75e-1,4.8837891e-1,": (3,7)"],[1.0e0,7.4150391e-1,": (0,1)"]]]
	annot/collected plots/.initial=,
	annot/snap dist/.initial=4,
	every semilogy axis/.append style={/pgfplots/annot/point format={(\%.1f, \%.1e)}},
	every semilogx axis/.append style={/pgfplots/annot/point format={(\%.1e, \%.1f)}},
	every loglog axis/.append style={/pgfplots/annot/point format={(\%.1e, \%.1e)}},
}

\pgfkeysifdefined{/pgfplots/annot/xy pattern}{%
}{%
	\pgfkeyssetvalue{/pgfplots/annot/xy pattern}{(xy)}%
}%
\pgfkeysifdefined{/pgfplots/annot/no such coord}{%
}{%
	\pgfkeyssetvalue{/pgfplots/annot/no such coord}{--}%
}%

% ATTENTION:
% The eforms package creates \begin{Form} and \end{Form} in \AtBeginDocument and \AtEndDocument!
\def\pgfplots@glob@TMPa{pgfsys-pdftex.def}
\ifx\pgfplots@glob@TMPa\pgfsysdriver
	\RequirePackage[pdftex]{insdljs}
	\RequirePackage[pdftex]{eforms}
\else
\def\pgfplots@glob@TMPa{pgfsys-dvipdfm.def}
\ifx\pgfplots@glob@TMPa\pgfsysdriver
	\RequirePackage[dvipdfm]{insdljs}
	\RequirePackage[dvipdfm]{eforms}
\else
\def\pgfplots@glob@TMPa{pgfsys-dvips.def}
\ifx\pgfplots@glob@TMPa\pgfsysdriver
	\RequirePackage[dvips]{insdljs}
	\RequirePackage[dvips]{eforms}
\else
\def\pgfplots@glob@TMPa{pgfsys-textures.def}
\ifx\pgfplots@glob@TMPa\pgfsysdriver
	\RequirePackage[textures]{insdljs}
	\RequirePackage[textures]{eforms}
\else
	\RequirePackage{insdljs}
	\RequirePackage{eforms}
\fi\fi\fi\fi

% Work-around for a bug in \begindljs of acrotex:
% if " is active, \begindljs will be wrong.
\def\begindljs
{%
    \iwvo{\string\begingroup}
    {\uccode`c=`\%\uppercase{\iwvo{\string\obeyspaces\string\obeylines\string\global\string\let\string^\string^M=\string\jsR c}}}
    {\escapechar=-1 \lccode`C=`\%\lowercase{\iwvo{\string\\catcode`\string\\"=12C}}}
}

\def\pgfplots@clickable@no{0}

% This catcode-hackery is too much for me, I don't get '|' to work in
% conjunction with ltxdoc document style.
% So, I simply use \pgfplotsVERTBAR instead... *sigh*.
{
\catcode`\"=12
\gdef\pgfplotsDQ{"}%
\catcode`\|=12
\gdef\pgfplotsVERTBAR{|}%
\catcode`\#=12
\gdef\pgfplotsHASH{#}%
\catcode`\%=12 \gdef\pgfplotsPERCENT{%}}

% FIXME : write this stuff DIRECTLY into a pdf using \pdfobj! I don't
% need ANY TeX code inside of the methods. Maybe I can even use some
% sort of "include external .js file" command instead of /S /Javascript /JS
%
% FIXME : using '\jobname' here produces a bug in insdljs :-(
% The problem: insdljs creates a macro named 'dlsj\jobname' or
% something like that, but if fails to use '\csname' properly. So:
% only normal letters are allowed inside of the argument here.
\begin{insDLJS}[processAnnotatedPlot]{pgfplotsJS}{pgfplots Clickable Plot Code}
/*********************************************************************************
 * function sprintf() - written by Kevin van Zonneveld as part of the php to javascript 
 * conversion project.
 * 
 * More info at: http://kevin.vanzonneveld.net/techblog/article/phpjs_licensing/
 * 
 * This is version: 1.33
 * php.js is copyright 2008 Kevin van Zonneveld.
 * 
 * Portions copyright Michael White (http://crestidg.com), _argos, Jonas
 * Raoni Soares Silva (http://www.jsfromhell.com), Legaev Andrey, Ates Goral
 * (http://magnetiq.com), Philip Peterson, Martijn Wieringa, Webtoolkit.info
 * (http://www.webtoolkit.info/), Carlos R. L. Rodrigues
 * (http://www.jsfromhell.com), Ash Searle (http://hexmen.com/blog/),
 * Erkekjetter, GeekFG (http://geekfg.blogspot.com), Johnny Mast
 * (http://www.phpvrouwen.nl), marrtins, Alfonso Jimenez
 * (http://www.alfonsojimenez.com), Aman Gupta, Arpad Ray
 * (mailto:arpad@php.net), Karol Kowalski, Mirek Slugen, Thunder.m, Tyler
 * Akins (http://rumkin.com), d3x, mdsjack (http://www.mdsjack.bo.it), Alex,
 * Alexander Ermolaev (http://snippets.dzone.com/user/AlexanderErmolaev),
 * Allan Jensen (http://www.winternet.no), Andrea Giammarchi
 * (http://webreflection.blogspot.com), Arno, Bayron Guevara, Ben Bryan,
 * Benjamin Lupton, Brad Touesnard, Brett Zamir, Cagri Ekin, Cord, David,
 * David James, DxGx, FGFEmperor, Felix Geisendoerfer
 * (http://www.debuggable.com/felix), FremyCompany, Gabriel Paderni, Howard
 * Yeend, J A R, Leslie Hoare, Lincoln Ramsay, Luke Godfrey, MeEtc
 * (http://yass.meetcweb.com), Mick@el, Nathan, Nick Callen, Ozh, Pedro Tainha
 * (http://www.pedrotainha.com), Peter-Paul Koch
 * (http://www.quirksmode.org/js/beat.html), Philippe Baumann, Sakimori,
 * Sanjoy Roy, Simon Willison (http://simonwillison.net), Steve Clay, Steve
 * Hilder, Steven Levithan (http://blog.stevenlevithan.com), T0bsn, Thiago
 * Mata (http://thiagomata.blog.com), Tim Wiel, XoraX (http://www.xorax.info),
 * Yannoo, baris ozdil, booeyOH, djmix, dptr1988, duncan, echo is bad, gabriel
 * paderni, ger, gorthaur, jakes, john (http://www.jd-tech.net), kenneth,
 * loonquawl, penutbutterjelly, stensi
 * 
 * Dual licensed under the MIT (MIT-LICENSE.txt)
 * and GPL (GPL-LICENSE.txt) licenses.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL KEVIN VAN ZONNEVELD BE LIABLE FOR ANY CLAIM, DAMAGES
 * OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */ 
// ATTENTION: this method has been masked such that special characters of TeX and javascript 
// don't produce problems.
function sprintf( ) {
    // Return a formatted string
    // 
    // +    discuss at: http://kevin.vanzonneveld.net/techblog/article/javascript_equivalent_for_phps_sprintf/
    // +       version: 804.1712
    // +   original by: Ash Searle (http://hexmen.com/blog/)
    // + namespaced by: Michael White (http://crestidg.com)
    // *     example 1: sprintf("\pgfplotsPERCENT01.2f", 123.1);
    // *     returns 1: 123.10

    var regex = /\pgfplotsPERCENT\pgfplotsPERCENT\pgfplotsVERTBAR\pgfplotsPERCENT(\d+\$)?([-+\pgfplotsHASH0 ]*)(\*\d+\$\pgfplotsVERTBAR\*\pgfplotsVERTBAR\d+)?(\.(\*\d+\$\pgfplotsVERTBAR\*\pgfplotsVERTBAR\d+))?([scboxXuidfegEG])/g;
    var a = arguments, i = 0, format = a[i++];

    // pad()
    var pad = function(str, len, chr, leftJustify) {
        var padding = (str.length >= len) ? '' : Array(1 + len - str.length >>> 0).join(chr);
        return leftJustify ? str + padding : padding + str;
    };

    // justify()
    var justify = function(value, prefix, leftJustify, minWidth, zeroPad) {
        var diff = minWidth - value.length;
        if (diff > 0) {
            if (leftJustify \pgfplotsVERTBAR\pgfplotsVERTBAR !zeroPad) {
            value = pad(value, minWidth, ' ', leftJustify);
            } else {
            value = value.slice(0, prefix.length) + pad('', diff, '0', true) + value.slice(prefix.length);
            }
        }
        return value;
    };

    // formatBaseX()
    var formatBaseX = function(value, base, prefix, leftJustify, minWidth, precision, zeroPad) {
        // Note: casts negative numbers to positive ones
        var number = value >>> 0;
        prefix = prefix && number && {'2': '0b', '8': '0', '16': '0x'}[base] \pgfplotsVERTBAR\pgfplotsVERTBAR '';
        value = prefix + pad(number.toString(base), precision \pgfplotsVERTBAR\pgfplotsVERTBAR 0, '0', false);
        return justify(value, prefix, leftJustify, minWidth, zeroPad);
    };

    // formatString()
    var formatString = function(value, leftJustify, minWidth, precision, zeroPad) {
        if (precision != null) {
            value = value.slice(0, precision);
        }
        return justify(value, '', leftJustify, minWidth, zeroPad);
    };

    // finalFormat()
    var doFormat = function(substring, valueIndex, flags, minWidth, _, precision, type) {
        if (substring == '\pgfplotsPERCENT\pgfplotsPERCENT') return '\pgfplotsPERCENT';

        // parse flags
        var leftJustify = false, positivePrefix = '', zeroPad = false, prefixBaseX = false;
        for (var j = 0; flags && j < flags.length; j++) switch (flags.charAt(j)) {
            case ' ': positivePrefix = ' '; break;
            case '+': positivePrefix = '+'; break;
            case '-': leftJustify = true; break;
            case '0': zeroPad = true; break;
            case '\pgfplotsHASH': prefixBaseX = true; break;
        }

        // parameters may be null, undefined, empty-string or real valued
        // we want to ignore null, undefined and empty-string values
        if (!minWidth) {
            minWidth = 0;
        } else if (minWidth == '*') {
            minWidth = +a[i++];
        } else if (minWidth.charAt(0) == '*') {
            minWidth = +a[minWidth.slice(1, -1)];
        } else {
            minWidth = +minWidth;
        }

        // Note: undocumented perl feature:
        if (minWidth < 0) {
            minWidth = -minWidth;
            leftJustify = true;
        }

        if (!isFinite(minWidth)) {
            throw new Error('sprintf: (minimum-)width must be finite');
        }

        if (!precision) {
            precision = 'fFeE'.indexOf(type) > -1 ? 6 : (type == 'd') ? 0 : void(0);
        } else if (precision == '*') {
            precision = +a[i++];
        } else if (precision.charAt(0) == '*') {
            precision = +a[precision.slice(1, -1)];
        } else {
            precision = +precision;
        }

        // grab value using valueIndex if required?
        var value = valueIndex ? a[valueIndex.slice(0, -1)] : a[i++];

        switch (type) {
            case 's': return formatString(String(value), leftJustify, minWidth, precision, zeroPad);
            case 'c': return formatString(String.fromCharCode(+value), leftJustify, minWidth, precision, zeroPad);
            case 'b': return formatBaseX(value, 2, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
            case 'o': return formatBaseX(value, 8, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
            case 'x': return formatBaseX(value, 16, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
            case 'X': return formatBaseX(value, 16, prefixBaseX, leftJustify, minWidth, precision, zeroPad).toUpperCase();
            case 'u': return formatBaseX(value, 10, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
            case 'i':
            case 'd': {
                        var number = parseInt(+value);
                        var prefix = number < 0 ? '-' : positivePrefix;
                        value = prefix + pad(String(Math.abs(number)), precision, '0', false);
                        return justify(value, prefix, leftJustify, minWidth, zeroPad);
                    }
            case 'e':
            case 'E':
            case 'f':
            case 'F':
            case 'g':
            case 'G':
                        {
                        var number = +value;
                        var prefix = number < 0 ? '-' : positivePrefix;
                        var method = ['toExponential', 'toFixed', 'toPrecision']['efg'.indexOf(type.toLowerCase())];
                        var textTransform = ['toString', 'toUpperCase']['eEfFgG'.indexOf(type) \pgfplotsPERCENT 2];
                        value = prefix + Math.abs(number)[method](precision);
                        return justify(value, prefix, leftJustify, minWidth, zeroPad)[textTransform]();
                    }
            default: return substring;
        }
    };

    return format.replace(regex, doFormat);
}
/*********************************************************************************/


var lastPoint = null;
var posOnMouseDownX = -1;
var posOnMouseDownY = -1;

// preallocation.
var tmpArray1 = new Array(3);
var tmpArray2 = new Array(3);

var clickablePatternForXY="\pgfkeysvalueof{/pgfplots/annot/xy pattern}";
var clickableStringNoSuchCoord = "\pgfkeysvalueof{/pgfplots/annot/no such coord}";

/**
 * Takes an already existing TextField, changes its value to point.text and places it at (x,y).
 * Additional \c displayOpts will be used to format it.
 */
function ClickableCoordDraw( canvas, point, displayOpts )
{
	canvas.value = ""+point.text;
	var R = canvas.rect;
	R[0] = point.canvasx;
	R[1] = point.canvasy;
	R[2] = R[0] + displayOpts.textSize/2*Math.max( 5,point.text.length );
	R[3] = R[1] - 1.5*displayOpts.textSize;
	canvas.rect = R;
	canvas.textFont = displayOpts.textFont;
	canvas.textSize = displayOpts.textSize;
	canvas.fillColor = displayOpts.fillColor;//["RGB",1,1,.855];
	canvas.doNotSpellCheck = true;
	canvas.readonly = true;
	if( displayOpts.printable )
		canvas.display = display.visible;
	else
		canvas.display = display.noPrint;
	
	var mark = this.getField( canvas.name + "mark");
	if( mark ) {
		R = mark.rect;
		R[0]=point.canvasx-2;
		R[1]=point.canvasy-2;
		R[2]=R[0]+4;
		R[3]=R[1]+4;
		mark.value="";
		mark.rect = R;
		mark.fillColor = ["RGB",0,0,0];
		mark.doNotSpellCheck = true;
		mark.readonly = true;
		if( displayOpts.printable )
			mark.display = display.visible;
		else
			mark.display = display.noPrint;
	}
}

function ClickableCoord(canvasx,canvasy, realx,realy, text)
{
	this.dim=2;
	this.canvasx=canvasx;
	this.canvasy=canvasy;
	this.realx=realx;
	this.realy=realy;
	this.realz=0;
	this.text=text;
	this.sourcePlotIdx = -1;
	this.sourceCoordIdx = -1;

	this.isSnapToNearestCoord = function() {
		return this.sourcePlotIdx >= 0;
	}
	this.draw=function( docObject, canvas, displayOpts )
	{
		canvas.value = ""+this.text;
		var R = canvas.rect;
		R[0] = this.canvasx;
		R[1] = this.canvasy;
		R[2] = R[0] + displayOpts.textSize/2*Math.max( 5,this.text.length );
		R[3] = R[1] - 1.5*displayOpts.textSize;
		canvas.rect = R;
		canvas.textFont = displayOpts.textFont;
		canvas.textSize = displayOpts.textSize;
		canvas.fillColor = displayOpts.fillColor;//["RGB",1,1,.855];
		canvas.doNotSpellCheck = true;
		canvas.readonly = true;
		if( displayOpts.printable )
			canvas.display = display.visible;
		else
			canvas.display = display.noPrint;
		
		var mark = docObject.getField( canvas.name + "mark");
		if( mark ) {
			R = mark.rect;
			R[0]=this.canvasx-2;
			R[1]=this.canvasy-2;
			R[2]=R[0]+4;
			R[3]=R[1]+4;
			mark.value="";
			mark.rect = R;
			mark.fillColor = ["RGB",0,0,0];
			mark.doNotSpellCheck = true;
			mark.readonly = true;
			if( displayOpts.printable )
				mark.display = display.visible;
			else
				mark.display = display.noPrint;
		}
	}
}

/**
 * @return an instance of ClickableCoord or null.
 * The returned canvas coordinates are NOT yet initialised.
 */
function findNearest( point, rect, axisAnnotObj, startSearchAt )
{
	var actx;
	var acty;
	var minSoFar = 1e324;
	var minPtSoFar = null;
	var tmpPt = null;
	var dist =0;
	var startPlot = 0;
	var startCoord = 0;
	var collectedPlots = axisAnnotObj.collectedPlots;
	if( point.dim > 2 )
		tmpPt = new ClickableCoord(0,0,0,0,"");
		
	if( startSearchAt && startSearchAt.isSnapToNearestCoord() ) {
		startPlot = startSearchAt.sourcePlotIdx;
		startCoord= startSearchAt.sourceCoordIdx;
	}
	for( var i = startPlot; i<collectedPlots.length; ++i ) {
		for( var j = startCoord; j<collectedPlots[i].length; ++j ) {
			if( point.dim == 2 ) {
				actx = collectedPlots[i][j][0] - point.realx;
				acty = collectedPlots[i][j][1] - point.realy;
			} else {
				// dim > 2 should be compared using CANVAS coordinates, not real coordinates:
				tmpPt.realx = collectedPlots[i][j][0];
				tmpPt.realy = collectedPlots[i][j][1];
				if( collectedPlots[i][j].length-1 >= 3 )
					tmpPt.realz = collectedPlots[i][j][2];
				else
					tmpPt.realz = 0;
				computeCanvasFor( tmpPt, rect, axisAnnotObj );
				actx = tmpPt.canvasx - point.canvasx;
				acty = tmpPt.canvasy - point.canvasy;
			}
			dist = actx*actx + acty*acty;
			if( dist < minSoFar ) {
			 	if( minPtSoFar == null )
					minPtSoFar = new ClickableCoord(-1,-1,0,0,"");
				minPtSoFar.realx = collectedPlots[i][j][0];
				minPtSoFar.realy = collectedPlots[i][j][1];
				if( collectedPlots[i][j].length-1 >= 3 )
					minPtSoFar.realz = collectedPlots[i][j][2];
				else
					minPtSoFar.realz = 0;
				minPtSoFar.text= collectedPlots[i][j][ collectedPlots[i][j].length-1 ];
				minPtSoFar.sourcePlotIdx = i;
				minPtSoFar.sourceCoordIdx = j;
				minSoFar = dist;
			}
		}
	}
	if( minPtSoFar )
		computeCanvasFor(minPtSoFar,rect,axisAnnotObj);
	return minPtSoFar;
}

/**
 * Returns either a ClickableCoord describing the point under the mouse cursor or a snap--to--nearest result near the mouse cursor.
 *
 * @param axisAnnotObj the axis in which we shall search.
 * @param x,y the input canvas coordinates
 * @param canvas a pointer to the Drawing object (TextField) whose 'rect' field is the drawing canvas.
 * @param startSearch either null or an instance of ClickableCoord for which isSnapToNearestCoord() returns true. 
 *   If it is not null, the next matching point *after* it will be returned (or null if there is no matching snap--to--nearest coord after it).
 * @return an instance of ClickableCoord or null in case the startSearch!=null and there are no further matches.
 */
function axisFindClickableCoord( axisAnnotObj, x,y, canvas, startSearch )
{
	// Get and modify bounding box. The mouse movement is only accurate up to one point 
	// (mouseX and mouseY are integers), so the bounding box should be an integer as well.
	var rect = canvas.rect; // rect = [ mincanvasx mincanvasy maxcanvasx maxcanvasy ]; relative to upper left corner
	rect[0] = Math.round(rect[0]);
	rect[1] = Math.round(rect[1]);
	rect[2] = Math.round(rect[2]);
	rect[3] = Math.round(rect[3]);
	canvas.rect= rect;

	var realx=-1;
	var realy=-1;
	if( axisAnnotObj.dim == 2 ) {
		// the following code inverts computeCanvasFor():
		var minminminx = rect[0] + axisAnnotObj.minminmin[0];
		var minminminy = rect[3] + axisAnnotObj.minminmin[1];
		var vecx = x - minminminx;
		var vecy = y - minminminy;
		var A = [ 
			[axisAnnotObj.xaxis[0], axisAnnotObj.yaxis[0]],
			[axisAnnotObj.xaxis[1], axisAnnotObj.yaxis[1]] ];
		var b = [ vecx, vecy ];

		var rowpermut = [0, 1];
		if( Math.abs(A[0][0]) < 0.0001 ) {
			rowpermut[0] = 1;
			rowpermut[1] = 0;
		}
		var pivot = -A[rowpermut[1]][0] / A[rowpermut[0]][0];
		var unity = (b[rowpermut[1]] + pivot*b[rowpermut[0]]) / (A[rowpermut[1]][1] + pivot * A[rowpermut[0]][1]);
		var unitx = (b[rowpermut[0]] - A[rowpermut[0]][1] * unity) / A[rowpermut[0]][0];

		realx = axisAnnotObj.xmin + unitx * (axisAnnotObj.xmax - axisAnnotObj.xmin);
		realy = axisAnnotObj.ymin + unity * (axisAnnotObj.ymax - axisAnnotObj.ymin);
		//console.println( "unitx = " + unitx + "; unity " + unity );
	}


	var point = new ClickableCoord( x,y, realx, realy, clickablePatternForXY);
	point.dim = axisAnnotObj.dim;

	if( startSearch && !startSearch.isSnapToNearestCoord() ) {
		console.println( "WARNING: startSearch().isSnapToNearestCoord() has been expected!" );
		startSearch = null;
	}
	
	var nearestClickableCoord = findNearest( point, rect,axisAnnotObj, startSearch );
	if( nearestClickableCoord ) {
		if( getDist( point.canvasx,point.canvasy,  nearestClickableCoord.canvasx, nearestClickableCoord.canvasy ) < axisAnnotObj.snapDist ) {
			return nearestClickableCoord;
		}
	}
	if( startSearch )
		point = null;
	if( axisAnnotObj.dim > 2 ) { // we didn't find a snap--to--nearest point.
		point.text = clickableStringNoSuchCoord;
	}

	return point;
}

function getVecLen( t1,t2 ) {
	return Math.sqrt( t1*t1 + t2*t2);
}
function getDist( x1,y1, x2,y2 ) {
	var t1 = (x1-x2);
	var t2 = (y1-y2);
	return getVecLen(t1,t2);
}

/**
 * Takes point's real coordinates and computes its canvas coordinates. The result is written back into \c point.
 */
function computeCanvasFor( point, rect, axisAnnotObj)
{
	var unitx = (point.realx - axisAnnotObj.xmin) / (axisAnnotObj.xmax -axisAnnotObj.xmin);
	var unity = (point.realy - axisAnnotObj.ymin) / (axisAnnotObj.ymax -axisAnnotObj.ymin);

	point.canvasx = rect[0] + axisAnnotObj.minminmin[0] + axisAnnotObj.xaxis[0] * unitx + axisAnnotObj.yaxis[0] * unity;
	point.canvasy = rect[3] + axisAnnotObj.minminmin[1] + axisAnnotObj.xaxis[1] * unitx + axisAnnotObj.yaxis[1] * unity;
	if( axisAnnotObj.dim >= 3 ) {
		var unitz = (point.realz - axisAnnotObj.zmin) / (axisAnnotObj.zmax -axisAnnotObj.zmin);
		point.canvasx += axisAnnotObj.zaxis[0] * unitz;
		point.canvasy += axisAnnotObj.zaxis[1] * unitz;
	}
}
/**
 * Changes all required Field values of \c plotRegionField, inserts the proper
 * value and displays it at the pdf positions (x,y) .
 *
 * @param plotRegionField a reference to a Field object.
 * @param x the x canvas coordinate where the annotation shall be placed and which is used to determine
 *  the annotation text.
 * @param y the corresponding y coord.
 * @param axisAnnotObj An object containing axis references.
 * @param displayOpts An object for display flags.
 * @param[out] retCoords will be filled with the point in axis coordinates (should have length axisAnnotObj.dim).
 */
function placeClickableCoord( point, textField, axisAnnotObj, displayOpts, retCoords )
{

	var transformedCoordx = point.realx;
	var transformedCoordy = point.realy;

	if( axisAnnotObj.xscale.length >= 3 && axisAnnotObj.xscale.substr(0,3) == "log" ) {
		if( axisAnnotObj.xscale.length > 4 ) // log:<basis>
			point.realx = point.realx * Math.log( axisAnnotObj.xscale.substr(4) );
		else {
			// pgfplots handles log plots base e INTERNALLY, but uses base 10 for display.
			// convert to base 10:
			transformedCoordx = point.realx / Math.log(10);
		}
		point.realx = Math.exp(point.realx);
	}
	if( axisAnnotObj.yscale.length >= 3 && axisAnnotObj.yscale.substr(0,3) == "log" ) {
		if( axisAnnotObj.yscale.length > 4 ) // log:<basis>
			point.realy = point.realy * Math.log( axisAnnotObj.yscale.substr(4) );
		else {
			// pgfplots handles log plots base e INTERNALLY, but uses base 10 for display.
			// convert to base 10:
			transformedCoordy = point.realy / Math.log(10);
		}
		point.realy = Math.exp(point.realy);
	}
	if( axisAnnotObj.dim > 2 ) {
		if( axisAnnotObj.zscale.length >= 3 && axisAnnotObj.zscale.substr(0,3) == "log" ) {
			if( axisAnnotObj.zscale.length > 4 ) // log:<basis>
				point.realz = point.realz * Math.log( axisAnnotObj.zscale.substr(4) );
			else {
				// pgfplots handles log plots base e INTERNALLY, but uses base 10 for display.
				// convert to base 10:
				transformedCoordz = point.realz / Math.log(10);
			}
			point.realz = Math.exp(point.realz);
		}
	}

	// replace the text substring "(xy)" with the actual coordinates:
	var coordOff = point.text.indexOf(clickablePatternForXY);
	if( coordOff >= 0 ) {
		point.text = 
			point.text.substring( 0, coordOff ) + 
			sprintf( displayOpts.pointFormat, point.realx,point.realy,point.realz) +
			point.text.substr( coordOff+clickablePatternForXY.length );
	}
	point.draw( this, textField, displayOpts );

	if( retCoords ) {
		retCoords[0] = transformedCoordx;
		retCoords[1] = transformedCoordy;
		if( axisAnnotObj.dim > 2 )
			retCoords[2] = transformedCoordz;
	}

}

function axisMouseDown(formName ) 
{
	posOnMouseDownX = mouseX;
	posOnMouseDownY = mouseY;
}

/**
 * @param formName the name of the clickable button. It is expected to be as large as the underlying plot.
 * @param axisAnnotObj an object with the fields
 *   - xmin, xmax
 *   - ymin, ymax
 *   - xscale, yscale
 * @param displayOpts an object with the fields
 *   - pointFormat an sprintf format string to format the final point coordinates.
 *   The default is  "(\pgfplotsPERCENT.2f,\pgfplotsPERCENT.2f)"
 *   - fillColor the fill color for the annotation. Options are
 *    transparent, gray, RGB or CMYK color. Default is
 *       ["RGB",1,1,.855]
 *	 - textFont / textSize
 */
function axisMouseUp(formName, axisAnnotObj, displayOpts)
{
	if( Math.abs( mouseX - posOnMouseDownX ) > 6 \pgfplotsVERTBAR\pgfplotsVERTBAR
		Math.abs( mouseY - posOnMouseDownY ) > 6 )
	{
		axisDragNDrop( formName, axisAnnotObj, displayOpts );

	} else {
		axisClick( formName, axisAnnotObj, displayOpts );
	}
}

function axisDragNDrop( formName, axisAnnotObj, displayOpts )
{
	if( axisAnnotObj.dim == 3 )
		return;

	var result = this.getField( formName + "-result");
	var result2 = this.getField( formName + "-result2");
	var resultmark = this.getField( formName + "-resultmark");
	var result2mark = this.getField( formName + "-result2mark");
	var slope 	= this.getField( formName + "-slope" );
	if( !result ) {
		console.println( "WARNING: there is no TextField \"" + formName + "-result\" to display results for interactive element \"" + formName + "\"");
		return;
	}

	var a = this.getField(formName);
	if( ! a ) {
		console.println( "Warning: there is no form named \"" + formName + "\"" );
		return;
	}
	// dragging the mouse results in slope computation:
	// placeClickableCoord shows the endpoint coords and returns the (transformed) coordinates into tmpArray1 and tmpArray2:
	placeClickableCoord( 
		axisFindClickableCoord( axisAnnotObj, posOnMouseDownX, posOnMouseDownY, a, null ),
		result, axisAnnotObj, displayOpts, tmpArray1 );
	placeClickableCoord( 
		axisFindClickableCoord( axisAnnotObj, mouseX, mouseY, a, null ),
		result2, axisAnnotObj, displayOpts, tmpArray2 );

	var m =  ( tmpArray2[1] - tmpArray1[1] ) / ( tmpArray2[0] - tmpArray1[0] );
	var n =  tmpArray1[1] - m * tmpArray1[0];

	var slopePoint = new ClickableCoord(
		0.5 * ( mouseX + posOnMouseDownX ),
		0.5 * ( mouseY + posOnMouseDownY ),
		-1,-1,
		sprintf( displayOpts.slopeFormat, m, n ));
	slopePoint.draw(
		this,
		slope,
		displayOpts );

	// FIXME! these document rights seem to forbid modifications to annotations, although they work for text fields!?
	//var lineobj = this.getAnnot( a.page, formName + '-line' );
	//console.println( 'lineobj = ' + lineobj );
	//lineobj.points = [[mouseX,mouseY],[posOnMouseDownX,posOnMouseDownY]];
	//lineobj.display = display.visible;
}

function axisClick( formName, axisAnnotObj, displayOpts )
{
	var result = this.getField( formName + "-result");
	var result2 = this.getField( formName + "-result2");
	var resultmark = this.getField( formName + "-resultmark");
	var result2mark = this.getField( formName + "-result2mark");
	var slope 	= this.getField( formName + "-slope" );
	if( !result ) {
		console.println( "WARNING: there is no TextField \"" + formName + "-result\" to display results for interactive element \"" + formName + "\"");
		return;
	}
	result2.display = display.hidden;
	slope.display = display.hidden;
	result2mark.display = display.hidden;

	var a = this.getField(formName);
	if( ! a ) {
		console.println( "Warning: there is no form named \"" + formName + "\"" );
		return;
	}

	var point = null;
	var bSearchPoint = true;
	if( lastPoint ) {
		if( getDist( mouseX,mouseY,  lastPoint.canvasx,lastPoint.canvasy) < axisAnnotObj.snapDist ) {
			if( lastPoint.isSnapToNearestCoord() )
				++lastPoint.sourceCoordIdx;
			else
				bSearchPoint = false;

		} else
			lastPoint = null; // no search restriction.
	}
	if( bSearchPoint )
		point = axisFindClickableCoord(axisAnnotObj, mouseX, mouseY, a, lastPoint ); 

	lastPoint = point;

	// clicking twice onto the same point hides it:
	if( point == null ) {
		result.display = display.hidden;
		resultmark.display = display.hidden;
		return;
	}

	placeClickableCoord( 
		point,
		result, axisAnnotObj, displayOpts, null );
}

\end{insDLJS}
%--------------------------------------------------
% function hideClickableTextfields() {
% 	for (var i = 0; i < this.numFields; i++) {
% 		var fieldName = this.getNthFieldName(i);
% 		console.println("checking Field " + fieldName + " ... ");
% 		if( fieldName.substr( 0, 13 ) == "clickableplot" && fieldName.indexOf( "-result", 12 ) >= 0 ) {
% 			console.println("hiding Field " + fieldName + " ... ");
% 			this.getField( fieldName ).display = display.hidden;
% 		}
% 	}
% }
% hideClickableTextfields();
%-------------------------------------------------- 

\pgfkeysdef{/pgfplots/annot/xy pattern}{\pgfplots@clickable@xypat@error}%
\pgfkeysdef{/pgfplots/annot/xy pattern/.initial}{\pgfplots@clickable@xypat@error}%
\def\pgfplots@clickable@xypat@error{\pgfplots@error{Sorry, \string\pgfplotsset{annot/xy pattern/.initial=...} can only be assigned *before* \string\usepgfplotslibrary{clickable}}}%
\pgfkeysdef{/pgfplots/annot/no such coord}{\pgfplots@clickable@nosuchcoord@error}%
\pgfkeysdef{/pgfplots/annot/no such coord/.initial}{\pgfplots@clickable@nosuchcoord@error}%
\def\pgfplots@clickable@nosuchcoord@error{\pgfplots@error{Sorry, \string\pgfplotsset{annot/no such coord/.initial=...} can only be assigned *before* \string\usepgfplotslibrary{clickable}}}%

\def\pgfplots@clickable@beginaxis{%
	\pgfplotsapplistXglobalnewempty\pgfplots@clickable@collectedplots
	\gdef\pgfplots@clickable@collectedplots@isempty{1}%
}%

\def\pgfplots@clickable@startcoordcollect{%
	\pgfplotsapplistXnewempty\pgfplots@clickable@collectedplot
	\def\pgfplots@clickable@collectedplot@isempty{1}%
}%
\def\pgfplots@clickable@coordcollect#1{%
	\begingroup
	\pgfplotscoordmath{x}{tostring}\pgfplots@current@point@x
	\let\pgfplots@current@point@x=\pgfmathresult
	\pgfplotscoordmath{y}{tostring}\pgfplots@current@point@y
	\let\pgfplots@current@point@y=\pgfmathresult
	\ifpgfplots@curplot@threedim
		\pgfplotscoordmath{z}{tostring}\pgfplots@current@point@z
		\let\pgfplots@current@point@z=\pgfmathresult
	\fi
	\begingroup
		#1%
		\xdef\pgfplots@glob@TMPa{\pgfplotsretval}%
	\endgroup
	\xdef\pgfplots@glob@TMPa{\if1\pgfplots@clickable@collectedplot@isempty\else,\fi[\pgfplots@current@point@x,\pgfplots@current@point@y\ifpgfplots@curplot@threedim,\pgfplots@current@point@z\fi,"\pgfplots@glob@TMPa"]}%
	\endgroup
	\expandafter\pgfplotsapplistXpushback\expandafter{\pgfplots@glob@TMPa}\to\pgfplots@clickable@collectedplot
	\def\pgfplots@clickable@collectedplot@isempty{0}%
}%
\def\pgfplots@clickable@endcoordcollect{%
	\pgfplotsapplistXlet\pgfplots@clickable@collectedplot@=\pgfplots@clickable@collectedplot
	\if1\pgfplots@clickable@collectedplots@isempty
		\expandafter\pgfplotsapplistXglobalpushback\expandafter{\expandafter[\pgfplots@clickable@collectedplot@]}\to\pgfplots@clickable@collectedplots
	\else
		\expandafter\pgfplotsapplistXglobalpushback\expandafter{\expandafter,\expandafter[\pgfplots@clickable@collectedplot@]}\to\pgfplots@clickable@collectedplots
	\fi
	\gdef\pgfplots@clickable@collectedplots@isempty{0}%
}%

% Creates an area which is clickable. A click produces a popup which
% contains information about the point under the cursor.
%
% The complete (!) context needs to be provided using key-value-pairs,
% either in '#1' or set before invocation of \pgfplotsclickablecreate.
%
% This command actually creates an AcroForm which employs javascript
% whenever it is clicked. A javascript Object is created which
% represents the context (axis limits and options). This javascript
% object is available at runtime.
%
% @remark This method is public and it is NOT restricted to pgfplots.
% The pgfplots hook simply initialises the required key-value-pairs in
% '#1'.
% @remark This method does not draw anything. It initialises only a
% clickable area and javascript code.
%
% The required key-value-pairs are documented in the pdf-manual or can
% be seen above.
%
% @attention Complete key-value validation is NOT performed here. It
% can happen that invalid options will produce javascript bugs when
% opened with Acrobat Reader. Use the javascript console to find them.
\def\pgfplotsclickablecreate[#1]{%
	\def\pgfplots@loc@TMPa{#1}%
	\ifx\pgfplots@loc@TMPa\pgfutil@empty
	\else
		\pgfqkeys{/pgfplots/annot}{#1}%
	\fi
	\pgfkeysgetvalue{/pgfplots/annot/jsname}\pgfplots@clickable@uniquename
	\ifx\pgfplots@clickable@uniquename\pgfutil@empty
		\edef\pgfplots@clickable@uniquename{clickableplot\pgfplots@clickable@no}%
		\begingroup
			\c@pgf@counta=\pgfplots@clickable@no\relax
			\advance\c@pgf@counta by1
			\xdef\pgfplots@clickable@no{\the\c@pgf@counta}%
		\endgroup
	\fi
	%
	\pgfkeysgetvalue{/pgfplots/annot/collected plots}\pgfplots@clickable@collectedplots@@
	\ifx\pgfplots@clickable@collectedplots@@\pgfutil@empty
		\def\pgfplots@clickable@collectedplots@@{[]}%
	\fi
	%
	\edef\pgfplots@clickable@expanded@args{%
		{\pgfkeysvalueof{/pgfplots/annot/width}}%
		{\pgfkeysvalueof{/pgfplots/annot/height}}%
		{\pgfplots@clickable@uniquename}%
		{{
			dim:	\pgfkeysvalueof{/pgfplots/annot/dim},
			xmin:	\pgfkeysvalueof{/pgfplots/annot/xmin}, 
			xmax:	\pgfkeysvalueof{/pgfplots/annot/xmax},
			ymin:	\pgfkeysvalueof{/pgfplots/annot/ymin},
			ymax:	\pgfkeysvalueof{/pgfplots/annot/ymax},
			xscale:	"\pgfkeysvalueof{/pgfplots/annot/xscale}",
			yscale:	"\pgfkeysvalueof{/pgfplots/annot/yscale}",
			\ifnum\pgfkeysvalueof{/pgfplots/annot/dim}=3
			zmin:	\pgfkeysvalueof{/pgfplots/annot/zmin},
			zmax:	\pgfkeysvalueof{/pgfplots/annot/zmax},
			zscale:	"\pgfkeysvalueof{/pgfplots/annot/zscale}",
			zaxis:		\pgfkeysvalueof{/pgfplots/annot/z axis},
			\fi
			collectedPlots: \pgfplots@clickable@collectedplots@@,
			snapDist:	\pgfkeysvalueof{/pgfplots/annot/snap dist},
			minminmin:		\pgfkeysvalueof{/pgfplots/annot/minminmin},
			xaxis:		\pgfkeysvalueof{/pgfplots/annot/x axis},
			yaxis:		\pgfkeysvalueof{/pgfplots/annot/y axis}
		}}%
		{{
			pointFormat: "\ifnum\pgfkeysvalueof{/pgfplots/annot/dim}=3 \pgfkeysvalueof{/pgfplots/annot/point format 3d}\else \pgfkeysvalueof{/pgfplots/annot/point format}\fi",
			slopeFormat: "\pgfkeysvalueof{/pgfplots/annot/slope format}",
			fillColor:\pgfkeysvalueof{/pgfplots/annot/js fillColor},
			textFont:\pgfkeysvalueof{/pgfplots/annot/font},
			textSize:\pgfkeysvalueof{/pgfplots/annot/textSize},
			printable: \ifpgfplots@annot@printable true\else false\fi
		}}%
	}%
	\expandafter\pgfplots@create@clickable@plotarea\pgfplots@clickable@expanded@args
}%


% This thing is invoked from within pgfplots. It prepares and invokes
% \pgfplotsclickablecreate.
% 
\def\pgfplots@create@clickable@plotarea@hook{%
	\ifpgfplots@clickable
		\begingroup
		% communicate collected plot coordinates:
		\pgfplotsapplistXgloballet\pgfplots@clickable@collectedplots@@=\pgfplots@clickable@collectedplots
		\pgfplotsapplistXglobalnewempty\pgfplots@clickable@collectedplots
		\def\pgfplots@generate@clickable{1}%
		\ifpgfplots@threedim
			\ifx\pgfplots@clickable@collectedplots@@\pgfutil@empty
				\def\pgfplots@generate@clickable{0}%
			\fi
		\fi
		\if1\pgfplots@generate@clickable
			\t@pgfplots@tokc=\expandafter{\pgfplots@clickable@collectedplots@@}%
			\edef\pgfplots@clickable@collectedplots@@{[\the\t@pgfplots@tokc]}%
			\pgfkeyslet{/pgfplots/annot/collected plots}\pgfplots@clickable@collectedplots@@
			%
			\pgfplotscoordmath{x}{datascaletrafo inverse}{\pgfplots@xmin}%
			\pgfplotscoordmath{x}{tostring}{\pgfmathresult}%
			\let\pgfplots@clickable@xmin=\pgfmathresult
			\pgfplotscoordmath{x}{datascaletrafo inverse}{\pgfplots@xmax}%
			\pgfplotscoordmath{x}{tostring}{\pgfmathresult}%
			\let\pgfplots@clickable@xmax=\pgfmathresult
			%
			\pgfplotscoordmath{y}{datascaletrafo inverse}{\pgfplots@ymin}%
			\pgfplotscoordmath{y}{tostring}{\pgfmathresult}%
			\let\pgfplots@clickable@ymin=\pgfmathresult
			\pgfplotscoordmath{y}{datascaletrafo inverse}{\pgfplots@ymax}%
			\pgfplotscoordmath{y}{tostring}{\pgfmathresult}%
			\let\pgfplots@clickable@ymax=\pgfmathresult
			%
			\ifpgfplots@threedim
				\pgfplotscoordmath{z}{datascaletrafo inverse}{\pgfplots@zmin}%
				\pgfplotscoordmath{z}{tostring}{\pgfmathresult}%
				\let\pgfplots@clickable@zmin=\pgfmathresult
				\pgfplotscoordmath{z}{datascaletrafo inverse}{\pgfplots@zmax}%
				\pgfplotscoordmath{z}{tostring}{\pgfmathresult}%
				\let\pgfplots@clickable@zmax=\pgfmathresult
			\fi
			%
			% Convert to user interface of clickable lib:
			\pgfplotspointbbdiagonal
			\edef\pgfplots@clickable@wd{\the\pgf@x}%
			\pgfkeyslet{/pgfplots/annot/width}\pgfplots@clickable@wd
			\edef\pgfplots@clickable@ht{\the\pgf@y}%
			\pgfkeyslet{/pgfplots/annot/height}\pgfplots@clickable@ht
			\pgfkeyslet{/pgfplots/annot/xmin}\pgfplots@clickable@xmin
			\pgfkeyslet{/pgfplots/annot/xmax}\pgfplots@clickable@xmax
			\pgfkeyslet{/pgfplots/annot/ymin}\pgfplots@clickable@ymin
			\pgfkeyslet{/pgfplots/annot/ymax}\pgfplots@clickable@ymax
			\ifpgfplots@xislinear
				\pgfkeyssetvalue{/pgfplots/annot/xscale}{linear}%
			\else
				\pgfkeyssetvalue{/pgfplots/annot/xscale}{log:\pgfkeysvalueof{/pgfplots/log basis x}}%
			\fi
			\ifpgfplots@yislinear
				\pgfkeyssetvalue{/pgfplots/annot/yscale}{linear}%
			\else
				\pgfkeyssetvalue{/pgfplots/annot/yscale}{log:\pgfkeysvalueof{/pgfplots/log basis y}}%
			\fi
			\ifpgfplots@threedim
				\pgfkeyslet{/pgfplots/annot/zmin}\pgfplots@clickable@zmin
				\pgfkeyslet{/pgfplots/annot/zmax}\pgfplots@clickable@zmax
				\ifpgfplots@zislinear
					\pgfkeyssetvalue{/pgfplots/annot/zscale}{linear}%
				\else
					\pgfkeyssetvalue{/pgfplots/annot/zscale}{log:\pgfkeysvalueof{/pgfplots/log basis z}}%
				\fi
			\fi
			%
			% note that \pgfplotspointbblowerleft has *not* been
			% transformed after \endtikzpicture in pgfplots.code.tex.
			% That's why I can use it here:
			\pgfpointdiff
				\pgfplotspointbblowerleft
				{\pgfplotspointminminmin}%
			\pgf@sys@bp@correct\pgf@x \pgf@sys@bp@correct\pgf@y
			\edef\pgfplots@loc@TMPa{[\pgf@sys@tonumber\pgf@x, \pgf@sys@tonumber\pgf@y]}%
			\pgfkeyslet{/pgfplots/annot/minminmin}\pgfplots@loc@TMPa
			%
			\pgfplotspointxaxis
			\pgf@sys@bp@correct\pgf@x \pgf@sys@bp@correct\pgf@y
			\edef\pgfplots@loc@TMPa{[\pgf@sys@tonumber\pgf@x, \pgf@sys@tonumber\pgf@y]}%
			\pgfkeyslet{/pgfplots/annot/x axis}\pgfplots@loc@TMPa
			%
			\pgfplotspointyaxis
			\pgf@sys@bp@correct\pgf@x \pgf@sys@bp@correct\pgf@y
			\edef\pgfplots@loc@TMPa{[\pgf@sys@tonumber\pgf@x, \pgf@sys@tonumber\pgf@y]}%
			\pgfkeyslet{/pgfplots/annot/y axis}\pgfplots@loc@TMPa
			%
			\ifpgfplots@threedim
				\pgfplotspointzaxis
				\pgf@sys@bp@correct\pgf@x \pgf@sys@bp@correct\pgf@y
				\edef\pgfplots@loc@TMPa{[\pgf@sys@tonumber\pgf@x, \pgf@sys@tonumber\pgf@y]}%
				\pgfkeyslet{/pgfplots/annot/z axis}\pgfplots@loc@TMPa
			\fi
			%
			\pgfkeyssetvalue{/pgfplots/annot/dim}{\ifpgfplots@threedim 3\else2\fi}%
			%
			%
			\pgfinterruptboundingbox%
			\pgftext[left,bottom,at=\lowerleftinnercorner]{\pgfplotsclickablecreate[]}%
			\endpgfinterruptboundingbox%
		\fi
		\endgroup
	\fi
}

% This is the low-level method which creates Acroforms and Javascript
% code.
% #1: width
% #2: height
% #3: name
% #4: the axisAnnotObj object (see javascript docs above)
% #5: the displayOpts object (see javascript docs above)
\def\pgfplots@create@clickable@plotarea#1#2#3#4#5{%
%\tracingmacros=2\tracingcommands=2
	%\leavevmode
	%--------------------------------------------------
	% hyperref.sty implementation:
	%--------------------------------------------------
	% \PushButton[name=#3,borderwidth=0,bordersep=0,
	%        onclick={processAnnotatedPlot("#3", #4, #5);}]{\vbox to #2{\hsize=#1\vfill\hfill}}%
	% \TextField[name=#3-result,hidden=true]{}%
	%-------------------------------------------------- 
	%
	%-------------------------------------------------- 
	% eforms.sty implementation:
	% it allows more customization.
	%-------------------------------------------------- 
	%
	% Hier kommen Annotation Directories zum Zuge!
	% -> siehe Annotations in pdf reference
	\def\pushButtonDefaults{	
		\W{0}% border width
		\Border{0 0 0}%
	}%
	\def\textFieldDefaults{%
		\W{1}% border width
		\S{B}% border style ( one of SDBIU )
		\F{2}% "display" bitflag. 2^1= hidden (see "Annotation Flags" in pdf reference)
		%ATTENTION: \F 2 (hidden) produces INCOMPATIBILITIES with figure environment!?
		%  ---> ok, that has been fixed by recent versions of hyperref.
		%  (the pdf catalog may be incomplete in older hyperref pdftex drivers)
		\Ff{1}% "Field characteristics" bitflag. 2^0 = "read-only"
	}%
	\pushButton[
		%\A{/S/JavaScript/JS(processAnnotatedPlot("#3", #4, #5);)}%
		\AA{
			% /U = "mouse UP"
			% /D = "mouse DOWN"
			/U << /S/JavaScript/JS(axisMouseUp("#3", #4, #5);) >> 
			/D << /S/JavaScript/JS(axisMouseDown("#3");) >> 
		}%
		]
		{#3}
		{#1}{#2}%
	\textField{#3-result}{0pt}{0pt}%
	\textField{#3-result2}{0pt}{0pt}%
	\textField{#3-resultmark}{0pt}{0pt}%
	\textField{#3-result2mark}{0pt}{0pt}%
	\textField{#3-slope}{0pt}{0pt}%
	% Unfortunately, line annotations can't be created/changed in acrobat
	% javascript due to right problems :-(
	%--------------------------------------------------
	% \hbox to 0pt{\vsize=0pt \pdfannot{
	% 		/Subtype	/Line
	% 		/Open		/false
	% 		/NM			(#3-line)
	% 		/C			
	% 		/CA			
	% 		/Subj		()
	% 		/Contents	()
	% 		/L			[0 0 0 0]
	% 		/LE			[/None /OpenArrow] % PDF 1.4
	% 	%	/Ff			194
	% }}%
	%-------------------------------------------------- 
	%	
	%
	%\setLinkBbox[%
	%	\Border{}%
	%	\A{/S/JavaScript/JS(processme("#3");)}%
	%	\rawPDF{/C[1 0 0] /NM (#3)}%
	%  ]%
	%  {#1}{#2}{}%
}

\catcode`\"=\pgfplotscatcodeDQ
\endinput
